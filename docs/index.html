<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Uma Builder â€” Card Picker</title>
<style>
:root {
  --card-w: 120px;
  --gap: 6.5px;
  --card-gap: 6.5px;
}

/* --------- RESET & BASE STYLES --------- */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

body {
  font-family: Arial, Helvetica, sans-serif;
  background: #fff;
  color: #111;
}

/* --------- HEADER --------- */
.header {
  height: 70px;
  background: #fff;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 30px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header-left {
  display: flex;
  align-items: center;
}

.header-logo {
  height: 40px;
  width: auto;
}

.header-title {
  margin-left: 12px;
  font-size: 18px;
  font-weight: bold;
  color: #333;
}

.header-nav {
  display: flex;
  align-items: center;
  gap: 10px;
}

.dark-mode-toggle {
  background: none;
  border: 2px solid #666;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dark-mode-toggle:hover {
  background: #444;
  border-color: #888;
  transform: scale(1.1);
}

/* --------- LAYOUT --------- */
.container {
  display: flex;
  width: 100%;
  height: calc(100vh - 70px);
  overflow: hidden;
}

.sidebar, .right-sidebar {
  flex-shrink: 0;
  padding: 16px 12px;
  box-sizing: border-box;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  scrollbar-width: none;
  -ms-overflow-style: none;
  height: 100%;
}

.sidebar::-webkit-scrollbar,
.right-sidebar::-webkit-scrollbar {
  display: none;
}

.sidebar > *:not(:last-child),
.right-sidebar > *:not(:last-child) {
  margin-bottom: 12px;
}

.sidebar {
  width: 200px;
  background: #f9f9f9;
}

.right-sidebar {
  background: #f5f5f5;
  border-left: 1px solid #ddd;
  align-items: center;
  overflow-y: auto !important;
  overflow-x: hidden;
  position: relative;
  transition: all 0.3s ease;
}

.right-sidebar.collapsed {
  --card-gap: 7px;
  max-width: 140px;
}

.collapse-toggle {
  position: sticky;
  top: 50vh;
  left: 0;
  width: 15px;
  height: 150px;
  margin-left: 16px;
  border: 2px solid #ddd;
  border-radius: 4px 0 0 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 14px;
  font-weight: bold;
  z-index: 1000;
  transition: all 0.3s ease;
  float: left;
  transform: translateY(-50%);
}

.collapse-toggle:hover {
  background: #333;
  transform: translateY(-50%) scale(1.1);
}

.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  overflow-y: auto;
  padding: 16px 0 16px 16px;
  box-sizing: border-box;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.main-content::-webkit-scrollbar {
  display: none;
}

.content-wrapper {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: flex-start;
  width: 100%;
  margin: 0 auto;
}

/* --------- FORM CONTROLS --------- */
.filter-group, .toggle-button-group {
  display: flex;
  flex-direction: column;
  transition: opacity 0.3s ease;
}

.filter-group > label:not(.checkbox-label),
.toggle-button-group label {
  margin-bottom: 4px;
  font-weight: 600;
  font-size: 13px;
}

.sidebar select, 
.sidebar .skill-search,
.search-input-container input {
  width: 100%;
  padding: 6px 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  margin-bottom: -4px;
}

.checkbox-label input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
}

/* --------- BUTTONS --------- */
.clear-all, #clearFiltersBtn, #togglePresetCardsBtn {
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  width: 100%;
  font-weight: 600;
}

.clear-all:hover, #clearFiltersBtn:hover, #togglePresetCardsBtn:hover {
  background: #333;
}

.clear-all, #clearAllBtn {
  background: #8B0000 !important;
  color: #fff;
}

.clear-all:hover, #clearAllBtn:hover {
  background: #A52A2A !important;
}

#clearFiltersBtn {
  background: #8B0000 !important;
  color: #fff;
}

#clearFiltersBtn:hover {
  background: #A52A2A !important;
}

.copy-paste-buttons {
  display: flex;
  gap: 6px;
  width: 100%;
  margin-bottom: 8px;
}

.copy-paste-btn {
  flex: 1;
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  font-weight: 600;
}

.copy-paste-btn:hover {
  background: #333;
}

.copy-paste-btn:active {
  transform: translateY(1px);
}

.deck-buttons {
  display: grid;
  grid-template-columns: repeat(3, var(--card-w));
  gap: var(--gap);
  width: 100%;
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2);
  margin-bottom: 1px;
}

.deck-btn, .slots-header .clear-all {
  width: var(--card-w);
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  font-weight: 600;
  box-sizing: border-box;
}

.deck-btn:hover, .slots-header .clear-all:hover {
  background: #333;
}

.deck-btn:active, .slots-header .clear-all:active {
  transform: translateY(1px);
}

/* --------- TOGGLE BUTTONS --------- */
.toggle-buttons-row {
  display: flex;
  justify-content: flex-start;
}

.toggle-button {
  background: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border: none;
}

.toggle-button:hover {
  background: #f0f0f0;
}

.toggle-button.active {
  background: none;
}

.toggle-button img {
  display: block;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  filter: grayscale(100%) opacity(0.6);
  transition: filter 0.2s ease;
}

.toggle-button.active img {
  filter: grayscale(0%) opacity(1);
}

.toggle-button:hover img {
  filter: grayscale(100%) opacity(0.8);
}

.rarity-buttons .toggle-buttons-row {
  width: 100%;
  gap: 2px;
}

.rarity-buttons .toggle-button {
  flex: 1;
  aspect-ratio: 53 / 22;
  border-radius: 0;
  border-right: none;
  background: none;
}

.type-buttons .toggle-buttons-row {
  width: 100%;
  gap: 1px;
  flex-wrap: wrap;
}

.type-buttons .toggle-button {
  flex: 1;
  border: none;
  border-radius: 0;
  aspect-ratio: 1;
  min-width: 0;
}

/* --------- SKILL SEARCH --------- */
#skillSearchGroup {
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}

.skill-search-divider {
  min-height: 1px;
  background: #333;
  margin-bottom: 12px;
  width: 100%;
}

.skill-search-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0;
}

#skillSearchGroup label {
  margin-bottom: 0;
  font-weight: 600;
  font-size: 13px;
}

.add-search-btn {
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  width: 48px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

.add-search-btn:hover {
  background: #333;
}

.search-input-container {
  display: flex;
  align-items: center;
  gap: 4px;
  width: 100%;
}

.remove-search-btn {
  width: 24px;
  height: 24px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #f5f5f5;
  color: #666;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  flex-shrink: 0;
}

.remove-search-btn:hover {
  background: #e5e5e5;
  color: #333;
}

.skill-search-buttons {
  display: flex;
  gap: 6px;
}

.clear-search-btn {
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #8B0000 !important;
  color: #fff;
  transition: background-color 0.2s;
  width: 48px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

.clear-search-btn:hover {
  background: #A52A2A !important;
}

/* --------- CARDS & SLOTS --------- */
.cards, .slots {
  display: grid;
  grid-template-columns: repeat(auto-fill, var(--card-w));
  gap: var(--card-gap);
  width: 100%;
  justify-content: start;
  align-items: start;
}

.cards {
  grid-auto-rows: 0;
  grid-template-rows: 1fr;
  overflow: hidden;
}

.slots {
  grid-template-columns: repeat(3, var(--card-w));
  grid-auto-rows: min-content;
  max-width: calc(var(--card-w) * 3 + var(--card-gap) * 2);
  margin: 35px auto 0;
  height: auto;
  min-height: min-content;
}

.right-sidebar.collapsed .slots {
  grid-template-columns: 1fr;
  max-width: 100%;
  margin-top: 40px;
  margin-bottom: 8px;
  gap: 30px;
  height: auto;
  min-height: min-content;
}

.card, .slot {
  border: 1px solid #ddd;
  padding: 6px;
  box-sizing: border-box;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: var(--card-w);
  position: relative;
  min-height: 0;
  height: auto;
}

.slot {
  padding: 8px;
  cursor: pointer;
  min-height: var(--card-w);
  height: min-content;
  justify-self: start;
  transition: min-height 0.3s ease;
}

.slot:not(.has-card) {
  border: 2px dashed #ccc;
  background: #fafafa;
  aspect-ratio: 1;
  height: var(--card-w);
}

.slot.has-card {
  height: auto;
}

.slot .placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ccc;
  font-size: 11px;
}

.card .name, .slot.has-card .name {
  margin: 6px 0 4px;
  font-weight: 700;
  text-align: center;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card img, .slot.has-card img {
  max-width: calc(var(--card-w) * 0.8);
  max-height: calc(var(--card-w) * 0.8);
  object-fit: contain;
}

.card .skills, .slot.has-card .skills,
.card .skills-group, .slot.has-card .skills-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 100%;
  align-items: center;
  min-height: 0;
}

.skills-group {
  min-height: 0;
}

.skills-group.hidden-skill {
  display: none !important;
  margin: 0 !important;
  gap: 0 !important;
}

.skills-group:not(.hidden-skill) + .skills-group:not(.hidden-skill) {
  margin-top: 8px;
}

.skills-group:not(.hidden-skill):first-child {
  margin-top: 0;
}

.skill {
  width: 100%;
  background: #eef2ff;
  border-radius: 4px;
  padding: 2px 4px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
}

.skills-header {
  font-size: 9px;
  font-weight: bold;
  margin-top: 6px;
  text-align: center;
  background: #000;
  color: #fff;
  padding: 3px 4px;
  border-radius: 0;
  width: 100%;
}

.card .type-icon, .slot.has-card .type-icon {
  position: absolute;
  top: 0px;
  right: 0px;
  width: 32px;
  height: 32px;
  overflow: hidden;
}

.card .type-icon img, .slot.has-card .type-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

/* --------- SLOT LEVEL CONTROLS --------- */
.slot-container {
  position: relative;
  width: var(--card-w);
}

.slot-container:nth-child(-n+3) {
  margin-bottom: 40px;
}

.slot-container:nth-child(n+4) {
  margin-bottom: 0;
}

.slot-level-controls {
  position: absolute;
  top: -35px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 8px;
  background: #f8f8f8;
  border: 1px solid #ddd;
  border-radius: 4px;
  z-index: 20;
  pointer-events: auto;
}

.slot:not(.has-card) .slot-level-controls {
  display: none;
}

.slot-level-label {
  font-size: 12px;
  font-weight: bold;
  color: #333;
}

.slot-level-input {
  width: 40px;
  height: 20px;
  border: 1px solid #ccc;
  border-radius: 3px;
  text-align: center;
  font-size: 12px;
  font-weight: bold;
  background: #fff;
}

.slot-level-input:focus {
  outline: none;
  border-color: #444;
}

.right-sidebar.collapsed .slot-level-controls {
  padding: 2px 4px;
  top: -25px;
}

.right-sidebar.collapsed .slot-level-label {
  font-size: 10px;
}

.right-sidebar.collapsed .slot-level-input {
  width: 30px;
  height: 14px;
  font-size: 10px;
}

/* --------- SECTIONS & PAGINATION --------- */
.card-sections {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: 100%;
  gap: 10px;
}

.card-section {
  position: relative;
  width: 100%;
}

.card-section-header {
  position: relative;
  display: block;
  margin: 0 0 10px;
  width: 100%;
}

.card-section-header h2 {
  margin: 0;
}

.page-controls {
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  gap: 8px;
}

.page-controls button {
  border: none;
  background: #444;
  color: #fff;
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 12px;
  font-weight: bold;
  cursor: pointer;
  min-width: 32px;
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
  line-height: 1;
}

.page-controls button:hover:not(:disabled) {
  background: #333;
}

.page-controls button:disabled {
  background: #999;
  color: #ccc;
  cursor: not-allowed;
}

.card.disabled {
  opacity: 0.45;
}

/* --------- UTILITY CONTROLS --------- */
.sort-order-btn {
  border: 1px solid #ccc;
  background: #f5f5f5;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

.sort-order-btn:hover {
  background: #e5e5e5;
  border-color: #999;
}

.sort-order-btn.ascending {
  background: #444;
  color: #fff;
  border-color: #444;
}

/* --------- COLOR PICKER --------- */
.color-picker {
  width: 20px;
  height: 20px;
  border: 2px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 0.2s ease;
}

.color-picker:hover {
  border-color: #999;
  transform: scale(1.1);
}

.color-picker.green { background: #bce934; }
.color-picker.blue { background: #1cd8fe; }
.color-picker.orange { background: #fdb832; }
.color-picker.red { background: #fca5a5; }

.color-picker.green-border { 
  background: #57ad33;
  border-color: #fff96b;
  border-width: 3px;
}
.color-picker.blue-border { 
  background: #14a1f7;
  border-color: #fff96b;
  border-width: 3px;
}
.color-picker.orange-border { 
  background: #fa9937;
  border-color: #fff96b;
  border-width: 3px;
}
.color-picker.red-border { 
  background: #f75757;
  border-color: #fff96b;
  border-width: 3px;
}

/* --------- SKILLS LIST --------- */
.selected-skills-section {
  width: 100%;
  margin-top: 16px;
}

.skills-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding: 0 4px;
}

.skills-list-header h3 {
  margin: 0;
  font-size: 14px;
  font-weight: bold;
  color: #333;
}

.skills-count {
  font-size: 12px;
  color: #666;
  font-weight: normal;
}

.skills-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 400px;
  overflow-y: auto;
  padding-right: 4px;
}

.skills-list::-webkit-scrollbar {
  width: 4px;
}

.skills-list::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 2px;
}

.skills-list::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 2px;
}

.skills-list::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

.skill-item {
  background: #eef2ff;
  border-radius: 4px;
  padding: 6px 8px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
  transition: all 0.2s ease;
  border: 1px solid #ddd;
}

.skill-item.highlighted {
  background: #ffae77;
  color: #000;
}

.skill-item.search-highlighted {
  color: white;
}

/* --------- VISIBILITY CONTROLS --------- */
.sidebar-filters-section {
  transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar-filters-section.hidden {
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  pointer-events: none;
  margin-bottom: 0 !important;
  gap: 0;
}

.skill.hidden-skill,
.skills-header.hidden-skill,
.skills-group.hidden-skill,
.skill-item.hidden-skill {
  display: none;
}

.skills:empty,
.skills:has(.skills-group.hidden-skill:only-child),
.skills:has(.skills-group.hidden-skill:first-child + .skills-group.hidden-skill:last-child) {
  display: none;
}

.skill.search-highlighted {
  background: #ff4444;
  color: white;
}

/* --------- SKILL HIGHLIGHTING WITH BORDERS --------- */
.skill.search-highlighted,
.skill.highlighted {
  position: relative;
  z-index: 1;
}

.skill.search-highlighted[data-has-border="true"],
.skill.highlighted[data-has-border="true"] {
  border: 2px solid #fff96b;
  box-shadow: 0 0 0 1px #fff96b;
  color: #ffffff !important;
  padding: 1px 3px;
}

.skill-item.search-highlighted[data-has-border="true"],
.skill-item.highlighted[data-has-border="true"] {
  border: 2px solid #fff96b;
  box-shadow: 0 0 0 1px #fff96b;
  padding: 5px 7px;
  color: #ffffff !important;
}

.skill.search-highlighted:not([data-has-border="true"]),
.skill.highlighted:not([data-has-border="true"]) {
  color: #000000 !important;
}

.skill-item.search-highlighted:not([data-has-border="true"]),
.skill-item.highlighted:not([data-has-border="true"]) {
  color: #000000 !important;
}

/* --------- SLOT SELECTION --------- */
.slot-container.selected .slot:not(.has-card) {
  border: 2px solid #ff4444 !important;
  background: rgba(255, 68, 68, 0.05);
  cursor: pointer;
}

.slot:not(.has-card) {
  border: 2px dashed #ccc;
  background: #fafafa;
  aspect-ratio: 1;
  height: var(--card-w);
  transition: border 0.2s ease;
}

.slot-container.selected {
  outline: none !important;
  border: none !important;
  background: transparent !important;
  cursor: pointer;
}

.slot-container:not(.has-card) {
  cursor: pointer;
}

.slot-container.has-card {
  cursor: default;
}

.slot-container.flash-warning {
  animation: flashRed 1s ease-in-out;
}

@keyframes flashRed {
  0%, 100% { background-color: transparent; }
  25%, 75% { background-color: rgba(255, 0, 0, 0.3); }
  50% { background-color: rgba(255, 0, 0, 0.6); }
}

/* --------- EFFECTS DISPLAY --------- */
.effects-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin: 0 0 8px 0;
  font-weight: bold;
  font-size: 12px;
  color: #333;
  border-bottom: 1px solid #ddd;
  padding-bottom: 8px;
}

.effects-header .effect-label {
  text-align: left;
  min-width: 50px;
}

.effects-header .total-label {
  min-width: 50px;
  text-align: right;
}

.effects-header .cards-label {
  min-width: 120px;
  text-align: right;
  padding-right: 8px;
}

.effect-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-bottom: 3px;
  padding: 3px 0px;
  border-radius: 3px;
  transition: background-color 0.2s ease;
  min-height: 36px;
}

.effect-row:hover {
  background-color: rgba(0, 0, 0, 0.03);
}

.effect-info {
  display: flex;
  align-items: center;
  min-width: 150px;
  flex-shrink: 0;
}

.effect-name {
  font-size: 11px;
  font-weight: 500;
  color: #333;
  min-width: 130px;
}

.effect-value {
  font-size: 11px;
  font-weight: bold;
  color: #2c5e1a;
  min-width: 30px;
  text-align: center;
  background: #f0f8f0;
  margin-left: 3px;
  padding: 13px 4px;
  border-radius: 2px;
  border: 1px solid #e0f0e0;
}

.effect-cards {
  display: flex;
  gap: 1px;
  align-items: center;
  justify-content: flex-end;
  min-height: 40px;
  flex-wrap: nowrap;
  max-width: 186px;
  overflow: hidden;
}

.effect-cards.has-many-cards {
  overflow-x: auto;
  scrollbar-width: thin;
  scrollbar-color: #ccc transparent;
}

.effect-cards.has-many-cards::-webkit-scrollbar {
  height: 3px;
}

.effect-cards.has-many-cards::-webkit-scrollbar-track {
  background: transparent;
}

.effect-cards.has-many-cards::-webkit-scrollbar-thumb {
  background-color: #ccc;
  border-radius: 2px;
}

.effect-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 30px;
  flex-shrink: 0;
  position: relative;
}

.effect-card-img {
  width: 24px;
  height: 24px;
  border-radius: 2px;
  border: 1px solid #ddd;
  object-fit: cover;
  background: #fff;
}

.effect-card-value {
  font-size: 8px;
  font-weight: bold;
  color: #2c5e1a;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 1px;
  padding: 0 1px;
  margin-top: 1px;
  line-height: 1.1;
  text-align: center;
  min-width: 100%;
  border: 0.5px solid #e0e0e0;
}

/* --------- LEVEL & DIAMONDS DISPLAY --------- */
.main-content .level-diamond-container {
  position: absolute;
  top: 79px;
  display: flex;
  z-index: 5;
  background: rgba(0, 0, 0, 0.9);
  padding: 3px;
  border-radius: 6px;
  pointer-events: auto;
}

.right-sidebar .level-diamond-container {
  position: absolute;
  top: 81px;
  display: flex;
  z-index: 5;
  background: rgba(0, 0, 0, 0.9);
  padding: 3px;
  border-radius: 6px;
  pointer-events: auto;
}

.level-diamond-container * {
  pointer-events: none;
}

.level-badge-combined {
  color: rgb(255, 255, 255);
  font-size: 11px;
  min-width: 30px;
  text-align: center;
  pointer-events: auto;
}

.diamond-icons-combined {
  display: flex;
  margin: 0 2px;
}

.diamond-icon-combined {
  width: 11.5px;
  height: auto;
  aspect-ratio: 40 / 34;
  object-fit: contain;
}

.right-sidebar.collapsed .level-diamond-container {
  position: absolute;
  top: 50px;
  display: flex;
  z-index: 5;
  background: rgba(0, 0, 0, 0.9);
  padding: 3px;
  border-radius: 6px;
  pointer-events: auto;
}

.right-sidebar.collapsed .diamond-icons {
  position: absolute;
  top: 53px !important;
  right: 0px !important;
  display: flex !important;
  z-index: 10;
  transform: scale(1) !important;
  transform-origin: top right !important;
  background: rgba(0, 0, 0, 0.9) !important;
  padding: 1px 2px !important;
  border-radius: 3px;
  gap: 0px;
}

.right-sidebar.collapsed .diamond-icon {
  width: 9px !important;
  height: 12px !important;
  object-fit: contain;
}

.right-sidebar.collapsed .level-badge {
  position: absolute;
  top: 52px !important;
  left: 1px !important;
  background: rgba(0, 0, 0, 0.9) !important;
  color: white;
  padding: 3px 7px !important;
  font-size: 12px !important;
  font-weight: bold;
  z-index: 10;
  transform: scale(0.8) !important;
  transform-origin: top left !important;
  border-radius: 3px;
}

/* --------- CHARACTER PICKER --------- */
.character-picker-section {
  display: flex;
  width: 100%;
  gap: 12px;
  margin-bottom: 8px;
  align-items: flex-start;
}

.character-picker-left-column {
  width: var(--card-w);
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0;
}

.character-picker-empty-box {
  width: auto;
  height: 120px;
  border: 2px dashed #ccc;
  background: #fafafa;
  border-radius: 4px;
}

.character-picker-info {
  display: flex;
  flex-direction: column;
  width: 100%;
  gap: 4px;
}

.character-picker-name {
  font-weight: bold;
  font-size: 12px;
  text-align: center;
  background: #eef2ff;
  padding: 4px 4px;
  border-radius: 4px;
  word-break: break-word;
  line-height: 2;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 0;
}

.character-picker-costume {
  font-size: 11px;
  text-align: center;
  background: #f0f8ff;
  padding: 3px 4px;
  border-radius: 4px;
  word-break: break-word;
  line-height: 1.2;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 0;
}

.character-picker-rows {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: var(--card-w);
}

.character-picker-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0px 8px;
  background: #f8f8f8;
  border-radius: 4px;
  min-height: 24px;
}

.character-picker-row-2,
.character-picker-row-4,
.character-picker-row-6,
.character-picker-row-8 {
  background: #e8e8e8;
}

.character-picker-row-1,
.character-picker-row-3,
.character-picker-row-5,
.character-picker-row-7 {
  background: #f8f8f8;
}

.character-picker-type-icon {
  width: 20px;
  height: 20px;
  margin: 0 12.5px;
}

.character-picker-five-items {
  display: flex;
  width: 100%;
  justify-content: space-between;
  align-items: center;
}

.character-picker-percentage {
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  flex: 1;
}

.character-picker-two-items {
  display: flex;
  width: 100%;
  justify-content: space-between;
  align-items: center;
}

.character-picker-title {
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  flex: 1;
}

.character-picker-grade {
  font-size: 14px;
  font-weight: bold;
  text-align: center;
  flex: 1;
}

.character-picker-four-items {
  display: flex;
  width: 100%;
  justify-content: space-between;
  align-items: center;
}

/* --------- DECK NAME --------- */
.deck-name-section {
  width: 100%;
  margin-bottom: 12px;
}

.deck-name-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 6px;
  font-size: 12px;
  margin-bottom: 8px;
  box-sizing: border-box;
}

.deck-name-display {
  text-align: center;
  font-size: 12px;
  font-weight: bold;
  color: #333;
  margin-top: 8px;
  padding: 4px;
  background: #f5f5f5;
  border-radius: 4px;
}

.new-deck-buttons {
  margin-bottom: 8px;
}

/* --------- COLLAPSED MODE ADJUSTMENTS --------- */
.right-sidebar.collapsed .slot {
  position: relative;
  overflow: visible !important;
  min-height: 70px;
  padding: 4px;
  gap: 3px;
}

.right-sidebar.collapsed .slot:not(.has-card) {
  height: 70px;
}

.right-sidebar.collapsed .slot.has-card .name,
.right-sidebar.collapsed .slot.has-card .skills,
.right-sidebar.collapsed .slot.has-card .skills-group,
.right-sidebar.collapsed .slot.has-card .skills-header,
.right-sidebar.collapsed .slot.has-card .skill {
  display: none !important;
}

.right-sidebar.collapsed .slot.has-card img {
  max-width: 56px;
}

.right-sidebar.collapsed .slot-container {
  width: 100%;
  margin-bottom: 8px;
}

.right-sidebar.collapsed .deck-buttons {
  grid-template-columns: 1fr;
  margin-bottom: 0px;
  gap: 4px;
}

.right-sidebar.collapsed .deck-btn,
.right-sidebar.collapsed .slots-header .clear-all {
  width: 100%;
  padding: 6px 8px;
  font-size: 10px;
  min-height: 32px;
}

.right-sidebar.collapsed .effect-row {
  min-height: 24px;
  padding: 2px 4px;
  margin-bottom: 2px;
  flex-wrap: nowrap;
  overflow: hidden;
  max-width: 100%;
  box-sizing: border-box;
}

.right-sidebar.collapsed .effect-info {
  min-width: 0;
  flex: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  overflow: hidden;
}

.right-sidebar.collapsed .effect-name {
  font-size: 9px;
  min-width: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  margin-right: 4px;
}

.right-sidebar.collapsed .effect-value {
  font-size: 9px;
  min-width: 20px;
  padding: 0 2px;
  margin-left: 0;
}

.right-sidebar.collapsed .effect-cards {
  display: none !important;
}

.right-sidebar.collapsed .deck-buttons:nth-child(2) {
  display: none;
}

.right-sidebar.collapsed .effects-header .cards-label {
  display: none !important;
}

.right-sidebar.collapsed .effects-header {
  padding-bottom: 12px !important;
}

.right-sidebar.collapsed .small-info-text {
  display: none !important;
}

.right-sidebar.collapsed .slot .name + div {
  display: none !important;
}

.right-sidebar.collapsed .slot .name {
  margin-bottom: 0 !important;
  padding-bottom: 0 !important;
}

.right-sidebar.collapsed .slot.has-card .type-icon {
  width: 20px !important;
  height: 20px !important;
  top: 4px !important;
  right: 4px !important;
  z-index: 5;
}

/* --------- UTILITY CLASSES --------- */
.small-info-text {
  font-size: 7.9px;
  opacity: 0.6;
  margin-bottom: 0px;
}

.diamond-icon {
  width: 14px;
  height: 18px;
  object-fit: contain;
}

.slots-header .clear-all {
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2);
}

.right-sidebar .slots-header {
  margin-bottom: 4px;
}

.right-sidebar-content {
  display: flex;
  flex-direction: column;
  width: 100%;
}

/* --------- DARK MODE --------- */
body.dark-mode {
  background: #1a1a1a;
  color: #e0e0e0;
}

body.dark-mode .header {
  background: #2d2d2d;
  border-bottom-color: #444;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

body.dark-mode .header-title {
  color: #e0e0e0;
}

body.dark-mode .sidebar {
  background: #2d2d2d;
}

body.dark-mode .right-sidebar {
  background: #252525;
  border-left-color: #444;
}

body.dark-mode select,
body.dark-mode .skill-search,
body.dark-mode .slot-level-input {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

body.dark-mode select:focus,
body.dark-mode .skill-search:focus,
body.dark-mode .slot-level-input:focus {
  border-color: #666;
  outline: none;
}

body.dark-mode .card,
body.dark-mode .slot {
  background: #2d2d2d;
  border-color: #444;
  color: #e0e0e0;
}

body.dark-mode .slot:not(.has-card) {
  background: #252525;
  border-color: #555;
}

body.dark-mode .skill {
  background: #3a3a3a;
  color: #e0e0e0;
}

body.dark-mode .skills-header {
  background: #444;
  color: #e0e0e0;
}

body.dark-mode .clear-all,
body.dark-mode #clearFiltersBtn,
body.dark-mode #togglePresetCardsBtn,
body.dark-mode .add-search-btn,
body.dark-mode .page-controls button {
  background: #555;
  color: #e0e0e0;
}

body.dark-mode .clear-all:hover,
body.dark-mode #clearFiltersBtn:hover,
body.dark-mode #togglePresetCardsBtn:hover,
body.dark-mode .add-search-btn:hover,
body.dark-mode .page-controls button:hover:not(:disabled) {
  background: #666;
}

body.dark-mode .page-controls button:disabled {
  background: #444;
  color: #888;
}

body.dark-mode .remove-search-btn {
  background: #3a3a3a;
  border-color: #555;
  color: #888;
}

body.dark-mode .remove-search-btn:hover {
  background: #444;
  color: #e0e0e0;
}

body.dark-mode .toggle-button {
  background: #3a3a3a;
}

body.dark-mode .toggle-button:hover {
  background: #444;
}

body.dark-mode .sort-order-btn {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

body.dark-mode .sort-order-btn:hover {
  background: #444;
  border-color: #666;
}

body.dark-mode .sort-order-btn.ascending {
  background: #555;
  border-color: #666;
}

body.dark-mode .slot-level-controls {
  background: #3a3a3a;
  border-color: #555;
}

body.dark-mode .slot-level-label {
  color: #e0e0e0;
}

body.dark-mode .skill-item {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

body.dark-mode .skills-list::-webkit-scrollbar-track {
  background: #2d2d2d;
}

body.dark-mode .skills-list::-webkit-scrollbar-thumb {
  background: #555;
}

body.dark-mode .skills-list::-webkit-scrollbar-thumb:hover {
  background: #666;
}

body.dark-mode .skill-search-divider {
  background: #555;
}

body.dark-mode .dark-mode-toggle {
  border-color: #888;
  background: #444;
}

body.dark-mode .dark-mode-toggle:hover {
  background: #555;
}

body.dark-mode .copy-paste-btn {
  background: #555;
  color: #e0e0e0;
}

body.dark-mode .copy-paste-btn:hover {
  background: #666;
}

body.dark-mode .deck-btn,
body.dark-mode .slots-header .clear-all {
  background: #555;
  color: #e0e0e0;
}

body.dark-mode .deck-btn:hover,
body.dark-mode .slots-header .clear-all:hover {
  background: #666;
}

body.dark-mode .clear-all,
body.dark-mode #clearAllBtn {
  background: #8B0000 !important;
}

body.dark-mode .clear-all:hover,
body.dark-mode #clearAllBtn:hover {
  background: #A52A2A !important;
}

body.dark-mode #clearFiltersBtn {
  background: #8B0000 !important;
}

body.dark-mode #clearFiltersBtn:hover {
  background: #A52A2A !important;
}

body.dark-mode #togglePresetCardsBtn {
  background: #555 !important;
}

body.dark-mode #togglePresetCardsBtn:hover {
  background: #666 !important;
}

body.dark-mode .clear-search-btn {
  background: #8B0000 !important;
}

body.dark-mode .clear-search-btn:hover {
  background: #A52A2A !important;
}

body.dark-mode .effect-row:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

body.dark-mode .effect-name {
  color: #e0e0e0;
}

body.dark-mode .effect-card-img {
  border-color: #555;
  background: #3a3a3a;
}

body.dark-mode .effect-card-value {
  background: rgba(60, 60, 60, 0.95);
  color: #8bc34a;
  border-color: #555;
}

body.dark-mode .effect-value {
  background: #2a3a2a;
  color: #8bc34a;
  border-color: #3a4a3a;
}

body.dark-mode .collapse-toggle {
  background: #555;
  border-color: #666;
}

body.dark-mode .collapse-toggle:hover {
  background: #666;
}

body.dark-mode .effects-header {
  color: #e0e0e0;
  border-bottom-color: #555;
}

body.dark-mode .character-picker-empty-box {
  background: #252525;
  border-color: #555;
}

body.dark-mode .character-picker-name {
  background: #3a3a3a;
}

body.dark-mode .character-picker-costume {
  background: #2a3a3a;
}

body.dark-mode .character-picker-row {
  background: #2d2d2d;
}

body.dark-mode .character-picker-row-2,
body.dark-mode .character-picker-row-4,
body.dark-mode .character-picker-row-6,
body.dark-mode .character-picker-row-8 {
  background: #252525;
}

body.dark-mode .character-picker-row-1,
body.dark-mode .character-picker-row-3,
body.dark-mode .character-picker-row-5,
body.dark-mode .character-picker-row-7 {
  background: #2d2d2d;
}

body.dark-mode .character-skills-header {
  background: #444;
  color: #e0e0e0;
}

body.dark-mode .character-skill {
  background: #3a3a3a;
  color: #e0e0e0;
}

body.dark-mode .deck-name-input {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

body.dark-mode .deck-name-display {
  background: #3a3a3a;
  color: #e0e0e0;
}

body.dark-mode .skill.search-highlighted[data-has-border="true"],
body.dark-mode .skill.highlighted[data-has-border="true"],
body.dark-mode .skill-item.search-highlighted[data-has-border="true"],
body.dark-mode .skill-item.highlighted[data-has-border="true"] {
  border-color: #fff96b;
  box-shadow: 0 0 0 1px #fff96b;
}

/* --------- CHARACTER PICKER MODAL --------- */
.character-picker-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.character-picker-modal.active {
  display: flex;
}

.character-picker-container {
  width: 90%;
  height: 90%;
  background: #fff;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

body.dark-mode .character-picker-container {
  background: #2d2d2d;
  color: #e0e0e0;
}

.character-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #ddd;
  background: #f9f9f9;
}

body.dark-mode .character-picker-header {
  background: #3a3a3a;
  border-bottom-color: #555;
}

.character-picker-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #333;
  transition: color 0.2s;
}

body.dark-mode .character-picker-close {
  color: #e0e0e0;
}

.character-picker-close:hover {
  color: #ff4444;
}

.character-picker-controls {
  display: flex;
  padding: 16px 20px;
  gap: 16px;
  border-bottom: 1px solid #ddd;
  background: #f9f9f9;
  flex-wrap: wrap;
}

body.dark-mode .character-picker-controls {
  background: #3a3a3a;
  border-bottom-color: #555;
}

.character-search-container {
  flex: 1;
  min-width: 200px;
}

.character-search {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  box-sizing: border-box;
}

body.dark-mode .character-search {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

.sort-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.sort-select {
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  background: #fff;
}

body.dark-mode .sort-select {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

.sort-order-btn {
  width: 36px;
  height: 36px;
  border: 1px solid #ccc;
  background: #f5f5f5;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
}

body.dark-mode .sort-order-btn {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

.sort-order-btn:hover {
  background: #e5e5e5;
  border-color: #999;
}

body.dark-mode .sort-order-btn:hover {
  background: #444;
  border-color: #666;
}

.sort-order-btn.ascending {
  background: #444;
  color: #fff;
  border-color: #444;
}

body.dark-mode .sort-order-btn.ascending {
  background: #555;
  border-color: #666;
}

.character-picker-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

.character-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 16px;
}

.character-card {
  border: 1px solid #ddd;
  border-radius: 6px;
  padding: 12px;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: all 0.2s ease;
  height: 220px;
  box-sizing: border-box;
}

body.dark-mode .character-card {
  background: #3a3a3a;
  border-color: #555;
}

.character-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  border-color: #aaa;
}

body.dark-mode .character-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  border-color: #777;
}

.character-portrait {
  width: 100px;
  height: 100px;
  object-fit: cover;
  border-radius: 4px;
  margin-bottom: 8px;
  background: #f0f0f0;
}

body.dark-mode .character-portrait {
  background: #555;
}

.character-name {
  font-weight: bold;
  font-size: 14px;
  text-align: center;
  margin-bottom: 4px;
  width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.character-rarity {
  font-size: 12px;
  color: #666;
  margin-bottom: 4px;
}

body.dark-mode .character-rarity {
  color: #aaa;
}

.character-title {
  font-size: 12px;
  color: #888;
  text-align: center;
  width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

body.dark-mode .character-title {
  color: #999;
}

/* Character Picker Empty Box */
.character-picker-empty-box {
  width: auto;
  height: 120px;
  border: 2px dashed #ccc;
  background: #fafafa;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

body.dark-mode .character-picker-empty-box {
  background: #252525;
  border-color: #555;
}

.character-picker-empty-box:hover {
  border-color: #999;
  background: #f0f0f0;
}

body.dark-mode .character-picker-empty-box:hover {
  border-color: #777;
  background: #2d2d2d;
}

.character-picker-empty-text {
  color: #999;
  font-size: 14px;
}

body.dark-mode .character-picker-empty-text {
  color: #777;
}

/* Selected character styling */
.character-picker-empty-box.has-character {
  border-style: solid;
  border-color: #ddd;
  background: #fff;
  position: relative;
  overflow: hidden;
}

body.dark-mode .character-picker-empty-box.has-character {
  border-color: #555;
  background: #3a3a3a;
}

.character-picker-empty-box.has-character .character-picker-empty-text {
  display: none;
}

.selected-character-portrait {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 2px;
}

.selected-character-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 4px;
  font-size: 11px;
  text-align: center;
}

.selected-character-name {
  font-weight: bold;
  margin-bottom: 2px;
}

.selected-character-title {
  font-size: 10px;
  opacity: 0.9;
}

.character-skills-header {
  font-size: 9px;
  font-weight: bold;
  text-align: center;
  background: #000;
  color: #fff;
  padding: 3px 0px;
  border-radius: 0;
  width: 100%;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Hide empty skill boxes */
.character-skill:empty {
  display: none;
}

/* Hide entire column if no skills */
.character-skills-column:has(.character-skill:only-child:empty) {
  display: none;
}

/* Ensure the right sidebar doesn't expand */
.right-sidebar .character-skills-section {
  max-width: 100%;
  overflow: hidden;
}

.character-skills-section {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
  width: 100%;
  margin-bottom: 12px;
}

/* Prevent skill text from causing layout issues */
.character-skill-text {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  width: 100%;
  line-height: 1.2;
}

/* Remove symbols from skill names in character picker */
.character-skill::before,
.character-skill::after {
  content: none !important;
}

/* Remove the character-skill-text class and integrate its properties */
.character-skill {
  display: -webkit-box;
  -webkit-line-clamp: 2; /* Limit to 2 lines max */
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  /* Keep the existing properties */
  width: 100%;
  background: #eef2ff;
  border-radius: 4px;
  padding: 2px 4px;
  font-size: 10px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
  min-height: 20px;
  line-height: 1.2;
  box-sizing: border-box;
}

/* Ensure the flex container allows proper text wrapping */
.character-skills-column {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
  /* Add this to ensure proper text wrapping in child elements */
  align-items: stretch;
}

</style>

</head>

<body>
  <!-- Header -->
  <div class="header">
    <div class="header-left">
      <img src="images/your-logo.png" alt="Logo" class="header-logo">
      <div class="header-title">Uma Builder</div>
    </div>
    <div class="header-nav">
      <button id="darkModeToggle" class="dark-mode-toggle" title="Toggle Dark Mode">ðŸŒ™</button>
    </div>
  </div>

  <div class="container">
    <!-- Left Sidebar (Filters) -->
    <div class="sidebar">
      <!-- Basic Filters -->
      <div class="filter-group">
        <label for="cardSearch">Search Card</label>
        <input type="text" id="cardSearch" class="skill-search" placeholder="Search card name">
      </div>

      <!-- Rarity Toggle Buttons -->
      <div class="toggle-button-group rarity-buttons">
        <label>Rarity</label>
        <div class="toggle-buttons-row">
          <button class="toggle-button" data-rarity="SSR"><img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_03.png" alt="SSR"></button>
          <button class="toggle-button" data-rarity="SR"><img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_02.png" alt="SR"></button>
          <button class="toggle-button" data-rarity="R"><img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_01.png" alt="R"></button>
        </div>
      </div>

      <!-- Type Toggle Buttons -->
      <div class="toggle-button-group type-buttons">
        <label>Type</label>
        <div class="toggle-buttons-row">
          <button class="toggle-button" data-type="speed"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_00.png" alt="Speed"></button>
          <button class="toggle-button" data-type="stamina"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_01.png" alt="Stamina"></button>
          <button class="toggle-button" data-type="power"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_02.png" alt="Power"></button>
          <button class="toggle-button" data-type="guts"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_03.png" alt="Guts"></button>
          <button class="toggle-button" data-type="intelligence"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_04.png" alt="Intelligence"></button>
          <button class="toggle-button" data-type="friend"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_05.png" alt="Friend"></button>
          <button class="toggle-button" data-type="group"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_06.png" alt="Group"></button>
        </div>
      </div>

      <!-- Sorting & Region -->
      <div class="filter-group">
        <label for="sortBy">Sort By</label>
        <div style="display: flex; gap: 6px; align-items: center;">
          <select id="sortBy" style="flex: 1;">
            <option value="rarity">Rarity</option>
            <option value="name">Character name</option>
            <option value="type">Card type</option>
            <option value="release">Release date</option>
            <option value="support_id">Game ID Number</option>
            <option disabled="">â€” Effects â€”</option>
            <option value="1">Friendship Bonus</option>
            <option value="2">Mood Effect</option>
            <option value="3">Speed Bonus</option>
            <option value="4">Stamina Bonus</option>
            <option value="5">Power Bonus</option>
            <option value="6">Guts Bonus</option>
            <option value="7">Wit Bonus</option>
            <option value="8">Training Effectiveness</option>
            <option value="9">Initial Speed</option>
            <option value="10">Initial Stamina</option>
            <option value="11">Initial Power</option>
            <option value="12">Initial Guts</option>
            <option value="13">Initial Wit</option>
            <option value="14">Initial Friendship Gauge</option>
            <option value="15">Race Bonus</option>
            <option value="16">Fan Bonus</option>
            <option value="17">Hint Levels</option>
            <option value="18">Hint Frequency</option>
            <option value="19">Specialty Priority</option>
            <option value="25">Event Recovery</option>
            <option value="26">Event Effectiveness</option>
            <option value="27">Failure Protection</option>
            <option value="28">Energy Cost Reduction</option>
            <option value="30">Skill Point Bonus</option>
            <option value="31">Wit Friendship Recovery</option>
            <option value="32">Initial Skill Points Up</option>
            <option value="41">All Stats Bonus</option>
          </select>
          <button id="sortOrder" class="sort-order-btn ascending" style="width: 32px; height: 32px; border: 1px solid #ccc; background: #444; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; border-radius: 4px; flex-shrink: 0;">â†‘</button>
        </div>
      </div>

      <div class="filter-group">
        <label for="region">Region</label>
        <select id="region">
          <option value="global">Global</option>
          <option value="japan">Japan</option>
        </select>
      </div>

      <div class="filter-group">
        <label class="checkbox-label">
          <input type="checkbox" id="hideUncolored">
          Hide Uncoloured Skills
        </label>
      </div>

      <div class="skill-search-divider"></div>

      <!-- Preset Controls -->
      <button id="togglePresetCardsBtn" class="clear-all">Hide Preset Cards</button>

      <!-- Advanced Filters Section -->
      <div class="sidebar-filters-section" id="sidebarFiltersSection">
        <button id="clearFiltersBtn" class="clear-all clear-filters-top">Clear Filters</button>

        <div class="filter-group">
          <label for="presets">Presets</label>
          <select id="presets">
            <option value="">-- Select --</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="racecourse">Racecourse</label>
          <select id="racecourse">
            <option value="">-- Select --</option>
            <option value="Sapporo">Sapporo</option>
            <option value="Hakodate">Hakodate</option>
            <option value="Niigata">Niigata</option>
            <option value="Fukushima">Fukushima</option>
            <option value="Nakayama">Nakayama</option>
            <option value="Tokyo">Tokyo</option>
            <option value="Chukyo">Chukyo</option>
            <option value="Kyoto">Kyoto</option>
            <option value="Hanshin">Hanshin</option>
            <option value="Kokura">Kokura</option>
            <option value="Oi">Oi</option>
            <option value="Kawasaki">Kawasaki</option>
            <option value="Funabashi">Funabashi</option>
            <option value="Morioka">Morioka</option>
            <option value="Longchamp">Longchamp</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="length">Length</label>
          <select id="length">
            <option value="">-- Select --</option>
            <option value="1000">1000m</option>
            <option value="1150">1150m</option>
            <option value="1200">1200m</option>
            <option value="1300">1300m</option>
            <option value="1400">1400m</option>
            <option value="1500">1500m</option>
            <option value="1600">1600m</option>
            <option value="1700">1700m</option>
            <option value="1800">1800m</option>
            <option value="1900">1900m</option>
            <option value="2000">2000m</option>
            <option value="2100">2100m</option>
            <option value="2200">2200m</option>
            <option value="2300">2300m</option>
            <option value="2400">2400m</option>
            <option value="2500">2500m</option>
            <option value="2600">2600m</option>
            <option value="3000">3000m</option>
            <option value="3200">3200m</option>
            <option value="3400">3400m</option>
            <option value="3600">3600m</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="direction">Direction</label>
          <select id="direction">
            <option value="">-- Select --</option>
            <option value="Clockwise">Clockwise</option>
            <option value="Counterclockwise">Counterclockwise</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="track">Track Conditions</label>
          <select id="track">
            <option value="">-- Select --</option>
            <option value="Firm">Firm</option>
            <option value="Good">Good</option>
            <option value="Soft">Soft</option>
            <option value="Heavy">Heavy</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="season">Season</label>
          <select id="season">
            <option value="">-- Select --</option>
            <option value="Spring">Spring</option>
            <option value="Summer">Summer</option>
            <option value="Fall">Autumn</option>
            <option value="Winter">Winter</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="weather">Weather</label>
          <select id="weather">
            <option value="">-- Select --</option>
            <option value="Sunny">Sunny</option>
            <option value="Cloudy">Cloudy</option>
            <option value="Rainy">Rain</option>
            <option value="Snowy">Snow</option>
          </select>
        </div>

        <div class="filter-group">
          <label for="strategy">Strategy</label>
          <select id="strategy">
            <option value="">-- Select --</option>
            <option value="Front Runner">Front Runner</option>
            <option value="Pace Chaser">Pace Chaser</option>
            <option value="Late Surger">Late Surger</option>
            <option value="End Closer">End Closer</option>
          </select>
        </div>
      </div>

      <div class="skill-search-divider"></div>

      <!-- Skill Management -->
      <div class="copy-paste-buttons">
        <button id="copySkillsBtn" class="copy-paste-btn">Copy Skills</button>
        <button id="pasteSkillsBtn" class="copy-paste-btn">Paste Skills</button>
      </div>

      <!-- Skill Search Section -->
      <div id="skillSearchGroup">
        <div class="skill-search-header">
          <label for="skillSearch1">Search</label>
          <div class="skill-search-buttons">
            <button class="add-search-btn" id="addSearchBtn">Add</button>
            <button class="clear-search-btn" id="clearAllSearchesBtn" title="Clear all searches">Clear</button>
          </div>
        </div>
        <div class="search-input-container">
          <div class="color-picker green" data-search-id="skillSearch1" data-color="green"></div>
          <input type="text" id="skillSearch1" class="skill-search" placeholder="Search skill">
          <button class="remove-search-btn" data-search-id="skillSearch1">Ã—</button>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <div class="content-wrapper">
        <div id="cardSections" class="card-sections"></div>
      </div>
    </div>

    <!-- Sidebar Toggle -->
    <button class="collapse-toggle" id="collapseSidebar" title="Collapse sidebar">â—€</button>

    <!-- Right Sidebar (Slots & Effects) -->
    <div class="right-sidebar" id="rightSidebar">
      <div class="right-sidebar-content">
        <!-- Deck Management -->
        <div class="deck-name-section">
          <input type="text" id="deckNameInput" class="deck-name-input" placeholder="Enter deck name" maxlength="30">
          <div class="deck-buttons new-deck-buttons">
            <button id="copyAllBtn" class="deck-btn">Copy All</button>
            <button id="pasteAllBtn" class="deck-btn">Paste All</button>
            <button id="resetLevelsBtn" class="clear-all">Reset All Levels</button>
          </div>
          <div id="deckNameDisplay" class="deck-name-display">Unnamed Deck</div>
        </div>

        <div class="skill-search-divider"></div>

        <!-- Character Picker Section in Right Sidebar -->
        <div class="character-picker-section">
          <div class="character-picker-left-column">
            <div class="character-picker-empty-box" id="characterPickerBox">
              <div class="character-picker-empty-text">Empty</div>
            </div>
            <div class="character-picker-info">
              <div class="character-picker-name">Character Name</div>
              <div class="character-picker-costume">Character Costume</div>
            </div>
          </div>
          <div class="character-picker-rows">
            <div class="character-picker-row character-picker-row-1">
              <div class="character-picker-five-items">
                <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_00.png" alt="Speed" class="character-picker-type-icon">
                <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_01.png" alt="Stamina" class="character-picker-type-icon">
                <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_02.png" alt="Power" class="character-picker-type-icon">
                <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_03.png" alt="Guts" class="character-picker-type-icon">
                <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_04.png" alt="Intelligence" class="character-picker-type-icon">
              </div>
            </div>
            <div class="character-picker-row character-picker-row-2">
              <div class="character-picker-five-items">
                <div class="character-picker-percentage">20%</div>
                <div class="character-picker-percentage">20%</div>
                <div class="character-picker-percentage">20%</div>
                <div class="character-picker-percentage">20%</div>
                <div class="character-picker-percentage">20%</div>
              </div>
            </div>
            <div class="character-picker-row character-picker-row-3">
              <div class="character-picker-two-items">
                <div class="character-picker-title">Turf</div>
                <div class="character-picker-title">Dirt</div>
              </div>
            </div>
            <div class="character-picker-row character-picker-row-4">
              <div class="character-picker-two-items">
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
              </div>
            </div>
            <div class="character-picker-row character-picker-row-5">
              <div class="character-picker-four-items">
                <div class="character-picker-title">Short</div>
                <div class="character-picker-title">Mile</div>
                <div class="character-picker-title">Medium</div>
                <div class="character-picker-title">Long</div>
              </div>
            </div>
            <div class="character-picker-row character-picker-row-6">
              <div class="character-picker-four-items">
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
              </div>
            </div>
            <div class="character-picker-row character-picker-row-7">
              <div class="character-picker-four-items">
                <div class="character-picker-title">Front</div>
                <div class="character-picker-title">Pace</div>
                <div class="character-picker-title">Late</div>
                <div class="character-picker-title">End</div>
              </div>
            </div>
            <div class="character-picker-row character-picker-row-8">
              <div class="character-picker-four-items">
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
                <div class="character-picker-grade">A</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Character Skills -->
        <div class="character-skills-section">
          <div class="character-skills-column">
            <div class="character-skills-header">Innate Skills</div>
            <div class="character-skill">Innate Skill 1</div>
            <div class="character-skill">Innate Skill 2</div>
            <div class="character-skill">Innate Skill 3</div>
          </div>
          <div class="character-skills-column">
            <div class="character-skills-header">Awakening Skills</div>
            <div class="character-skill">Awakening Skill 1</div>
            <div class="character-skill">Awakening Skill 2</div>
            <div class="character-skill">Awakening Skill 3</div>
          </div>
          <div class="character-skills-column">
            <div class="character-skills-header">Event Skills</div>
            <div class="character-skill">Event Skill 1</div>
            <div class="character-skill">Event Skill 2</div>
            <div class="character-skill">Event Skill 3</div>
          </div>
        </div>

        <div class="skill-search-divider"></div>

        <!-- Deck Controls -->
        <div class="slots-header">
          <div class="deck-buttons">
            <button id="copyDeckBtn" class="deck-btn">Copy Deck Only</button>
            <button id="pasteDeckBtn" class="deck-btn">Paste Deck Only</button>
            <button id="clearAllBtn" class="clear-all">Clear Deck</button>
          </div>
        </div>

        <!-- Card Slots -->
        <div class="slots" id="slots">
          <div class="slot-container" data-slot="0">
            <div class="slot-level-controls">
              <span class="slot-level-label">Level</span>
              <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
            </div>
            <div class="slot" data-slot="0"><div class="placeholder">Empty</div></div>
          </div>
          <div class="slot-container" data-slot="1">
            <div class="slot-level-controls">
              <span class="slot-level-label">Level</span>
              <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
            </div>
            <div class="slot" data-slot="1"><div class="placeholder">Empty</div></div>
          </div>
          <div class="slot-container" data-slot="2">
            <div class="slot-level-controls">
              <span class="slot-level-label">Level</span>
              <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
            </div>
            <div class="slot" data-slot="2"><div class="placeholder">Empty</div></div>
          </div>
          <div class="slot-container" data-slot="3">
            <div class="slot-level-controls">
              <span class="slot-level-label">Level</span>
              <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
            </div>
            <div class="slot" data-slot="3"><div class="placeholder">Empty</div></div>
          </div>
          <div class="slot-container" data-slot="4">
            <div class="slot-level-controls">
              <span class="slot-level-label">Level</span>
              <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
            </div>
            <div class="slot" data-slot="4"><div class="placeholder">Empty</div></div>
          </div>
          <div class="slot-container" data-slot="5">
            <div class="slot-level-controls">
              <span class="slot-level-label">Level</span>
              <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
            </div>
            <div class="slot" data-slot="5"><div class="placeholder">Empty</div></div>
          </div>
        </div>

        <div class="skill-search-divider"></div>

        <!-- Effects Display -->
        <div class="effects-header">
          <span class="effect-label">Effect</span>
          <span class="total-label">Total</span>
          <span class="cards-label">Cards</span>
        </div>

        <!-- Effects List -->
        <div class="effect-rows-container">
          <div class="effect-row" data-effect="Friendship Bonus"><div class="effect-info"><span class="effect-name">Friendship Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Mood Effect"><div class="effect-info"><span class="effect-name">Mood Effect</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Speed Bonus"><div class="effect-info"><span class="effect-name">Speed Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Stamina Bonus"><div class="effect-info"><span class="effect-name">Stamina Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Power Bonus"><div class="effect-info"><span class="effect-name">Power Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Guts Bonus"><div class="effect-info"><span class="effect-name">Guts Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Wit Bonus"><div class="effect-info"><span class="effect-name">Wit Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Training Effectiveness"><div class="effect-info"><span class="effect-name">Training Effectiveness</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Speed"><div class="effect-info"><span class="effect-name">Initial Speed</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Stamina"><div class="effect-info"><span class="effect-name">Initial Stamina</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Power"><div class="effect-info"><span class="effect-name">Initial Power</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Guts"><div class="effect-info"><span class="effect-name">Initial Guts</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Wit"><div class="effect-info"><span class="effect-name">Initial Wit</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Friendship Gauge"><div class="effect-info"><span class="effect-name">Initial Friendship Gauge</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Race Bonus"><div class="effect-info"><span class="effect-name">Race Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Fan Bonus"><div class="effect-info"><span class="effect-name">Fan Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Hint Levels"><div class="effect-info"><span class="effect-name">Hint Levels</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Hint Frequency"><div class="effect-info"><span class="effect-name">Hint Frequency</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Specialty Priority"><div class="effect-info"><span class="effect-name">Specialty Priority</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Event Recovery"><div class="effect-info"><span class="effect-name">Event Recovery</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Event Effectiveness"><div class="effect-info"><span class="effect-name">Event Effectiveness</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Failure Protection"><div class="effect-info"><span class="effect-name">Failure Protection</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Energy Cost Reduction"><div class="effect-info"><span class="effect-name">Energy Cost Reduction</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Skill Point Bonus"><div class="effect-info"><span class="effect-name">Skill Point Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Wit Friendship Recovery"><div class="effect-info"><span class="effect-name">Wit Friendship Recovery</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="Initial Skill Points Up"><div class="effect-info"><span class="effect-name">Initial Skill Points Up</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
          <div class="effect-row" data-effect="All Stats Bonus"><div class="effect-info"><span class="effect-name">All Stats Bonus</span><span class="effect-value">0</span></div><div class="effect-cards"></div></div>
        </div>
      </div>
    </div>
  </div>

      <!-- Character Picker Modal -->
    <div class="character-picker-modal" id="characterPickerModal">
      <div class="character-picker-container">
        <div class="character-picker-header">
          <div class="character-picker-title">Select Character</div>
          <button class="character-picker-close" id="characterPickerClose">Ã—</button>
        </div>
        <div class="character-picker-controls">
          <div class="character-search-container">
            <input type="text" id="characterSearch" class="character-search" placeholder="Search by name or title">
          </div>
          <div class="sort-controls">
            <select id="characterSort" class="sort-select">
              <option value="name">Name</option>
              <option value="rarity">Rarity</option>
              <option value="implemented">Release date</option>
              <option value="id">Game ID number</option>
              <option disabled=""></option>
              <option disabled="">â€” Aptitude â€”</option>
              <option value="turf">Turf aptitude</option>
              <option value="dirt">Dirt aptitude</option>
              <option value="sprint">Short aptitude</option>
              <option value="mile">Mile aptitude</option>
              <option value="middle">Medium aptitude</option>
              <option value="long">Long aptitude</option>
              <option value="runner">Front aptitude</option>
              <option value="leader">Pace aptitude</option>
              <option value="betweener">Late aptitude</option>
              <option value="chaser">End aptitude</option>
              <option disabled=""></option>
              <option disabled="">â€” Stat bonuses â€”</option>
              <option value="bonus_speed">Speed bonus</option>
              <option value="bonus_stamina">Stamina bonus</option>
              <option value="bonus_power">Power bonus</option>
              <option value="bonus_guts">Guts bonus</option>
              <option value="bonus_int">Wit bonus</option>
              <option disabled=""></option>
              <option disabled="">â€” Stats â€”</option>
              <option value="base_speed">Base speed</option>
              <option value="base_stamina">Base stamina</option>
              <option value="base_power">Base power</option>
              <option value="base_guts">Base guts</option>
              <option value="base_int">Base wit</option>
              <option value="5_speed">5â­ Speed</option>
              <option value="5_stamina">5â­ Stamina</option>
              <option value="5_power">5â­ Power</option>
              <option value="5_guts">5â­ Guts</option>
              <option value="5_int">5â­ Wit</option>
            </select>
            <button class="sort-order-btn ascending" id="characterSortOrder">â†‘</button>
          </div>
        </div>
        <div class="character-picker-content">
          <div class="character-grid" id="characterGrid">
            <!-- Character cards will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>
</body>

<script>
/* --------------------------------------- CONFIG --------------------------------------- */
const SUPPORT_CARDS_PATTERN = "support-cards";
const SKILLS_PATTERN = "skills";
const PRESETS_JSON_FILE = "data/champions_meeting.json";
const HIDE = { char_id: false, url_name: true };

/* ------------- STATE ------------- */
let cardsData = [];
let skillsData = [];
let presetRaceNumbers = new Map();
let supportsDataWithEffects = [];
let characters = [];

const cardSections = document.getElementById('cardSections');
const slotContainers = Array.from(document.querySelectorAll('.slot-container'));
const slots = Array.from(document.querySelectorAll('.right-sidebar .slot'));
const clearAllBtn = document.getElementById('clearAllBtn');
const clearFiltersBtn = document.getElementById('clearFiltersBtn');
const selectedCardIds = new Set();
const sectionPages = new Map();
const slotListeners = new Map();
const characterPickerBox = document.getElementById('characterPickerBox');
const characterPickerModal = document.getElementById('characterPickerModal');
const characterPickerClose = document.getElementById('characterPickerClose');
const characterSearch = document.getElementById('characterSearch');
const characterSort = document.getElementById('characterSort');
const characterSortOrder = document.getElementById('characterSortOrder');
const characterGrid = document.getElementById('characterGrid');
const characterPickerName = document.querySelector('.character-picker-name');
const characterPickerCostume = document.querySelector('.character-picker-costume');
const SLOT_KEY = 'saved_slots';
const FILTER_KEYS = ['racecourse','length','direction','track','season','weather','strategy'];
let SKILL_SEARCH_KEYS = [];
let showPresetCards = true;
let selectedSlot = null;
const SLOT_SELECTION_KEY = 'selected_slot';

let cardSearchValue = '';
let skillSearches = JSON.parse(localStorage.getItem('skillSearches')) || [{ id: 'skillSearch1', value: '' }];
let searchCounter = skillSearches.length + 1;

const selectedRarities = new Set();
const selectedTypes = new Set();

let hideUncolored = false;
let sortBy = 'rarity';
let sortOrder = 'descending';
let region = 'global';
let selectedCharacter = null;
let isAscending = true;

const slotLevels = JSON.parse(localStorage.getItem('slotLevels')) || {};
const MAX_LEVELS = { 'R': 40, 'SR': 45, 'SSR': 50 };


function saveCardLevel(supportId, level) {
    if (supportId) {
        slotLevels[supportId] = parseInt(level) || 1;
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
    }
}

function getCardLevel(supportId) {
    return slotLevels[supportId] || 1;
}

function removeCardLevel(supportId) {
    if (slotLevels[supportId]) {
        delete slotLevels[supportId];
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
    }
}

/* ------------- DATA LOADING ------------- */
async function discoverDataFiles() {
    const commonPatterns = [
        { support: 'data/support-cards.36dc3929.json', skills: 'data/skills.c34f831c.json' },
        { support: 'data/support-cards.json', skills: 'data/skills.json' },
        { support: 'support-cards.json', skills: 'skills.json' },
        { support: 'data/support_cards.json', skills: 'data/skills.json' }
    ];

    for (const pattern of commonPatterns) {
        try {
            const [supportTest, skillsTest] = await Promise.allSettled([
                fetch(pattern.support).then(r => r.ok ? r.json() : Promise.reject('Not found')),
                fetch(pattern.skills).then(r => r.ok ? r.json() : Promise.reject('Not found'))
            ]);

            if (supportTest.status === 'fulfilled' && skillsTest.status === 'fulfilled') {
                return {
                    supportCardsFile: pattern.support,
                    skillsFile: pattern.skills,
                    supportData: supportTest.value,
                    skillsData: skillsTest.value
                };
            }
        } catch (error) {
            continue;
        }
    }

    throw new Error('Could not find required data files.');
}

// Update the loadCharacterData function to ensure skillsData is available
async function loadCharacterData() {
    try {
        const response = await fetch('data/characters.json');
        const data = await response.json();
        
        // Transform the data to match our expected format
        characters = Object.values(data).map(char => ({
            id: char.card_id,
            char_id: char.char_id,
            card_id: char.card_id,
            name: char.name_en || 'Unknown',
            title: char.title || char.title_en_gl || 'No Title',
            rarity: getRarityText(char.rarity),
            portrait: getCharacterPortrait(char.char_id, char.card_id),
            implemented: char.release || char.release_en || 'Unknown',
            stat_bonus: char.stat_bonus || [0, 0, 0, 0, 0],
            aptitude: char.aptitude || [],
            // Store the original data for region filtering and skills
            originalData: char
        }));
        
        // Apply initial region filter
        applyRegionFilter();
        
        console.log('Character data loaded successfully:', characters.length, 'characters');
    } catch (error) {
        console.error('Error loading character data:', error);
        // Show error message
        if (characterGrid) {
            characterGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;">Error loading character data</div>';
        }
    }
}

function getSkillName(skillId) {
    if (!skillsData || skillsData.length === 0) {
        return `Skill ${skillId}`;
    }
    
    const skill = skillsData.find(s => s.id === skillId);
    if (skill) {
        if (region === 'global') {
            return skill.name_en || skill.jpname || `Skill ${skillId}`;
        } else {
            return skill.jpname || skill.name_en || `Skill ${skillId}`;
        }
    }
    
    return `Skill ${skillId}`;
}

function getSkillDescription(skillId) {
    if (!skillsData || skillsData.length === 0) return '';
    
    const skill = skillsData.find(s => s.id === skillId);
    if (skill) {
        if (region === 'global') {
            return skill.desc_en || skill.jpdesc || '';
        } else {
            return skill.jpdesc || skill.desc_en || '';
        }
    }
    
    return '';
}

// Helper function to convert rarity number to text
function getRarityText(rarity) {
    switch(rarity) {
        case 3: return "SSR";
        case 2: return "SR";
        case 1: return "R";
        default: return "Unknown";
    }
}

// Update the getCharacterPortrait function to use the new format
function getCharacterPortrait(charId, cardId) {
    // Updated format: https://gametora.com/images/umamusume/characters/thumb/chara_stand_{char_id}_{card_id}.png
    return `https://gametora.com/images/umamusume/characters/thumb/chara_stand_${charId}_${cardId}.png`;
}

function processSupportCardData(supportCards, skills) {
    skillsData = skills;
    supportsDataWithEffects = supportCards;
    
    return supportCards.map(card => {
        const hint_skills = (card.hints?.hint_skills || []).map(skillId => getSkillName(skillId));
        const event_skills = (card.event_skills || []).map(skillId => getSkillName(skillId));
        const event_skills_en = (card.event_skills || []).map(skillId => getSkillName(skillId));
        
        return {
            ...card,
            char_id: card.char_id || 0,
            char_name: card.char_name || 'Unknown',
            hint_skills: hint_skills,
            event_skills: event_skills,
            event_skills_en: event_skills_en,
            rarity: card.rarity || 1,
            release: card.release || '',
            release_en: card.release_en || '',
            support_id: card.support_id || 0,
            type: (card.type || '').toLowerCase(),
            url_name: card.url_name || '',
            effects: card.effects || []
        };
    });
}

async function loadDataFiles() {
    try {
        const discoveredFiles = await discoverDataFiles();
        const supportCardsData = discoveredFiles.supportData;
        const skillsData = discoveredFiles.skillsData;

        if (!Array.isArray(supportCardsData)) {
            throw new Error('support-cards data is not an array');
        }
        if (!Array.isArray(skillsData)) {
            throw new Error('skills data is not an array');
        }
        
        cardsData = processSupportCardData(supportCardsData, skillsData);
        return true;
        
    } catch (error) {
        console.error('Error loading data files:', error);
        throw new Error(`Error: Could not load data files. Please ensure you have both files in your data folder. Current error: ${error.message}`);
    }
}

/* ------------- INITIALIZATION ------------- */
document.addEventListener('DOMContentLoaded', function() {
    loadDataFiles()
    .then(() => {
        try {
            setupFilterPersistence();
            setupToggleButtons();
            setupSortingControls();
            setupDynamicSkillSearch();
            setupPresets();
            setupPresetReset();
            setupTogglePresetCards();
            setupCardSearch();
            setupCopyPasteButtons();
            loadSlotsFromLocalStorage();
            setupClearAllSearches();
            updateSelectedSkillsList();
            setupDeckCopyPaste();
            setupSlotSelection();
            setupKeyboardShortcuts();

            setupDeckName();
            setupCopyAll();
            setupPasteAll();
            setupResetLevels();
            setupClearDeckWithNameReset();

            // Initialize character picker AFTER loading main data
            initCharacterPicker();

            setTimeout(() => {
                sectionPages.clear();
                renderSections();
                updateAllSlotDisplays();
                
                setTimeout(() => {
                    ensureSlotsLoaded();
                    updateAllSlotDisplays();
                    updateEffectTotals();
                }, 500);
            }, 500);
        } catch (error) {
            console.error('Error during setup:', error);
        }
    })
    .catch(err => {
        console.error('Could not load JSON:', err);
        cardSections.innerHTML = `
            <div style="opacity:0.7;padding:12px;text-align:center;">
            <h3>Error loading data</h3>
            <p>${err.message}</p>
            <p>Please check that your data files exist and are properly named.</p>
            </div>
        `;
    });
});

/* ------------- PAGINATION ------------- */
function calculateCardsPerPage() {
  const grid = document.querySelector('.cards');
  if (!grid) return 6;
  
  const gridWidth = grid.clientWidth;
  const cardWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w')) || 120;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8;
  
  const cardsPerRow = Math.floor((gridWidth + gap) / (cardWidth + gap));
  const rowsPerPage = 1;
  
  return cardsPerRow * rowsPerPage;
}

function renderFilterPage(page, matches, grid, leftBtn, rightBtn, pageKey) {
  grid.innerHTML = '';
  const CARDS_PER_PAGE = calculateCardsPerPage();
  const startIdx = page * CARDS_PER_PAGE;
  const endIdx = startIdx + CARDS_PER_PAGE;
  const pageCards = matches.slice(startIdx, endIdx);
  
  pageCards.forEach(card => grid.appendChild(createCardElement(card)));

  const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
  const needsPagination = totalPages > 1;
  leftBtn.style.display = needsPagination ? 'flex' : 'none';
  rightBtn.style.display = needsPagination ? 'flex' : 'none';
  leftBtn.disabled = page === 0;
  rightBtn.disabled = page >= totalPages - 1;

  leftBtn.onclick = () => { 
    if (page > 0) {
      renderFilterPage(page-1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey, page-1);
      highlightSkills();
    }
  };
  
  rightBtn.onclick = () => { 
    if (page < totalPages - 1) {
      renderFilterPage(page+1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey, page+1);
      highlightSkills();
    }
  };
  
  highlightSkills();
}

function renderCardSearchPage(page, matches, grid, leftBtn, rightBtn, pageKey) {
  grid.innerHTML = '';
  const CARDS_PER_PAGE = calculateCardsPerPage();
  const startIdx = page * CARDS_PER_PAGE;
  const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
  pageCards.forEach(card => grid.appendChild(createCardElement(card)));

  const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
  const needsPagination = totalPages > 1;
  leftBtn.style.display = needsPagination ? 'flex' : 'none';
  rightBtn.style.display = needsPagination ? 'flex' : 'none';
  leftBtn.disabled = page === 0;
  rightBtn.disabled = page >= totalPages - 1;
  
  highlightSkills();
}

function renderSkillSearchPage(page, matches, grid, leftBtn, rightBtn, pageKey) {
  grid.innerHTML = '';
  const CARDS_PER_PAGE = calculateCardsPerPage();
  const startIdx = page * CARDS_PER_PAGE;
  const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
  pageCards.forEach(card => grid.appendChild(createCardElement(card)));

  const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
  const needsPagination = totalPages > 1;
  leftBtn.style.display = needsPagination ? 'flex' : 'none';
  rightBtn.style.display = needsPagination ? 'flex' : 'none';
  leftBtn.disabled = page === 0;
  rightBtn.disabled = page >= totalPages - 1;
  
  highlightSkills();
}

/* ------------- SORTING ------------- */
function sortCards(cards, sortBy, order) {
  const sortedCards = [...cards];
  
  sortedCards.sort((a, b) => {
    let aValue, bValue;
    
    switch (sortBy) {
      case 'rarity':
        if (a.rarity !== b.rarity) {
          return order === 'ascending' ? a.rarity - b.rarity : b.rarity - a.rarity;
        }
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'name':
        aValue = a.char_name.toLowerCase();
        bValue = b.char_name.toLowerCase();
        
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        return b.rarity - a.rarity;
        
      case 'type':
        aValue = a.type;
        bValue = b.type;
        
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        return b.rarity - a.rarity;
        
      case 'release':
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'support_id':
        aValue = a.support_id;
        bValue = b.support_id;
        break;
        
      default:
        if (!isNaN(parseInt(sortBy))) {
          const effectId = parseInt(sortBy);
          aValue = getEffectValueForSorting(a, effectId) || 0;
          bValue = getEffectValueForSorting(b, effectId) || 0;
          break;
        }
        return 0;
    }
    
    if (!aValue && bValue) return order === 'ascending' ? -1 : 1;
    if (aValue && !bValue) return order === 'ascending' ? 1 : -1;
    if (!aValue && !bValue) return 0;
    
    if (sortBy === 'release' || (sortBy === 'rarity' && a.rarity === b.rarity)) {
      try {
        const aDate = new Date(aValue);
        const bDate = new Date(bValue);
        if (isNaN(aDate.getTime()) && !isNaN(bDate.getTime())) return order === 'ascending' ? -1 : 1;
        if (!isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return order === 'ascending' ? 1 : -1;
        if (isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return 0;
        
        aValue = aDate.getTime();
        bValue = bDate.getTime();
      } catch (e) {
        console.warn('Date parsing failed for:', aValue, bValue);
      }
    }
    
    if (aValue < bValue) return order === 'ascending' ? -1 : 1;
    if (aValue > bValue) return order === 'ascending' ? 1 : -1;
    return 0;
  });
  
  return sortedCards;
}

/* ------------- CARD SEARCH ------------- */
function setupCardSearch() {
  const cardSearchInput = document.getElementById('cardSearch');
  const savedCardSearch = localStorage.getItem('cardSearch');
  
  if (savedCardSearch) {
    cardSearchValue = savedCardSearch;
    cardSearchInput.value = savedCardSearch;
  }
  
  cardSearchInput.addEventListener('input', (e) => {
    cardSearchValue = e.target.value.trim().toLowerCase();
    localStorage.setItem('cardSearch', cardSearchValue);
    sectionPages.clear();
    renderSections();
  });
}

function renderCardSearchSection() {
  let filteredCards = cardsData.filter(card => {
    if (region === 'global') {
      if (!card.release_en || card.release_en === '') return false;
    }
    
    if (selectedRarities.size > 0) {
      const hasRarity = 
        (selectedRarities.has('R') && card.rarity === 1) ||
        (selectedRarities.has('SR') && card.rarity === 2) ||
        (selectedRarities.has('SSR') && card.rarity === 3);
      if (!hasRarity) return false;
    }
    
    if (selectedTypes.size > 0 && !selectedTypes.has(card.type)) {
      return false;
    }
    
    return true;
  });
  
  const matches = filteredCards.filter(card => {
    const cardName = card.char_name.toLowerCase();
    return cardName.includes(cardSearchValue);
  });
  
  const typeOrder = { 'speed': 0, 'stamina': 1, 'power': 2, 'guts': 3, 'intelligence': 4, 'friend': 5, 'group': 6 };
  
  matches.sort((a, b) => {
    if (a.rarity !== b.rarity) {
      return b.rarity - a.rarity;
    }
    return typeOrder[a.type] - typeOrder[b.type];
  });

  if (matches.length === 0) {
    return;
  }

  const displaySearchValue = cardSearchValue
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'card-search-header';
  header.textContent = `Card Search: "${displaySearchValue}" (${matches.length} cards)`;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = 'â—€';
  leftBtn.disabled = true;
  rightBtn.textContent = 'â–¶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `cardSearch-${cardSearchValue}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  renderSkillSearchPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);

leftBtn.addEventListener('click', () => {
  const newPage = sectionPages.get(pageKey) - 1;
  if (newPage >= 0) {
    sectionPages.set(pageKey, newPage);
    renderSkillSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
  }
});

rightBtn.addEventListener('click', () => {
  const totalPages = Math.ceil(matches.length / calculateCardsPerPage());
  const newPage = sectionPages.get(pageKey) + 1;
  if (newPage < totalPages) {
    sectionPages.set(pageKey, newPage);
    renderSkillSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
  }
});
}

/* ------------- SKILL SEARCH ------------- */
const maxSearches = 30;

function setupDynamicSkillSearch() {
  const addSearchBtn = document.getElementById('addSearchBtn');
  const skillSearchGroup = document.getElementById('skillSearchGroup');
  
  if (!skillSearchGroup) {
    console.error('Skill search group not found!');
    return;
  }
  
  const existingContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  existingContainers.forEach(container => container.remove());
  
  skillSearches.forEach((search, index) => {
    createSearchBox(search.id, search.value, index === 0);
  });
  
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  skillSearches.forEach(search => {
    const input = document.getElementById(search.id);
    if (input) {
      input.value = search.value;
    }
    
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${search.id}"]`);
    if (colorPicker) {
      const savedColor = localStorage.getItem(`color_${search.id}`) || 'green';
      colorPicker.className = `color-picker ${savedColor}`;
      colorPicker.dataset.color = savedColor;
    }
  });
  
  if (addSearchBtn) {
    addSearchBtn.addEventListener('click', addSearchBox);
  }
  
  skillSearches.forEach(search => {
    setupColorPicker(search.id);
  });
}

function createSearchBox(searchId, value = '') {
  const searchContainer = document.createElement('div');
  searchContainer.className = 'search-input-container';
  
  const isNewBox = !document.getElementById(searchId);
  const savedColor = isNewBox ? 'green' : (localStorage.getItem(`color_${searchId}`) || 'green');
  
  searchContainer.innerHTML = `
    <div class="color-picker ${savedColor}" data-search-id="${searchId}" data-color="${savedColor}"></div>
    <input type="text" id="${searchId}" class="skill-search" placeholder="Search skill" value="${value}">
    <button class="remove-search-btn" data-search-id="${searchId}" title="Remove search">
      Ã—
    </button>
  `;

  const skillSearchGroup = document.getElementById('skillSearchGroup');
  if (!skillSearchGroup) {
    console.error('skillSearchGroup element not found!');
    return;
  }
  
  skillSearchGroup.appendChild(searchContainer);

  setupSearchInput(searchId);
  setupRemoveButton(searchId);
  setupColorPicker(searchId);
}

const colorSequence = [
  'green', 'blue', 'orange', 'red',
  'green-border', 'blue-border', 'orange-border', 'red-border'
];

function setupColorPicker(searchId) {
  const colorPicker = document.querySelector(`.color-picker[data-search-id="${searchId}"]`);
  if (!colorPicker) return;

  const newColorPicker = colorPicker.cloneNode(true);
  colorPicker.parentNode.replaceChild(newColorPicker, colorPicker);

  const savedColor = localStorage.getItem(`color_${searchId}`) || 'green';
  newColorPicker.className = `color-picker ${savedColor}`;
  newColorPicker.dataset.color = savedColor;

  let clickHandler;
  newColorPicker.addEventListener('click', clickHandler = () => {
    const currentColor = newColorPicker.dataset.color;
    const currentIndex = colorSequence.indexOf(currentColor);
    const nextIndex = (currentIndex + 1) % colorSequence.length;
    const nextColor = colorSequence[nextIndex];
    
    newColorPicker.className = `color-picker ${nextColor}`;
    newColorPicker.dataset.color = nextColor;
    
    localStorage.setItem(`color_${searchId}`, nextColor);
    
    highlightSkills();
  });

  newColorPicker._clickHandler = clickHandler;
}

function addSearchBox() {
  if (skillSearches.length >= 30) return;

  const newId = `skillSearch${searchCounter}`;
  searchCounter++;
  
  skillSearches.push({ id: newId, value: '' });
  saveSkillSearches();
  
  createSearchBox(newId, '');
  
  const newColorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
  if (newColorPicker) {
    newColorPicker.className = 'color-picker green';
    newColorPicker.dataset.color = 'green';
    localStorage.setItem(`color_${newId}`, 'green');
  }
  
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  sectionPages.clear();
  renderSections();
  highlightSkills();
  highlightSelectedSkills();
}

function saveSkillSearches() {
  skillSearches.forEach(search => {
    const input = document.getElementById(search.id);
    if (input) {
      search.value = input.value;
    }
  });
  localStorage.setItem('skillSearches', JSON.stringify(skillSearches));
}

function setupSearchInput(searchId) {
  const input = document.getElementById(searchId);
  if (!input) return;

  const savedSearch = skillSearches.find(search => search.id === searchId);
  if (savedSearch) {
    input.value = savedSearch.value;
  }

  input.addEventListener('input', () => {
    const search = skillSearches.find(s => s.id === searchId);
    if (search) {
      search.value = input.value;
      saveSkillSearches();
    }
    
    sectionPages.clear();
    renderSections();
    highlightSkills();
    highlightSelectedSkills();
  });
}

function setupRemoveButton(searchId) {
  const removeBtn = document.querySelector(`.remove-search-btn[data-search-id="${searchId}"]`);
  if (!removeBtn) return;

  const newRemoveBtn = removeBtn.cloneNode(true);
  removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);

  newRemoveBtn.addEventListener('click', () => {
    removeSearchBox(searchId);
  });
}

function removeSearchBox(searchId) {
  if (skillSearches.length <= 1) {
    const input = document.getElementById(searchId);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${searchId}"]`);
    
    if (input) input.value = '';
    if (colorPicker) {
      colorPicker.className = 'color-picker green';
      colorPicker.dataset.color = 'green';
      localStorage.setItem(`color_${searchId}`, 'green');
    }
    
    const search = skillSearches.find(s => s.id === searchId);
    if (search) {
      search.value = '';
      saveSkillSearches();
    }
    
    sectionPages.clear();
    renderSections();
    highlightSkills();
    highlightSelectedSkills();
    return;
  }
  
  const container = document.querySelector(`.search-input-container input[id="${searchId}"]`)?.parentElement;
  if (container) {
    container.remove();
  }
  
  skillSearches = skillSearches.filter(search => search.id !== searchId);
  saveSkillSearches();
  
  localStorage.removeItem(`color_${searchId}`);
  
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  const removedIndex = parseInt(searchId.replace('skillSearch', '')) || 0;
  if (removedIndex < skillSearches.length + 1) {
    reorganizeSearchBoxes();
  } else {
    sectionPages.clear();
    renderSections();
    highlightSkills();
    highlightSelectedSkills();
  }
}

function reorganizeSearchBoxes() {
  skillSearches.sort((a, b) => {
    const aNum = parseInt(a.id.replace('skillSearch', '')) || 0;
    const bNum = parseInt(b.id.replace('skillSearch', '')) || 0;
    return aNum - bNum;
  });
  
  const existingContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  const currentColors = [];
  
  existingContainers.forEach((container, index) => {
    const colorPicker = container.querySelector('.color-picker');
    const color = colorPicker ? colorPicker.dataset.color : 'green';
    currentColors.push(color);
  });
  
  existingContainers.forEach(container => container.remove());
  
  skillSearches.forEach((search, index) => {
    const newId = `skillSearch${index + 1}`;
    const color = currentColors[index] || 'green';
    
    search.id = newId;
    
    createSearchBox(newId, search.value);
    
    const newColorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
    if (newColorPicker) {
      newColorPicker.className = `color-picker ${color}`;
      newColorPicker.dataset.color = color;
      localStorage.setItem(`color_${newId}`, color);
    }
  });
  
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  searchCounter = skillSearches.length + 1;
  saveSkillSearches();
  
  highlightSkills();
  highlightSelectedSkills();
}

/* ------------- TOGGLE BUTTONS ------------- */
function setupToggleButtons() {
  document.querySelectorAll('.rarity-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const rarity = button.dataset.rarity;
      if (selectedRarities.has(rarity)) {
        selectedRarities.delete(rarity);
        button.classList.remove('active');
      } else {
        selectedRarities.add(rarity);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });

  document.querySelectorAll('.type-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const type = button.dataset.type;
      if (selectedTypes.has(type)) {
        selectedTypes.delete(type);
        button.classList.remove('active');
      } else {
        selectedTypes.add(type);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- UTILITIES ------------- */
function normalizeSkill(s){ return String(s||'').replace(/[â—Žâ—‹]/g,'').trim().toLowerCase(); }
function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase(); }
function getLengthCategory(distance){ if(distance<=1400)return'Sprint'; if(distance<=1800)return'Mile'; if(distance<=2400)return'Medium'; return'Long'; }
function isStandardDistance(distance){ return distance%400===0; }
const typeMap = { "speed":"00","stamina":"01","power":"02","guts":"03","intelligence":"04","friend":"05","group":"06" };
function escapeHtml(s){ return String(s).replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

/* ------------- PRESETS ------------- */
function setupPresetReset() {
  const resetFilters = [
    'racecourse', 'length', 'direction', 'track', 'season', 'weather'
  ];
  
  resetFilters.forEach(filterId => {
    const element = document.getElementById(filterId);
    if (element) {
      element.addEventListener('change', () => {
        if (element.value) {
          const presetsSelect = document.getElementById('presets');
          if (presetsSelect && presetsSelect.value) {
            presetsSelect.value = '';
            localStorage.removeItem('filter_presets');
          }
        }
      });
    }
  });
}

function formatPresetDate(dateString) {
  const date = new Date(dateString);
  const month = date.toLocaleString('en-US', { month: 'short' });
  const year = date.getFullYear();
  return `${month} ${year}`;
}

function createPresetLabel(cup, index) {
  const distance = cup.distance === "Mile" ? "MILE" : cup.distance;
  const trackType = cup.aptitude === "Turf" ? "Turf" : "Dirt";
  const length = cup.length.replace(/\s*m/g, 'm');
  
  presetRaceNumbers.set(cup.title, index + 1);
  
  return `${index + 1}. ${cup.title} â€” ${cup.racecourse} ${trackType} ${length} ${cup.track_conditions}`;
}

function setupPresets() {
  const presetsSelect = document.getElementById('presets');
  if (!presetsSelect) return;

  const savedPreset = localStorage.getItem('filter_presets');
  const hasManuallySelectedNone = localStorage.getItem('manuallySelectedNone') === 'true';

  fetch(PRESETS_JSON_FILE)
    .then(response => {
      if (!response.ok) throw new Error('Failed to fetch presets JSON');
      return response.json();
    })
    .then(data => {
      presetsSelect.innerHTML = '<option value="">-- Select --</option>';
      
      const sortedCups = data.cups.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
      
      sortedCups.forEach((cup, index) => {
        const option = document.createElement('option');
        option.value = cup.title;
        option.textContent = createPresetLabel(cup, index);
        option.dataset.cupData = JSON.stringify(cup);
        presetsSelect.appendChild(option);
      });
      
      if (savedPreset) {
        presetsSelect.value = savedPreset;
      } else if (!hasManuallySelectedNone && sortedCups.length >= 2) {
        const secondCup = sortedCups[0];
        presetsSelect.value = secondCup.title;
        localStorage.setItem('filter_presets', secondCup.title);
        
        applyPreset(secondCup);
      }
      
      presetsSelect.addEventListener('change', function() {
        const selectedValue = this.value;
        localStorage.setItem('filter_presets', selectedValue);
        
        if (selectedValue) {
          const selectedOption = this.options[this.selectedIndex];
          const cup = JSON.parse(selectedOption.dataset.cupData);
          applyPreset(cup);
          
          localStorage.removeItem('manuallySelectedNone');
        } else {
          localStorage.setItem('manuallySelectedNone', 'true');
          clearPresetFilters();
          sectionPages.clear();
          renderSections();
        }
      });
    })
    .catch(err => {
      console.error('Could not load presets:', err);
      const option = document.createElement('option');
      option.textContent = 'Error loading presets';
      option.disabled = true;
      presetsSelect.appendChild(option);
    });
}

function clearPresetFilters() {
  const presetFilterIds = ['racecourse', 'length', 'direction', 'track', 'season', 'weather', 'strategy'];
  
  presetFilterIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.value = '';
      localStorage.removeItem('filter_' + id);
    }
  });
  
  sectionPages.clear();
  renderSections();
  highlightSkills();
}

function applyPreset(cup) {
  document.getElementById('racecourse').value = cup.racecourse;
  document.getElementById('length').value = cup.length.replace(' m', '');
  document.getElementById('direction').value = cup.direction;
  document.getElementById('track').value = cup.track_conditions;
  
  const seasonMap = {
    'Autumn': 'Fall',
    'Spring': 'Spring', 
    'Summer': 'Summer',
    'Winter': 'Winter'
  };
  document.getElementById('season').value = seasonMap[cup.season] || cup.season;
  
  const weatherMap = {
    'Rain': 'Rainy',
    'Snow': 'Snowy',
    'Sunny': 'Sunny',
    'Cloudy': 'Cloudy'
  };
  document.getElementById('weather').value = weatherMap[cup.weather] || cup.weather;
  
  document.getElementById('strategy').value = '';
  
  FILTER_KEYS.forEach(id => {
    const el = document.getElementById(id);
    if (el && el.value) localStorage.setItem('filter_' + id, el.value);
  });
  
  localStorage.removeItem('manuallySelectedNone');
  
  sectionPages.clear();
  renderSections();
}

FILTER_KEYS.push('presets');

/* ------------- SORTING CONTROLS ------------- */
function setupSortingControls() {
  const sortBySelect = document.getElementById('sortBy');
  const sortOrderBtn = document.getElementById('sortOrder');
  const regionSelect = document.getElementById('region');

  const savedSortBy = localStorage.getItem('sortBy');
  const savedSortOrder = localStorage.getItem('sortOrder');
  const savedRegion = localStorage.getItem('region');

  if (savedSortBy) {
    sortBy = savedSortBy;
    sortBySelect.value = savedSortBy;
  } else {
    sortBySelect.value = 'rarity';
  }
  
  if (savedSortOrder) {
    sortOrder = savedSortOrder;
    sortOrderBtn.textContent = sortOrder === 'ascending' ? 'â†‘' : 'â†“';
    sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
  } else {
    sortOrder = 'descending';
    sortOrderBtn.textContent = 'â†“';
    sortOrderBtn.classList.remove('ascending');
  }
  
  if (savedRegion) {
    region = savedRegion;
    regionSelect.value = savedRegion;
  } else {
    regionSelect.value = 'global';
  }

sortBySelect.addEventListener('change', (e) => {
  sortBy = e.target.value;
  localStorage.setItem('sortBy', sortBy);
  sectionPages.clear();
  renderSections();
  
  setTimeout(() => {
    updateAllSlotDisplays();
  }, 50);
});

sortOrderBtn.addEventListener('click', () => {
  sortOrder = sortOrder === 'ascending' ? 'descending' : 'ascending';
  sortOrderBtn.textContent = sortOrder === 'ascending' ? 'â†‘' : 'â†“';
  sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
  localStorage.setItem('sortOrder', sortOrder);
  sectionPages.clear();
  renderSections();
  
  setTimeout(() => {
    updateAllSlotDisplays();
  }, 50);
});

  regionSelect.addEventListener('change', (e) => {
    region = e.target.value;
    localStorage.setItem('region', region);
    sectionPages.clear();
    
    updateSlotsForRegion();
    
    updateSelectedSkillsList();
    highlightSkills();
    highlightSelectedSkills();
    
    renderSections();
  });
}

function updateSlotsForRegion() {
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        if (slotListeners.has(slot)) {
          slot.removeEventListener('click', slotListeners.get(slot));
          slotListeners.delete(slot);
        }
        
        addToSlot(card, slot, false);
      }
    }
  });
  
  saveSlotsToLocalStorage();
  
  highlightSkills();
  updateSkillVisibility();
}

function setupHideUncoloredCheckbox() {
  const hideUncoloredCheckbox = document.getElementById('hideUncolored');
  const savedHideUncolored = localStorage.getItem('hideUncolored');

  if (savedHideUncolored) {
    hideUncolored = savedHideUncolored === 'true';
    hideUncoloredCheckbox.checked = hideUncolored;
  }

  hideUncoloredCheckbox.addEventListener('change', (e) => {
    hideUncolored = e.target.checked;
    localStorage.setItem('hideUncolored', hideUncolored);
    updateSkillVisibility();
    updateSelectedSkillsVisibility();
  });
}

/* ------------- CARD ELEMENT CREATION ------------- */
function createCardElement(card){
  const el = document.createElement('div');
  el.className = 'card';
  el.dataset.id = card.char_id;
  el.dataset.supportId = card.support_id;
  el.dataset.name = card.char_name;

  const imgSrc = `https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png`;
  const typeImg = `https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type]||"xx"}.png`;

  const currentLevel = getCardLevel(card.support_id);
  
  const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
  const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

  let skillsHTML = '';
  
  if(card.hint_skills && card.hint_skills.length) {
    const hintSkillsHTML = card.hint_skills.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/â—‹\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
  }

  if(eventSkillsToUse && eventSkillsToUse.length) {
    const eventSkillsHTML = eventSkillsToUse.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/â—‹\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
  }
  
  if (card.unique && card.unique.effects && card.unique.effects.length > 0) {
    const uniqueEffectsHTML = card.unique.effects.map(effect => {
      const effectName = EFFECT_TYPES[effect.type];
      if (effectName) {
        const threshold = card.rarity === 1 ? 20 : card.rarity === 2 ? 25 : 30;
        return `<div class="skill" style="background: #fff0f0; border-left: 3px solid #ff4444;">
          <strong>Unique:</strong> ${effectName} +${effect.value} (Lv. ${threshold}+)
        </div>`;
      }
      return '';
    }).filter(html => html !== '').join('');
    
    if (uniqueEffectsHTML) {
      skillsHTML += `<div class="skills-group"><div class="skills-header">Unique Effects</div>${uniqueEffectsHTML}</div>`;
    }
  }
  
  const combinedLevelHTML = generateCombinedLevelDisplay(card, currentLevel);

  let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;
  
  const sortByValue = document.getElementById('sortBy').value;
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  if (!hideDataOptions.includes(sortByValue)) {
    if (sortByValue === 'support_id') {
      nameHtml += `<div class="small-info-text">ID: ${card.support_id}</div>`;
    } else if (sortByValue === 'release') {
      const releaseDate = region === 'global' ? card.release_en : card.release;
      if (releaseDate && releaseDate !== '') {
        const formattedDate = formatDateForDisplay(releaseDate);
        nameHtml += `<div class="small-info-text">${formattedDate}</div>`;
      }
    } else if (!isNaN(parseInt(sortByValue))) {
      const effectValue = getEffectValueForSorting(card, parseInt(sortByValue));
      if (effectValue !== null) {
        const effectName = EFFECT_TYPES[parseInt(sortByValue)];
        const unit = EFFECT_UNITS[parseInt(sortByValue)] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
          effectValue.toString() : effectValue.toFixed(1);
        
        let displayValue;
        if (unit === "Lv ") {
          displayValue = unit + formattedValue;
        } else {
          displayValue = formattedValue + unit;
        }
        
        nameHtml += `<div class="small-info-text">${effectName}: ${displayValue}</div>`;
      }
    } else {
      if(!HIDE.char_id) nameHtml += `<div class="small-info-text">ID: ${card.char_id}</div>`;
    }
  }
  
  if(!HIDE.url_name && card.url_name) nameHtml += `<div class="small-info-text">${escapeHtml(card.url_name)}</div>`;

  const diamondIconsHTML = generateDiamondIcons(card, currentLevel);

  el.innerHTML = `
    <div class="type-icon"><img src="${typeImg}" alt="${escapeHtml(card.type)}"></div>
    <div class="level-diamond-container">
      ${combinedLevelHTML}
    </div>
    <img src="${imgSrc}" alt="${escapeHtml(card.char_name)}">
    ${nameHtml}
    <div class="skills">${skillsHTML}</div>
  `;

el.addEventListener('click', ()=> {
    if (selectedCardIds.has(card.char_id)) {
        console.log(`Removing ${card.char_name} from slot`);
        
        const existingSlot = slots.find(s => Number(s.dataset.cardId) === card.char_id);
        if (existingSlot) {
            removeFromSlot(existingSlot);
        }
        return;
    }
    
    if (selectedSlot) {
        const slot = selectedSlot.querySelector('.slot');
        if (slot && !slot.dataset.cardId) {
            addToSlot(card, slot);
        } else {
            console.log('Selected slot has card, using normal placement');
            clearSlotSelection();
            
            const availableSlot = slots.find(s => !s.dataset.cardId);
            if (availableSlot) {
                addToSlot(card, availableSlot);
            }
        }
    } else {
        const slot = slots.find(s => !s.dataset.cardId);
        if (slot) {
            addToSlot(card, slot);
        } else {
            console.log('No empty slots available');
        }
    }
});

  if(selectedCardIds.has(card.char_id)) {
    el.classList.add('disabled');
    if (!el.querySelector('[data-dup-label]')) {
      const dupLabel = document.createElement('div');
      dupLabel.textContent = 'Duplicate Support';
      dupLabel.setAttribute('data-dup-label', 'true');
      dupLabel.style.position = 'absolute';
      dupLabel.style.top = '0';
      dupLabel.style.left = '0';
      dupLabel.style.width = '100%';
      dupLabel.style.background = 'red';
      dupLabel.style.color = 'white';
      dupLabel.style.fontSize = '9px';
      dupLabel.style.fontWeight = 'bold';
      dupLabel.style.textAlign = 'center';
      dupLabel.style.padding = '2px 0';
      dupLabel.style.borderTopLeftRadius = '4px';
      dupLabel.style.borderTopRightRadius = '4px';
      dupLabel.style.zIndex = '10';
      el.appendChild(dupLabel);
    }
  }

  return el;
}

function updateCardDisabledStates() {
  const allCards = document.querySelectorAll('.card');
  allCards.forEach(cardEl => {
    const cardId = parseInt(cardEl.dataset.id);
    if (selectedCardIds.has(cardId)) {
      cardEl.classList.add('disabled');
      if (!cardEl.querySelector('[data-dup-label]')) {
        const dupLabel = document.createElement('div');
        dupLabel.textContent = 'Duplicate Support';
        dupLabel.setAttribute('data-dup-label', 'true');
        dupLabel.style.position = 'absolute';
        dupLabel.style.top = '0';
        dupLabel.style.left = '0';
        dupLabel.style.width = '100%';
        dupLabel.style.background = 'red';
        dupLabel.style.color = 'white';
        dupLabel.style.fontSize = '9px';
        dupLabel.style.fontWeight = 'bold';
        dupLabel.style.textAlign = 'center';
        dupLabel.style.padding = '2px 0';
        dupLabel.style.borderTopLeftRadius = '4px';
        dupLabel.style.borderTopRightRadius = '4px';
        dupLabel.style.zIndex = '10';
        cardEl.appendChild(dupLabel);
      }
    } else {
      cardEl.classList.remove('disabled');
      const dupLabel = cardEl.querySelector('[data-dup-label]');
      if (dupLabel) {
        dupLabel.remove();
      }
    }
  });
  
  highlightSkills();
  highlightSelectedSkills();
}

/* ------------- DIAMOND ICONS ------------- */
function generateDiamondIcons(card, currentLevel) {
  let thresholds;
  switch(card.rarity) {
    case 1:
      thresholds = [21, 26, 31, 36];
      break;
    case 2:
      thresholds = [26, 31, 36, 41];
      break;
    case 3:
      thresholds = [31, 36, 41, 46];
      break;
    default:
      thresholds = [21, 26, 31, 36];
  }
  
  let diamondIconsHTML = '';
  
  for (let i = 0; i < 4; i++) {
    const isFilled = currentLevel >= thresholds[i];
    const iconSrc = isFilled ? 'images/diamond_filled.png' : 'images/diamond_empty.png';
    
    diamondIconsHTML += `<img src="${iconSrc}" alt="Diamond ${i+1}" class="diamond-icon" data-threshold="${thresholds[i]}">`;
  }
  
  return diamondIconsHTML;
}

/* ------------- SLOT MANAGEMENT ------------- */
function saveSlotsToLocalStorage() {
  const slotData = slots.map(s => s.dataset.supportId || null);
  localStorage.setItem(SLOT_KEY, JSON.stringify(slotData));
}

function loadSlotsFromLocalStorage() {
  const saved = localStorage.getItem(SLOT_KEY);
  if (!saved) return;
  
  const slotData = JSON.parse(saved);
  let loadedCount = 0;
  
  const waitForData = setInterval(() => {
    if (cardsData && cardsData.length > 0) {
      clearInterval(waitForData);
      
      slotData.forEach((supportId, index) => {
        if (supportId && supportId !== 'empty') {
          const card = cardsData.find(c => String(c.support_id) === String(supportId));
          if (card) {
            const slot = slots[index];
            addToSlot(card, slot, false);
            loadedCount++;
          }
        }
      });
      
      console.log(`Loaded ${loadedCount} cards into slots`);
      
      setTimeout(() => {
        updateAllSlotDisplays();
        setTimeout(updateAllSlotDisplays, 200);
      }, 300);
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(waitForData);
    if (loadedCount === 0) {
      console.warn('Failed to load slot data - cardsData not available');
    }
  }, 5000);
}

function addToSlot(card, targetSlot = null, save = true) {
  if (selectedCardIds.has(card.char_id)) {
    console.log(`Card ${card.char_name} is already in a slot!`);
    
    const existingSlot = slots.find(s => Number(s.dataset.cardId) === card.char_id);
    if (existingSlot) {
      flashSlot(existingSlot);
    }
    
    return;
  }
  
  let freeSlot;
  
    if (targetSlot) {
    freeSlot = targetSlot;
  } else if (selectedSlot) {
    freeSlot = selectedSlot.querySelector('.slot');
  } else {
    freeSlot = slots.find(s => !s.dataset.cardId);
  }
  
  if (!freeSlot) {
    console.log('No available slot found');
    return;
  }
  const savedLevel = getCardLevel(card.support_id);

  const combinedLevelHTML = generateCombinedLevelDisplay(card, savedLevel);

    const slotContainer = freeSlot.closest('.slot-container');
    if (!slotContainer) return;

    if (slotListeners.has(freeSlot)) {
        freeSlot.removeEventListener('click', slotListeners.get(freeSlot));
        slotListeners.delete(freeSlot);
    }

    const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
    const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

    let skillsHTML = '';

    if (card.hint_skills && card.hint_skills.length) {
        const hintSkillsHTML = card.hint_skills.map(s => {
            const skillText = String(s || '');
            return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/â—‹\s*/g, '')))}</div>`;
        }).join('');
        skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
    }

    if (eventSkillsToUse && eventSkillsToUse.length) {
        const eventSkillsHTML = eventSkillsToUse.map(s => {
            const skillText = String(s || '');
            return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/â—‹\s*/g, '')))}</div>`;
        }).join('');
        skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
    }

    if (card.unique && card.unique.effects && card.unique.effects.length > 0) {
        const uniqueEffectsHTML = card.unique.effects.map(effect => {
            const effectName = EFFECT_TYPES[effect.type];
            if (effectName) {
                const threshold = card.rarity === 1 ? 20 : card.rarity === 2 ? 25 : 30;
                const currentLevel = getCardLevel(card.support_id);
                const isActive = shouldApplyUniqueEffects(card, currentLevel);
                const activeStyle = isActive ? 'background: #f0fff0; border-left: 3px solid #44ff44;' : 'background: #fff0f0; border-left: 3px solid #ff4444;';
                
                return `<div class="skill" style="${activeStyle}">
                    <strong>Unique:</strong> ${effectName} +${effect.value} (Lv. ${threshold}+) ${isActive ? 'âœ…' : 'ðŸ”’'}
                </div>`;
            }
            return '';
        }).filter(html => html !== '').join('');

        if (uniqueEffectsHTML) {
            skillsHTML += `<div class="skills-group"><div class="skills-header">Unique Effects</div>${uniqueEffectsHTML}</div>`;
        }
    }

    freeSlot.dataset.cardId = card.char_id;
    freeSlot.dataset.supportId = card.support_id;
    freeSlot.classList.add('has-card');

let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;

const sortByValue = document.getElementById('sortBy').value;
const hideDataOptions = ['rarity', 'name', 'type'];

if (!hideDataOptions.includes(sortByValue)) {
  if (sortByValue === 'support_id') {
    nameHtml += `<div class="small-info-text">ID: ${card.support_id}</div>`;
  } else if (sortByValue === 'release') {
    const releaseDate = region === 'global' ? card.release_en : card.release;
    if (releaseDate && releaseDate !== '') {
      const formattedDate = formatDateForDisplay(releaseDate);
      nameHtml += `<div class="small-info-text">${formattedDate}</div>`;
    }
  } else if (!isNaN(parseInt(sortByValue))) {
    const effectId = parseInt(sortByValue);
    const currentLevel = getCardLevel(card.support_id);
    const effectValue = getEffectValueAtCurrentLevel(card, effectId, currentLevel);
    
    if (effectValue !== null) {
      const effectName = EFFECT_TYPES[effectId];
      const unit = EFFECT_UNITS[effectId] || "";
      const formattedValue = Number.isInteger(effectValue) ? 
        effectValue.toString() : effectValue.toFixed(1);
      
      let displayValue;
      if (unit === "Lv ") {
        displayValue = unit + formattedValue;
      } else {
        displayValue = formattedValue + unit;
      }
      
      nameHtml += `<div class="small-info-text">${effectName}: ${displayValue}</div>`;
    }
  } else {
    if(!HIDE.char_id) nameHtml += `<div class="small-info-text">ID: ${card.char_id}</div>`;
  }
  
  if(!HIDE.url_name && card.url_name) nameHtml += `<div class="small-info-text">${escapeHtml(card.url_name)}</div>`;
}

  freeSlot.innerHTML = `
      <div class="type-icon"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type] || "xx"}.png" alt="${escapeHtml(card.type)}"></div>
      <div class="level-diamond-container">
        ${combinedLevelHTML}
      </div>
      <img src="https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png" alt="${escapeHtml(card.char_name)}">
      ${nameHtml}
      <div class="skills">${skillsHTML}</div>
  `;
    const levelControls = slotContainer.querySelector('.slot-level-controls');
    const levelInput = levelControls.querySelector('.slot-level-input');

    levelInput.disabled = false;
    levelInput.min = '1';
    levelInput.max = getMaxLevel(card);
    
    levelInput.value = savedLevel;

const handleLevelChange = (e) => {
  const newLevel = updateSlotLevel(slotContainer, card, e.target.value);
  e.target.value = newLevel;
  
  updateUniqueEffectsDisplay(freeSlot, card, newLevel);
  
  updateSlotNameWithEffectData(freeSlot, card, newLevel);
  refreshSlotDisplay(freeSlot, card, newLevel);
  
  refreshCombinedLevelDisplay(freeSlot, card, newLevel);
  
  syncCardLevelInMainGrid(card.support_id, newLevel);
};

levelInput.onchange = handleLevelChange;
levelInput.onblur = handleLevelChange;
    levelInput.oninput = (e) => {
        const value = parseInt(e.target.value);
        const maxLevel = getMaxLevel(card);
        if (value > maxLevel) {
            e.target.value = maxLevel;
        } else if (value < 1 || isNaN(value)) {
            e.target.value = 1;
        }
    };

    const slotCard = { ...card };

function slotClickHandler(e) {
  e.stopPropagation();
  
  if (e.target.closest('.level-diamond-container') ||
      e.target.closest('.slot-level-input') || 
      e.target.closest('.slot-level-controls') ||
      e.target.closest('.type-icon')) {
    return;
  }
  
  removeFromSlot(freeSlot, slotCard);
}

    freeSlot.addEventListener('click', slotClickHandler);
    slotListeners.set(freeSlot, slotClickHandler);

  selectedCardIds.add(card.char_id);
  if (save) saveSlotsToLocalStorage();

  updateSelectedSkillsList();
  updateCardDisabledStates();
  
  setTimeout(updateEffectTotals, 100);

  if (targetSlot && selectedSlot && selectedSlot.contains(targetSlot)) {
    clearSlotSelection();
  }
}

function removeFromSlot(slot, card) {
  if (!slot) return;

  const slotContainer = slot.closest('.slot-container');
  if (!slotContainer) return;

  if (slotListeners.has(slot)) {
    slot.removeEventListener('click', slotListeners.get(slot));
    slotListeners.delete(slot);
  }

  slot.classList.remove('has-card');
  
  if (card) {
    selectedCardIds.delete(card.char_id);
  } else if (slot.dataset.cardId) {
    selectedCardIds.delete(Number(slot.dataset.cardId));
  }
  
  const supportId = slot.dataset.supportId;
  delete slot.dataset.cardId;
  delete slot.dataset.supportId;
  
  slot.innerHTML = '<div class="placeholder">Empty</div>';

  const levelInput = slotContainer.querySelector('.slot-level-input');
  if (levelInput) {
    levelInput.disabled = true;
    levelInput.value = '1';
    levelInput.min = '1';
    levelInput.max = '50';
  }

  if (selectedSlot && selectedSlot.contains(slot)) {
    console.log('Card removed from selected slot - selection maintained');
  }

  saveSlotsToLocalStorage();
  updateSelectedSkillsList();
  updateCardDisabledStates();
  
  setTimeout(updateEffectTotals, 100);
}

function refreshSlotDisplay(slot, card, level) {
    const sortByValue = document.getElementById('sortBy').value;
    
    if (!isNaN(parseInt(sortByValue))) {
    const effectId = parseInt(sortByValue);
    const effectValue = getEffectValueAtCurrentLevel(card, effectId, level);
    
    const effectDisplay = slot.querySelector('.name + div');
    if (effectDisplay && effectDisplay.textContent.includes(EFFECT_TYPES[effectId])) {
        const effectName = EFFECT_TYPES[effectId];
        const unit = EFFECT_UNITS[effectId] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
            effectValue.toString() : effectValue.toFixed(1);
        
        let displayValue;
        if (unit === "Lv ") {
            displayValue = unit + formattedValue;
        } else {
            displayValue = formattedValue + unit;
        }
        
        effectDisplay.textContent = `${effectName}: ${displayValue}`;
    }
}
    
    setTimeout(updateEffectTotals, 50);
}

/* ------------- CLEAR BUTTONS ------------- */
clearAllBtn.addEventListener('click', () => {
    selectedCardIds.clear();

    slotContainers.forEach(container => {
        const levelInput = container.querySelector('.slot-level-input');
        levelInput.disabled = true;
        levelInput.value = '1';
        levelInput.min = '1';
        levelInput.max = '50';

        const slot = container.querySelector('.slot');
        if (slotListeners.has(slot)) {
            slot.removeEventListener('click', slotListeners.get(slot));
            slotListeners.delete(slot);
        }
        slot.classList.remove('has-card');
        delete slot.dataset.cardId;
        delete slot.dataset.supportId;
        slot.innerHTML = '<div class="placeholder">Empty</div>';
    });

    localStorage.removeItem(SLOT_KEY);
    updateSelectedSkillsList();
    highlightSkills();
    highlightSelectedSkills();
    renderSections();

    setTimeout(() => {
        updateEffectTotals();
    }, 100);
});

clearFiltersBtn.addEventListener('click', () => {
  const presetFilterIds = ['racecourse', 'length', 'direction', 'track', 'season', 'weather', 'strategy'];
  
  presetFilterIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.value = '';
      localStorage.removeItem('filter_' + id);
    }
  });

  const cardSearchInput = document.getElementById('cardSearch');
  if (cardSearchInput) {
    cardSearchInput.value = '';
    cardSearchValue = '';
    localStorage.removeItem('cardSearch');
  }

  showPresetCards = true;
  localStorage.setItem('showPresetCards', 'true');
  updateTogglePresetCardsButton();
  updateSidebarFiltersVisibility();

  const presetsSelect = document.getElementById('presets');
  if (presetsSelect) {
    presetsSelect.value = '';
    localStorage.removeItem('filter_presets');
    localStorage.setItem('manuallySelectedNone', 'true');
  }
  
  sectionPages.clear();
  renderSections();
  updateSkillVisibility();
});

/* ------------- FILTER PERSISTENCE ------------- */
function setupFilterPersistence(){
  FILTER_KEYS.forEach(id=>{
    const el=document.getElementById(id); if(!el)return;
    const saved=localStorage.getItem('filter_'+id); if(saved) el.value=saved;
    el.addEventListener('change', ()=>{
      localStorage.setItem('filter_'+id, el.value);
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- SKILL HIGHLIGHTING ------------- */
function highlightSkills() {
  document.querySelectorAll('.skill').forEach(skill => {
    skill.classList.remove('highlighted', 'search-highlighted');
    skill.removeAttribute('data-has-border');
    skill.style.background = '#eef2ff';
    skill.style.color = '#000';
  });
  
  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

const searchTerms = SKILL_SEARCH_KEYS
  .map(id => {
    const input = document.getElementById(id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${id}"]`);
    const color = colorPicker ? colorPicker.dataset.color : 'green';
    return {
      term: input?.value.trim().toLowerCase(),
      color: color
    };
  })
  .filter(item => item.term);

  const colorMap = {
    racecourse: '#bce934',
    length: '#fdb832',
    direction: '#bce934',
    track: '#bce934',
    season: '#bce934',
    weather: '#bce934',
    strategy: '#fdb832'
  };

  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },
      { term: `${s} Straightaways`, color: colorMap.strategy },
      { term: `${s} Savvy`, color: colorMap.racecourse }
    );
  }
  
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },
      { term: `${label} Straightaways`, color: colorMap.length },
      { term: distType, color: colorMap.racecourse }
    );
  }

    document.querySelectorAll('.skill').forEach(skill => {
    const skillText = normalizeSkill(skill.textContent || '');
    
    for (const { term, color } of searchTerms) {
if (skillText.includes(term)) {
  const colorValue = getColorValue(color);
  const textColor = getTextColor(color);
  const hasBorder = color.includes('-border');
  
  skill.style.setProperty('background', colorValue, 'important');
  skill.style.setProperty('color', textColor, 'important');
  skill.classList.add('search-highlighted');
  
  if (hasBorder) {
    skill.setAttribute('data-has-border', 'true');
  }
  return;
}
    }
    
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skill.style.background = color;
        skill.style.color = '#000';
        skill.classList.add('highlighted');
        break;
      }
    }
  });

  updateSkillVisibility();
}

function getColorValue(colorName) {
  const colorMap = {
    green: '#bce934',
    blue: '#1cd8fe', 
    orange: '#fdb832',
    red: '#fca5a5',
    'green-border': '#57ad33',
    'blue-border': '#14a1f7',
    'orange-border': '#fa9937', 
    'red-border': '#f75757'
  };
  return colorMap[colorName] || '#bce934';
}

function getTextColor(colorName) {
  if (colorName.includes('-border')) {
    return '#ffffff';
  }
  return '#000000';
}

function updateSkillVisibility() {
  const shouldHide = hideUncolored;
  
  document.querySelectorAll('.skill').forEach(skill => {
    const isHighlighted = skill.classList.contains('highlighted') || 
                         skill.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skill.classList.add('hidden-skill');
    } else {
      skill.classList.remove('hidden-skill');
    }
  });
  
  document.querySelectorAll('.skills-group').forEach(group => {
    const skills = group.querySelectorAll('.skill');
    const visibleSkills = Array.from(skills).filter(skill => !skill.classList.contains('hidden-skill'));
    
    const header = group.querySelector('.skills-header');
    if (header) {
      if (shouldHide && visibleSkills.length === 0) {
        header.classList.add('hidden-skill');
        group.classList.add('hidden-skill');
      } else {
        header.classList.remove('hidden-skill');
        group.classList.remove('hidden-skill');
      }
    }
  });
}

function updateAllSlotDisplays() {
  console.log('Updating all slot displays...');
  
  slots.forEach((slot, index) => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        console.log(`Updating slot ${index} with card: ${card.char_name}`);
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        const currentLevel = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
        
        forceUpdateSlotNameWithEffectData(slot, card, currentLevel);
      }
    } else {
      console.log(`Slot ${index} is empty`);
    }
  });
}

function forceUpdateSlotNameWithEffectData(slot, card, level) {
  console.log(`Updating slot effect text for: ${card.char_name}`);
  
  const sortByValue = document.getElementById('sortBy').value;
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  const nameContainer = slot.querySelector('.name');
  if (!nameContainer) return;
  
  let nextElement = nameContainer.nextElementSibling;
  while (nextElement) {
    if (nextElement.classList && nextElement.classList.contains('small-info-text')) {
      nextElement.remove();
    }
    nextElement = nextElement.nextElementSibling;
  }
  
  if (!hideDataOptions.includes(sortByValue)) {
    if (sortByValue === 'support_id') {
      const effectDiv = document.createElement('div');
      effectDiv.className = 'small-info-text';
      effectDiv.textContent = `ID: ${card.support_id}`;
      nameContainer.after(effectDiv);
    } else if (sortByValue === 'release') {
      const releaseDate = region === 'global' ? card.release_en : card.release;
      if (releaseDate && releaseDate !== '') {
        const formattedDate = formatDateForDisplay(releaseDate);
        const effectDiv = document.createElement('div');
        effectDiv.className = 'small-info-text';
        effectDiv.textContent = formattedDate;
        nameContainer.after(effectDiv);
      }
    } else if (!isNaN(parseInt(sortByValue))) {
      const effectId = parseInt(sortByValue);
      const effectValue = getEffectValueAtCurrentLevel(card, effectId, level);
      
      if (effectValue !== null) {
        const effectName = EFFECT_TYPES[effectId];
        const unit = EFFECT_UNITS[effectId] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
          effectValue.toString() : effectValue.toFixed(1);
        
        let displayValue;
        if (unit === "Lv ") {
          displayValue = unit + formattedValue;
        } else {
          displayValue = formattedValue + unit;
        }
        
        const effectDiv = document.createElement('div');
        effectDiv.className = 'small-info-text';
        effectDiv.textContent = `${effectName}: ${displayValue}`;
        nameContainer.after(effectDiv);
      }
    } else {
      if(!HIDE.char_id) {
        const effectDiv = document.createElement('div');
        effectDiv.className = 'small-info-text';
        effectDiv.textContent = `ID: ${card.char_id}`;
        nameContainer.after(effectDiv);
      }
    }
    
    if(!HIDE.url_name && card.url_name) {
      const urlDiv = document.createElement('div');
      urlDiv.className = 'small-info-text';
      urlDiv.textContent = card.url_name;
      nameContainer.after(urlDiv);
    }
  }
  
  console.log(`Slot effect text updated for: ${card.char_name}`);
}

function updateSlotNameWithEffectData(slot, card, level) {
  const nameContainer = slot.querySelector('.name');
  if (!nameContainer) return;
  
  const sortByValue = document.getElementById('sortBy').value;
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  let nextElement = nameContainer.nextElementSibling;
  while (nextElement) {
    if (nextElement.classList && nextElement.classList.contains('small-info-text')) {
      nextElement.remove();
    }
    nextElement = nextElement.nextElementSibling;
  }
  
  if (!hideDataOptions.includes(sortByValue)) {
    if (sortByValue === 'support_id') {
      const effectDiv = document.createElement('div');
      effectDiv.className = 'small-info-text';
      effectDiv.textContent = `ID: ${card.support_id}`;
      nameContainer.after(effectDiv);
    } else if (sortByValue === 'release') {
      const releaseDate = region === 'global' ? card.release_en : card.release;
      if (releaseDate && releaseDate !== '') {
        const formattedDate = formatDateForDisplay(releaseDate);
        const effectDiv = document.createElement('div');
        effectDiv.className = 'small-info-text';
        effectDiv.textContent = formattedDate;
        nameContainer.after(effectDiv);
      }
    } else if (!isNaN(parseInt(sortByValue))) {
      const effectId = parseInt(sortByValue);
      const effectValue = getEffectValueAtCurrentLevel(card, effectId, level);
      
      if (effectValue !== null) {
        const effectName = EFFECT_TYPES[effectId];
        const unit = EFFECT_UNITS[effectId] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
          effectValue.toString() : effectValue.toFixed(1);
        
        let displayValue;
        if (unit === "Lv ") {
          displayValue = unit + formattedValue;
        } else {
          displayValue = formattedValue + unit;
        }
        
        const effectDiv = document.createElement('div');
        effectDiv.className = 'small-info-text';
        effectDiv.textContent = `${effectName}: ${displayValue}`;
        nameContainer.after(effectDiv);
      }
    } else {
      if(!HIDE.char_id) {
        const effectDiv = document.createElement('div');
        effectDiv.className = 'small-info-text';
        effectDiv.textContent = `ID: ${card.char_id}`;
        nameContainer.after(effectDiv);
      }
    }
    
    if(!HIDE.url_name && card.url_name) {
      const effectDiv = document.createElement('div');
      effectDiv.className = 'small-info-text';
      effectDiv.textContent = card.url_name;
      nameContainer.after(effectDiv);
    }
  }
}

/* ------------- FILTER BUILDING & MATCHING ------------- */
function buildFilterTerms(filters){
  const terms=[];
  if(filters.racecourse) terms.push(`${filters.racecourse} Racecourse`);
  if(filters.direction) terms.push(filters.direction==='Clockwise'?'Right-Handed':'Left-Handed');
  if(filters.track) terms.push(filters.track==='Firm'?'Firm Conditions':'Wet Conditions');
  
  if(filters.season) {
    terms.push(`${filters.season} Runner`);
  }
  
  if(filters.weather) {
    terms.push(`${filters.weather} Days`);
  }
  
  if(filters.strategy){
    const s=filters.strategy;
    terms.push(`${s} Corners`,`${s} Straightaways`,`${s} Savvy`);
  }
  if(filters.length){
    const dist=parseInt(filters.length);
    const label=getLengthCategory(dist);
    terms.push(`${label} Corners`,`${label} Straightaways`,isStandardDistance(dist)?'Standard Distance':'Non-Standard Distance');
  }
  return terms;
}

function filterCardsWithRules(cards,filters){
  const terms=buildFilterTerms(filters).map(normalizeSkill);
  const strictDistanceKeys=['standard distance','non-standard distance'];
  const strictTerms=terms.filter(t=>strictDistanceKeys.includes(t));
  const looseTerms=terms.filter(t=>!strictDistanceKeys.includes(t));
  return cards.filter(card=>{
    const skills=[...card.hint_skills,...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t=>skills.includes(t)) && looseTerms.every(term=>skills.some(s=>s.includes(term)));
  });
}

/* ------------- RENDER SECTIONS ------------- */
function renderSections() {
  cardSections.innerHTML='';

  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

const anyDropdownActive = Object.values(filters).some(v => v);
const anySkillActive = SKILL_SEARCH_KEYS.some(key => document.getElementById(key)?.value.trim());
const anyRarityActive = selectedRarities.size > 0;
const anyTypeActive = selectedTypes.size > 0;
const anyCardSearchActive = cardSearchValue.length > 0;

  if(!anyDropdownActive && !anySkillActive && !anyRarityActive && !anyTypeActive && !anyCardSearchActive) {
    const section = document.createElement('div');
    section.className = 'card-section';
    section.style.display = 'flex';
    section.style.flexDirection = 'column';
    section.style.alignItems = 'center';
    section.style.justifyContent = 'center';
    const msg = document.createElement('div');
    msg.style.opacity = '0.7';
    msg.style.padding = '0px';
    msg.style.marginTop = '20px';
    msg.style.marginBottom = '10px';
    msg.textContent = 'Pick a label on the left or type a skill to show matching cards.';
    section.appendChild(msg);
    cardSections.appendChild(section);
    return;
  }

let baseFilteredCards = cardsData.filter(card => {
  if (region === 'global') {
    return card.release_en && card.release_en !== '';
  } else {
    return true;
  }
});
  
  if (anyRarityActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      if (selectedRarities.has('R') && card.rarity === 1) return true;
      if (selectedRarities.has('SR') && card.rarity === 2) return true;
      if (selectedRarities.has('SSR') && card.rarity === 3) return true;
      return false;
    });
  }
  
  if (anyTypeActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      return selectedTypes.has(card.type);
    });
  }

  baseFilteredCards = sortCards(baseFilteredCards, sortBy, sortOrder);

  if (anyCardSearchActive) {
    renderCardSearchSection();
  }

const filterOrder = ['racecourse','length','direction','track','season','weather','strategy'];
filterOrder.forEach(catId => {
  if (!filters[catId]) return;

  if (!shouldShowFilterSection(catId)) return;

  if (catId === 'length') {
      const dist = parseInt(filters.length);
      const label = getLengthCategory(dist);
      const distanceType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';

      [
        { title: `${label} Corners`, terms: [`${label} Corners`] },
        { title: `${label} Straightaways`, terms: [`${label} Straightaways`] },
        { title: distanceType, terms: [distanceType] }
      ].forEach((row, idx) => renderFilterRow(catId, row.title, row.terms, idx, baseFilteredCards));

    } else if (catId === 'strategy') {
      const strat = filters.strategy;
      const stratRows = [
        { title: `${strat} Corners`, term: `${strat} Corners` },
        { title: `${strat} Straightaways`, term: `${strat} Straightaways` },
        { title: `${strat} Savvy`, term: `${strat} Savvy` }
      ];
      stratRows.forEach((row, idx) => renderFilterRow(catId, row.title, [row.term], idx, baseFilteredCards));

    } else {
      let rowTerms = [], headerText = '';
      switch (catId) {
        case 'racecourse': rowTerms.push(`${filters.racecourse} Racecourse`); headerText = `${filters.racecourse} Racecourse`; break;
        case 'direction': const dir = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed'; rowTerms.push(dir); headerText = dir; break;
        case 'track': const trackLabel = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions'; rowTerms.push(trackLabel); headerText = trackLabel; break;
        case 'season': rowTerms.push(`${filters.season} Runner`); headerText = `${filters.season} Runner`; break;
        case 'weather': rowTerms.push(`${capitalize(filters.weather)} Days`); headerText = `${capitalize(filters.weather)} Days`; break;
      }
      renderFilterRow(catId, headerText, rowTerms, 0, baseFilteredCards);
    }
  });

SKILL_SEARCH_KEYS.forEach((key, i) => {
  const val = document.getElementById(key)?.value.trim();
  if (!val) return;

  const normalized = normalizeSkill(val);
  
  const uniqueMatches = new Set();
  const matches = [];
  
  baseFilteredCards.forEach(card => {
    const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
    const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
    
    const skills = [...card.hint_skills, ...eventSkillsToUse].map(normalizeSkill);
    const hasMatch = skills.some(s => s.includes(normalized));
    
    if (hasMatch && !uniqueMatches.has(card.support_id)) {
      uniqueMatches.add(card.support_id);
      matches.push(card);
    }
  });

  const header = `Skill Search ${i + 1}: "${val}"`;
  renderSkillSearchRow(key, header, matches, i);
});

  highlightSkills();
}

function renderFilterRow(catId, headerText, termList, rowIndex, baseCards){
  const termsNormalized = termList.map(normalizeSkill);
  const strictDistanceKeys = ['standard distance','non-standard distance'];
  const strictTerms = termsNormalized.filter(t => strictDistanceKeys.includes(t));
  const looseTerms = termsNormalized.filter(t => !strictDistanceKeys.includes(t));

  const matches = baseCards.filter(card => {
    const skills = [...card.hint_skills, ...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t => skills.includes(t)) && looseTerms.every(term => skills.some(s => s.includes(term)));
  });

  if(matches.length === 0){
    return;
  }

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.textContent = headerText;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button'); 
  leftBtn.textContent = 'â—€';
  leftBtn.disabled = true;
  const rightBtn = document.createElement('button'); 
  rightBtn.textContent = 'â–¶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  const pageKey = `${catId}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  renderFilterPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);
  cardSections.appendChild(section);
}

function properCaseSkill(s) {
  return String(s || '')
    .split(' ')
    .map(word => {
      if (word.includes('-')) {
        return word
          .split('-')
          .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
          .join('-');
      }
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

function renderSkillSearchRow(key, headerText, matches, rowIndex) {
  if (matches.length === 0) {
    return;
  }

  const input = document.getElementById(key);
  const searchValue = input ? input.value.trim() : '';
  const displaySearchValue = searchValue
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'skill-search-header';
  header.textContent = `Skill Search ${rowIndex + 1}: "${displaySearchValue}"`;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = 'â—€';
  leftBtn.disabled = true;
  rightBtn.textContent = 'â–¶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `${key}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  renderCardSearchPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);

  leftBtn.addEventListener('click', () => {
    const newPage = sectionPages.get(pageKey) - 1;
    if (newPage >= 0) {
      sectionPages.set(pageKey, newPage);
      renderCardSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
    }
  });

  rightBtn.addEventListener('click', () => {
    const totalPages = Math.ceil(matches.length / calculateCardsPerPage());
    const newPage = sectionPages.get(pageKey) + 1;
    if (newPage < totalPages) {
      sectionPages.set(pageKey, newPage);
      renderCardSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
    }
  });
}

/* ------------- TOGGLE PRESET CARDS ------------- */
function setupTogglePresetCards() {
  const togglePresetCardsBtn = document.getElementById('togglePresetCardsBtn');
  
  const savedState = localStorage.getItem('showPresetCards');
  if (savedState !== null) {
    showPresetCards = savedState === 'true';
    updateTogglePresetCardsButton();
    updateSidebarFiltersVisibility();
  }

  togglePresetCardsBtn.addEventListener('click', () => {
    showPresetCards = !showPresetCards;
    localStorage.setItem('showPresetCards', showPresetCards);
    updateTogglePresetCardsButton();
    updateSidebarFiltersVisibility();
    renderSections();
  });
}

function updateTogglePresetCardsButton() {
  const togglePresetCardsBtn = document.getElementById('togglePresetCardsBtn');
  togglePresetCardsBtn.textContent = showPresetCards ? 
    'Hide Preset Cards' : 
    'Show Preset Cards';
}

function updateSidebarFiltersVisibility() {
  const sidebarFiltersSection = document.getElementById('sidebarFiltersSection');
  if (sidebarFiltersSection) {
    if (showPresetCards) {
      sidebarFiltersSection.classList.remove('hidden');
    } else {
      sidebarFiltersSection.classList.add('hidden');
    }
  }
}

function shouldShowFilterSection(catId) {
  if (!showPresetCards) {
    return false;
  }
  return true;
}

/* ------------- SELECTED SKILLS MANAGEMENT ------------- */
function updateSelectedSkillsList() {
  const skillsList = document.getElementById('selectedSkillsList');
  const skillsCount = document.getElementById('skillsCount');
  
  if (!skillsList) return;
  
  const allSkills = getAllSkillsFromSelectedCards();
  
  skillsList.innerHTML = '';
  
  allSkills.forEach(skill => {
    const skillElement = document.createElement('div');
    skillElement.className = 'skill-item';
    skillElement.textContent = skill;
    skillsList.appendChild(skillElement);
  });
  
  if (skillsCount) {
    skillsCount.textContent = allSkills.length;
  }
  
  highlightSelectedSkills();
  updateSelectedSkillsVisibility();
}

function getAllSkillsFromSelectedCards() {
    const allSkills = new Set();
    
    slots.forEach(slot => {
        if (slot.dataset.supportId) {
            const supportId = slot.dataset.supportId;
            const card = cardsData.find(c => String(c.support_id) === String(supportId));
            
            if (card) {
                const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
                const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
                
                if (card.hint_skills) {
                    card.hint_skills.forEach(skill => {
                        const cleanSkill = String(skill || '').replace(/â—‹\s*/g, '').trim();
                        if (cleanSkill) allSkills.add(properCaseSkill(cleanSkill));
                    });
                }
                
                if (eventSkillsToUse) {
                    eventSkillsToUse.forEach(skill => {
                        const cleanSkill = String(skill || '').replace(/â—‹\s*/g, '').trim();
                        if (cleanSkill) allSkills.add(properCaseSkill(cleanSkill));
                    });
                }
            }
        }
    });
    
    return Array.from(allSkills).sort();
}

function highlightSelectedSkills() {
  const skillItems = document.querySelectorAll('.skill-item');
  if (skillItems.length === 0) return;
  
  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };
  
const searchTerms = SKILL_SEARCH_KEYS
  .map(id => {
    const input = document.getElementById(id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${id}"]`);
    const color = colorPicker ? colorPicker.dataset.color : 'green';
    return {
      term: input?.value.trim().toLowerCase(),
      color: color
    };
  })
  .filter(item => item.term);
  
  const colorMap = {
    racecourse: '#bce934',
    length: '#fdb832',
    direction: '#bce934',
    track: '#bce934',
    season: '#bce934',
    weather: '#bce934',
    strategy: '#fdb832'
  };
  
  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },
      { term: `${s} Straightaways`, color: colorMap.strategy },
      { term: `${s} Savvy`, color: colorMap.racecourse }
    );
  }
  
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },
      { term: `${label} Straightaways`, color: colorMap.length },
      { term: distType, color: colorMap.racecourse }
    );
  }
  
  skillItems.forEach(skillItem => {
    skillItem.classList.remove('highlighted', 'search-highlighted');
    skillItem.removeAttribute('data-has-border');
    skillItem.style.background = '#eef2ff';
    skillItem.style.color = '#000';
    
    const skillText = normalizeSkill(skillItem.textContent || '');
    
    for (const { term, color } of searchTerms) {
      if (skillText.includes(term)) {
        const colorValue = getColorValue(color);
        const textColor = getTextColor(color);
        const hasBorder = color.includes('-border');
        
        skillItem.style.setProperty('background', colorValue, 'important');
        skillItem.style.setProperty('color', textColor, 'important');
        skillItem.classList.add('search-highlighted');
        
        if (hasBorder) {
          skillItem.setAttribute('data-has-border', 'true');
        }
        return;
      }
    }
    
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skillItem.style.background = color;
        skillItem.style.color = '#000';
        skillItem.classList.add('highlighted');
        break;
      }
    }
  });
}

function updateSelectedSkillsVisibility() {
  const shouldHide = hideUncolored;
  const skillItems = document.querySelectorAll('.skill-item');
  
  skillItems.forEach(skillItem => {
    const isHighlighted = skillItem.classList.contains('highlighted') || 
                         skillItem.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skillItem.classList.add('hidden-skill');
    } else {
      skillItem.classList.remove('hidden-skill');
    }
  });
}

/* ------------- LEVEL MANAGEMENT ------------- */
function getCardRarity(card) {
  if (card.rarity === 3) return 'SSR';
  if (card.rarity === 2) return 'SR';
  return 'R';
}

function getMaxLevel(card) {
  return MAX_LEVELS[getCardRarity(card)] || 50;
}

function validateLevel(level, card) {
  let num = parseInt(level);
  if (isNaN(num) || num < 1) return 1;
  
  const maxLevel = getMaxLevel(card);
  if (num > maxLevel) return maxLevel;
  
  return num;
}

function updateSlotLevel(slotContainer, card, level) {
    const validatedLevel = validateLevel(level, card);
    
    saveCardLevel(card.support_id, validatedLevel);
    
    const levelInput = slotContainer.querySelector('.slot-level-input');
    if (levelInput) {
        levelInput.value = validatedLevel;
    }
    
    syncCardLevelInMainGrid(card.support_id, validatedLevel);
    
    setTimeout(updateEffectTotals, 50);
    
    return validatedLevel;
}

function createLevelControls(slot, card) {
  const levelControls = document.createElement('div');
  levelControls.className = 'slot-level-controls';
  
  const levelLabel = document.createElement('span');
  levelLabel.className = 'slot-level-label';
  levelLabel.textContent = 'Level';
  
  const levelInput = document.createElement('input');
  levelInput.type = 'number';
  levelInput.className = 'slot-level-input';
  levelInput.min = '1';
  levelInput.max = getMaxLevel(card);
  levelInput.value = slotLevels[card.support_id] || 1;
  
  levelInput.addEventListener('change', (e) => {
    const newLevel = updateSlotLevel(slot, card, e.target.value);
    e.target.value = newLevel;
  });
  
  levelInput.addEventListener('blur', (e) => {
    const newLevel = updateSlotLevel(slot, card, e.target.value);
    e.target.value = newLevel;
  });
  
  levelControls.appendChild(levelLabel);
  levelControls.appendChild(levelInput);
  
  return levelControls;
}

/* ------------- DARK MODE ------------- */
function setupDarkMode() {
  const darkModeToggle = document.getElementById('darkModeToggle');
  const savedDarkMode = localStorage.getItem('darkMode') === 'true';
  
  if (savedDarkMode) {
    document.body.classList.add('dark-mode');
    darkModeToggle.textContent = 'â˜€ï¸';
  } else {
    darkModeToggle.textContent = 'ðŸŒ™';
  }
  
  darkModeToggle.addEventListener('click', () => {
    const isDarkMode = document.body.classList.toggle('dark-mode');
    localStorage.setItem('darkMode', isDarkMode);
    
    darkModeToggle.textContent = isDarkMode ? 'â˜€ï¸' : 'ðŸŒ™';
  });
}

document.addEventListener('DOMContentLoaded', setupDarkMode);

setupHideUncoloredCheckbox();

['racecourse','length','direction','track','season','weather','strategy']
  .forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.addEventListener('change', renderSections);
    }
  });

document.addEventListener('DOMContentLoaded', () => {
  renderSections();
});

window.addEventListener('resize', renderSections);

document.addEventListener('DOMContentLoaded', () => {
});

let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    sectionPages.clear();
    renderSections();
  }, 250);
});

/* ------------- SKILL SEARCH COPY/PASTE ------------- */
function setupCopyPasteButtons() {
  const copyBtn = document.getElementById('copySkillsBtn');
  const pasteBtn = document.getElementById('pasteSkillsBtn');
  
  copyBtn.addEventListener('click', copySkillsToClipboard);
  pasteBtn.addEventListener('click', pasteSkillsFromClipboard);
}

function copySkillsToClipboard() {
  const skillsData = skillSearches.map(search => {
    const input = document.getElementById(search.id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${search.id}"]`);
    
    if (input && input.value.trim() && colorPicker) {
      return {
        skill: input.value.trim(),
        color: colorPicker.dataset.color
      };
    }
    return null;
  }).filter(item => item !== null);
  
  if (skillsData.length === 0) {
    alert('No skills to copy!');
    return;
  }
  
  const copyText = skillsData.map(item => `${item.skill}|${item.color}`).join(',');
  
  navigator.clipboard.writeText(copyText).then(() => {
    const copyBtn = document.getElementById('copySkillsBtn');
    const originalText = copyBtn.textContent;
    copyBtn.textContent = 'Copied!';
    copyBtn.style.background = '#57ad33';
    
    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.style.background = '';
    }, 1500);
    
    console.log(`Copied ${skillsData.length} skill(s) to clipboard`);
  }).catch(err => {
    console.error('Failed to copy skills: ', err);
    alert('Failed to copy skills to clipboard');
  });
}

function pasteSkillsFromClipboard() {
  navigator.clipboard.readText().then(text => {
    try {
      const skillsData = parseSkillsFromClipboard(text);
      
      if (skillsData.length === 0) {
        alert('No valid skills found in clipboard!');
        return;
      }
      
      clearAllSkillSearches();
      
      skillsData.forEach((skillItem, index) => {
        if (index < maxSearches) {
          if (index === 0) {
            const firstInput = document.getElementById('skillSearch1');
            const firstColorPicker = document.querySelector('.color-picker[data-search-id="skillSearch1"]');
            
            if (firstInput) firstInput.value = skillItem.skill;
            if (firstColorPicker) {
              firstColorPicker.className = `color-picker ${skillItem.color}`;
              firstColorPicker.dataset.color = skillItem.color;
              localStorage.setItem('color_skillSearch1', skillItem.color);
            }
            
            const firstSearch = skillSearches.find(s => s.id === 'skillSearch1');
            if (firstSearch) {
              firstSearch.value = skillItem.skill;
            }
          } else {
            const newId = `skillSearch${index + 1}`;
            
            skillSearches.push({ id: newId, value: skillItem.skill });
            
            createSearchBox(newId, skillItem.skill);
            
            const colorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
            if (colorPicker) {
              colorPicker.className = `color-picker ${skillItem.color}`;
              colorPicker.dataset.color = skillItem.color;
              localStorage.setItem(`color_${newId}`, skillItem.color);
            }
          }
        }
      });
      
      searchCounter = skillSearches.length + 1;
      SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
      
      saveSkillSearches();
      
      sectionPages.clear();
      renderSections();
      highlightSkills();
      highlightSelectedSkills();
      
      const pasteBtn = document.getElementById('pasteSkillsBtn');
      const originalText = pasteBtn.textContent;
      pasteBtn.textContent = `Pasted ${skillsData.length}`;
      pasteBtn.style.background = '#14a1f7';
      
      setTimeout(() => {
        pasteBtn.textContent = originalText;
        pasteBtn.style.background = '';
      }, 1500);
      
      console.log(`Pasted ${skillsData.length} skill(s) from clipboard`);
      
    } catch (error) {
      console.error('Failed to parse clipboard data: ', error);
      alert('Invalid format in clipboard! Use Copy Skills button first.');
    }
  }).catch(err => {
    console.error('Failed to read clipboard: ', err);
    alert('Failed to read from clipboard. Please check permissions.');
  });
}

function parseSkillsFromClipboard(text) {
  if (!text || typeof text !== 'string') {
    throw new Error('Invalid clipboard data');
  }
  
  const skills = text.split(',').map(item => {
    if (!item || !item.includes('|')) return null;
    
    const [skill, color] = item.split('|');
    if (skill && color) {
      return {
        skill: skill.trim(),
        color: color.trim()
      };
    }
    return null;
  }).filter(item => item !== null);
  
  return skills;
}

/* ------------- CLEAR ALL SKILL SEARCHES ------------- */
function setupClearAllSearches() {
  const clearAllSearchesBtn = document.getElementById('clearAllSearchesBtn');
  
  clearAllSearchesBtn.addEventListener('click', clearAllSkillSearches);
}

function clearAllSkillSearches() {
  const searchContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  
  if (searchContainers.length === 0) return;
  
  const firstContainer = searchContainers[0];
  const firstInput = firstContainer.querySelector('.skill-search');
  const firstColorPicker = firstContainer.querySelector('.color-picker');
  
  if (firstInput) firstInput.value = '';
  if (firstColorPicker) {
    firstColorPicker.className = 'color-picker green';
    firstColorPicker.dataset.color = 'green';
  }
  
  for (let i = searchContainers.length - 1; i > 0; i--) {
    searchContainers[i].remove();
  }
  
  skillSearches = [{ id: 'skillSearch1', value: '' }];
  searchCounter = 2;
  SKILL_SEARCH_KEYS = ['skillSearch1'];
  
  localStorage.setItem('skillSearches', JSON.stringify(skillSearches));
  localStorage.setItem('color_skillSearch1', 'green');
  
  for (let i = 2; i <= 30; i++) {
    localStorage.removeItem(`color_skillSearch${i}`);
  }
  
  sectionPages.clear();
  renderSections();
  highlightSkills();
  highlightSelectedSkills();
  
  const clearBtn = document.getElementById('clearAllSearchesBtn');
  const originalText = clearBtn.textContent;
  clearBtn.textContent = 'Cleared!';
  clearBtn.style.background = '#f75757';
  
  setTimeout(() => {
    clearBtn.textContent = originalText;
    clearBtn.style.background = '';
  }, 1500);
}

/* ------------- DECK COPY/PASTE ------------- */
function setupDeckCopyPaste() {
  const copyDeckBtn = document.getElementById('copyDeckBtn');
  const pasteDeckBtn = document.getElementById('pasteDeckBtn');
  
  copyDeckBtn.addEventListener('click', copyDeckToClipboard);
  pasteDeckBtn.addEventListener('click', pasteDeckFromClipboard);
}

function copyDeckToClipboard() {
    const deckData = slots.map(slot => {
        const supportId = slot.dataset.supportId;
        let level = '1';
        if (supportId) {
            level = getCardLevel(supportId).toString();
        } else {
            const levelInput = slot.closest('.slot-container').querySelector('.slot-level-input');
            level = levelInput ? levelInput.value : '1';
        }

        return {
            supportId: supportId || 'empty',
            level: supportId ? level : '1'
        };
    });

    const copyText = deckData.map(slot => `${slot.supportId}|${slot.level}`).join(',');

    navigator.clipboard.writeText(copyText).then(() => {
        const copyBtn = document.getElementById('copyDeckBtn');
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = '#57ad33';

        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = '';
        }, 1500);

        console.log('Deck copied to clipboard with levels:', deckData);
    }).catch(err => {
        console.error('Failed to copy deck: ', err);
        alert('Failed to copy deck to clipboard');
    });
}

function pasteDeckFromClipboard() {
  navigator.clipboard.readText().then(text => {
    try {
      const deckData = parseDeckFromClipboard(text);
      
      if (!deckData || deckData.length !== 6) {
        alert('Invalid deck format! Expected 6 slots.');
        return;
      }

if (window.programmaticClearDeck) {
  window.programmaticClearDeck();
} else {
  clearAllBtn.click();
}
      
      setTimeout(() => {
        let hasValidCards = false;
        
        deckData.forEach((slotData, index) => {
          if (slotData.supportId !== 'empty') {
            const card = cardsData.find(c => String(c.support_id) === String(slotData.supportId));
            if (card) {
              const slot = slots[index];
              addToSlot(card, slot, false);
              
              if (slotData.level && slotData.level !== '1') {
                const slotContainer = slot.closest('.slot-container');
                const levelInput = slotContainer.querySelector('.slot-level-input');
                if (levelInput) {
                  const validatedLevel = validateLevel(slotData.level, card);
                  levelInput.value = validatedLevel;
                  slotLevels[card.support_id] = validatedLevel;
                }
              }
              
              hasValidCards = true;
            } else {
              console.warn(`Card with support_id ${slotData.supportId} not found`);
            }
          }
        });
        
        saveSlotsToLocalStorage();
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
        
        updateSelectedSkillsList();
        highlightSkills();
        highlightSelectedSkills();
        renderSections();
        
        const pasteBtn = document.getElementById('pasteDeckBtn');
        const originalText = pasteBtn.textContent;
        const validCardCount = deckData.filter(slot => slot.supportId !== 'empty').length;
        pasteBtn.textContent = `Pasted ${validCardCount}`;
        pasteBtn.style.background = '#14a1f7';
        
        setTimeout(() => {
          pasteBtn.textContent = originalText;
          pasteBtn.style.background = '';
        }, 1500);
        
        if (!hasValidCards) {
          alert('No valid cards found in the deck data!');
        }
        
      }, 100);
      
    } catch (error) {
      console.error('Failed to parse deck data: ', error);
      alert('Invalid deck format in clipboard! Use Copy Deck button first.');
    }
  }).catch(err => {
    console.error('Failed to read clipboard: ', err);
    alert('Failed to read from clipboard. Please check permissions.');
  });
}

function parseDeckFromClipboard(text) {
  const slots = text.split(',').map((item, index) => {
    const [supportId, level] = item.split('|');
    
    if (!supportId) {
      throw new Error(`Invalid format at slot ${index + 1}`);
    }
    
    return {
      supportId: supportId.trim(),
      level: (level || '1').trim()
    };
  });
  
  if (slots.length !== 6) {
    throw new Error(`Expected 6 slots, got ${slots.length}`);
  }
  
  return slots;
}

/* ------------- EFFECT CALCULATION ------------- */
const EFFECT_TYPES = {
  1: "Friendship Bonus",
  2: "Mood Effect", 
  3: "Speed Bonus",
  4: "Stamina Bonus",
  5: "Power Bonus",
  6: "Guts Bonus",
  7: "Wit Bonus",
  8: "Training Effectiveness",
  9: "Initial Speed",
  10: "Initial Stamina",
  11: "Initial Power",
  12: "Initial Guts",
  13: "Initial Wit",
  14: "Initial Friendship Gauge",
  15: "Race Bonus",
  16: "Fan Bonus",
  17: "Hint Levels",
  18: "Hint Frequency",
  19: "Specialty Priority",
  25: "Event Recovery",
  26: "Event Effectiveness", 
  27: "Failure Protection",
  28: "Energy Cost Reduction",
  30: "Skill Point Bonus",
  31: "Wit Friendship Recovery",
  32: "Initial Skill Points Up",
  41: "All Stats Bonus"
};

function loadEffectsData() {
    console.log('Effects data already loaded from support-cards.json');
    return Promise.resolve(supportsDataWithEffects);
}

function findCardWithEffects(supportId) {
    if (!supportsDataWithEffects || supportsDataWithEffects.length === 0) {
        console.warn('supportsDataWithEffects not loaded yet');
        return null;
    }
    
    const card = supportsDataWithEffects.find(c => c.support_id == supportId);
    return card;
}

function initializeEffectCalculation() {
    console.log('Initializing effect calculation system...');
    
    loadEffectsData().then(() => {
        console.log('Effect calculation system ready');
        setupEffectCalculation();
    }).catch(error => {
        console.warn('Error loading effects data, continuing without effect calculations:', error);
        setupEffectCalculation();
    });
}

function clamp(x, min, max) {
  return Math.max(min, Math.min(x, max));
}

function computeGrowth(knownLevels, knownValues, n) {
  if (knownLevels.length === 0) return 0;
  if (knownLevels.length === 1) return knownValues[0];

  const y1 = knownValues[0];
  let total = y1;

  for (let i = 0; i < knownLevels.length - 1; i++) {
    const L1 = knownLevels[i];
    const L2 = knownLevels[i + 1];
    const v1 = knownValues[i];
    const v2 = knownValues[i + 1];
    const slope = (v2 - v1) / (L2 - L1);
    total += slope * clamp(n - L1, 0, L2 - L1);
  }

  return total;
}

function parseCardData(data) {
  if (!Array.isArray(data) || data.length < 2) {
    return { id: data[0], knownLevels: [], knownValues: [] };
  }

  const id = data[0];
  const init = data[1];
  const baseLevels = [1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
  const limits = data.slice(2);

  const knownLevels = [];
  const knownValues = [];

  if (init !== undefined && init !== -1) {
    knownLevels.push(1);
    knownValues.push(init);
  }

  for (let i = 0; i < limits.length && (i + 1) < baseLevels.length; i++) {
    const val = limits[i];
    const lvl = baseLevels[i + 1];
    if (val !== undefined && val !== -1) {
      knownLevels.push(lvl);
      knownValues.push(val);
    }
  }

  return { id, knownLevels, knownValues };
}

function getEffectValueAtLevel(effectData, level) {
  try {
    const { knownLevels, knownValues } = parseCardData(effectData);
    
    if (knownLevels.length === 0) return 0;
    
    return computeGrowth(knownLevels, knownValues, level);
  } catch (error) {
    console.warn('Error calculating effect value:', error, effectData);
    return 0;
  }
}

function getEffectValueAtCurrentLevel(card, effectId, level) {
  const cardWithEffects = findCardWithEffects(card.support_id);
  
  if (!cardWithEffects || !cardWithEffects.effects) {
    return null;
  }
  
  const effectData = cardWithEffects.effects.find(effect => effect[0] === effectId);
  
  if (!effectData) {
    return 0;
  }
  
  const currentValue = getEffectValueAtLevel(effectData, level);
  
  if (shouldApplyUniqueEffects(card, level)) {
    const uniqueValue = getUniqueEffectValue(card, effectId);
    return currentValue + uniqueValue;
  }
  
  return currentValue;
}

const EFFECT_UNITS = {
  1: "%",
  2: "%",
  3: "",
  4: "",
  5: "",
  6: "",
  7: "",
  8: "%",
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: "",
  15: "%",
  16: "%",
  17: "Lv ",
  18: "%",
  19: "",
  25: "%",
  26: "%",
  27: "%",
  28: "%",
  30: "",
  31: "%",
  32: "",
  41: ""
};

function updateEffectTotals() {
  try {
    console.log('Updating effect totals UI with card contributions...');
    const contributions = calculateEffectContributions();
    const isCollapsed = document.getElementById('rightSidebar').classList.contains('collapsed');
    
    const hasCards = document.querySelectorAll('.slot.has-card').length > 0;
    
    Object.entries(contributions).forEach(([effectName, data]) => {
      const effectElements = document.querySelectorAll(`[data-effect="${effectName}"]`);
      
      effectElements.forEach(element => {
        if (data.total === 0 && data.cards.length === 0) {
          element.style.display = 'none';
          
          const valueSpan = element.querySelector('.effect-value');
          if (valueSpan) {
            valueSpan.textContent = '0';
          }
          
          const cardsContainer = element.querySelector('.effect-cards');
          if (cardsContainer) {
            cardsContainer.innerHTML = '';
          }
          return;
        }
        
        element.style.display = 'flex';
        
        const valueSpan = element.querySelector('.effect-value');
        if (valueSpan) {
          const effectId = Object.keys(EFFECT_TYPES).find(key => 
            EFFECT_TYPES[key] === effectName
          );
          const unit = EFFECT_UNITS[effectId] || "";
          const formattedValue = Number.isInteger(data.total) ? 
            data.total.toString() : data.total.toFixed(1);
          
          if (unit === "Lv ") {
            valueSpan.textContent = unit + formattedValue;
          } else {
            valueSpan.textContent = formattedValue + unit;
          }
        }

        const cardsContainer = element.querySelector('.effect-cards');
        if (cardsContainer) {
          if (isCollapsed) {
            cardsContainer.style.display = 'none';
          } else {
            cardsContainer.style.display = 'flex';
            cardsContainer.innerHTML = '';
            
            const sortedCards = [...data.cards].sort((a, b) => b.value - a.value);
            
            sortedCards.forEach(cardData => {
              const cardElement = document.createElement('div');
              cardElement.className = 'effect-card';
              
              const card = findCardWithEffects(cardData.supportId);
              let unit = "";
              if (card && card.effects) {
                const effectData = card.effects.find(effect => 
                  EFFECT_TYPES[effect[0]] === effectName
                );
                if (effectData) {
                  unit = EFFECT_UNITS[effectData[0]] || "";
                }
              }
              
              const formattedCardValue = Number.isInteger(cardData.value) ? 
                cardData.value.toString() : cardData.value.toFixed(1);
              
              let tooltipValue;
              if (unit === "Lv ") {
                tooltipValue = unit + formattedCardValue;
              } else {
                tooltipValue = formattedCardValue + unit;
              }
              
              cardElement.title = `${cardData.char_name} (Lv. ${cardData.level}): +${tooltipValue}`;
              
              let displayValue;
              if (unit === "Lv ") {
                displayValue = unit + formattedCardValue;
              } else {
                displayValue = "+" + formattedCardValue + unit;
              }
              
              cardElement.innerHTML = `
                <img src="https://gametora.com/images/umamusume/supports/support_card_s_${cardData.supportId}.png" 
                    alt="${cardData.char_name}" 
                    class="effect-card-img">
                <div class="effect-card-value">${displayValue}</div>
              `;
              
              cardsContainer.appendChild(cardElement);
            });
            
            if (sortedCards.length > 6) {
              cardsContainer.classList.add('has-many-cards');
            } else {
              cardsContainer.classList.remove('has-many-cards');
            }
          }
        }
      });
    });
    
  } catch (error) {
    console.error('Error updating effect totals:', error);
  }
}

function setupEffectCalculation() {
  console.log('Setting up effect calculation with card contributions...');
  
  const originalAddToSlot = window.addToSlot;
  const originalRemoveFromSlot = window.removeFromSlot;
  
  window.addToSlot = function(card, targetSlot = null, save = true) {
    const result = originalAddToSlot(card, targetSlot, save);
    
    setTimeout(() => {
      updateEffectTotals();
      
      const slot = targetSlot || document.querySelector('.slot[data-support-id]:not(.has-card)');
      if (slot) {
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        if (levelInput) {
          levelInput.addEventListener('change', updateEffectTotals);
          levelInput.addEventListener('input', updateEffectTotals);
        }
      }
    }, 100);
    
    return result;
  };
  
  window.removeFromSlot = function(slot, card) {
    const result = originalRemoveFromSlot(slot, card);
    
    setTimeout(() => {
      updateEffectTotals();
    }, 100);
    
    return result;
  };
  
  document.querySelectorAll('.slot-level-input').forEach(input => {
    input.addEventListener('change', updateEffectTotals);
    input.addEventListener('input', updateEffectTotals);
  });

  
  setTimeout(updateEffectTotals, 1500);
}

document.addEventListener('DOMContentLoaded', initializeEffectCalculation);

document.addEventListener('DOMContentLoaded', function() {
  if (window.pasteDeckFromClipboard) {
    const originalPasteDeck = window.pasteDeckFromClipboard;
    window.pasteDeckFromClipboard = function() {
      return originalPasteDeck().then(() => {
        setTimeout(updateEffectTotals, 500);
      });
    };
  }
});

window.updateEffects = updateEffectTotals;
window.getCardEffects = findCardWithEffects;

/* ------------- COLLAPSIBLE SIDEBAR ------------- */
function setupCollapsibleSidebar() {
  const rightSidebar = document.getElementById('rightSidebar');
  const collapseToggle = document.getElementById('collapseSidebar');
  
  const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';

  if (isCollapsed) {
    rightSidebar.classList.add('collapsed');
    collapseToggle.textContent = 'â—€';
    collapseToggle.title = 'Expand sidebar';
  } else {
    collapseToggle.textContent = 'â–¶';
    collapseToggle.title = 'Collapse sidebar';
  }

  collapseToggle.addEventListener('click', () => {
    const isNowCollapsed = !rightSidebar.classList.contains('collapsed');
    
    if (isNowCollapsed) {
      rightSidebar.classList.add('collapsed');
      collapseToggle.textContent = 'â—€';
      collapseToggle.title = 'Expand sidebar';
      localStorage.setItem('sidebarCollapsed', 'true');
    } else {
      rightSidebar.classList.remove('collapsed');
      collapseToggle.textContent = 'â–¶';
      collapseToggle.title = 'Collapse sidebar';
      localStorage.setItem('sidebarCollapsed', 'false');
    }
    
    setTimeout(updateEffectTotals, 50);
    
    setTimeout(() => {
      sectionPages.clear();
      renderSections();
    }, 100);
  });
}

document.addEventListener('DOMContentLoaded', function() {
  setupCollapsibleSidebar();
});

/* ------------- UNIQUE EFFECTS ------------- */
function shouldApplyUniqueEffects(card, level) {
  if (!card.unique || !card.unique.effects || card.unique.effects.length === 0) {
    return false;
  }
  
  const rarity = card.rarity;
  const threshold = rarity === 1 ? 20 : rarity === 2 ? 25 : 30;
  
  return level >= threshold;
}

function getUniqueEffectValue(card, effectType) {
  if (!card.unique || !card.unique.effects) return 0;
  
  const uniqueEffect = card.unique.effects.find(effect => effect.type === effectType);
  return uniqueEffect ? uniqueEffect.value : 0;
}

function calculateEffectContributions() {
  console.log('Calculating effect contributions...');
  const contributions = {};
  
  Object.values(EFFECT_TYPES).forEach(effectName => {
    contributions[effectName] = {
      total: 0,
      cards: []
    };
  });

  const slots = document.querySelectorAll('.slot');
  
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const slotContainer = slot.closest('.slot-container');
      const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
      const level = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
      
      const card = findCardWithEffects(supportId);
      
      if (card && card.effects) {
        card.effects.forEach(effectData => {
          const effectId = effectData[0];
          const effectName = EFFECT_TYPES[effectId];
          
          if (effectName) {
            let value = getEffectValueAtLevel(effectData, level);
            
            if (shouldApplyUniqueEffects(card, level)) {
              const uniqueValue = getUniqueEffectValue(card, effectId);
              value += uniqueValue;
            }
            
            if (value > 0) {
              contributions[effectName].total += value;
              contributions[effectName].cards.push({
                supportId: supportId,
                value: value,
                level: level,
                char_name: card.char_name,
                hasUnique: shouldApplyUniqueEffects(card, level) && getUniqueEffectValue(card, effectId) > 0
              });
            }
          }
        });
      }
    }
  });
  
  return contributions;
}

function updateUniqueEffectsDisplay(slot, card, level) {
    const uniqueEffects = slot.querySelectorAll('.skills-group:last-child .skill');
    if (uniqueEffects.length > 0 && card.unique && card.unique.effects) {
        uniqueEffects.forEach((effectElement, index) => {
            const uniqueEffect = card.unique.effects[index];
            if (uniqueEffect) {
                const threshold = card.rarity === 1 ? 20 : card.rarity === 2 ? 25 : 30;
                const isActive = level >= threshold;
                const activeStyle = isActive ? 'background: #f0fff0; border-left: 3px solid #44ff44;' : 'background: #fff0f0; border-left: 3px solid #ff4444;';
                
                effectElement.style.cssText = activeStyle;
                const text = effectElement.textContent;
                const newText = text.replace(/âœ…|ðŸ”’/g, isActive ? 'âœ…' : 'ðŸ”’');
                effectElement.textContent = newText;
            }
        });
    }
}

/* ------------- SORTING HELPERS ------------- */
function formatDateForDisplay(dateString) {
  if (!dateString) return 'Unknown';
  
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return dateString;
    
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  } catch (e) {
    return dateString;
  }
}

function getEffectValueForSorting(card, effectId) {
  const cardWithEffects = findCardWithEffects(card.support_id);
  
  if (!cardWithEffects || !cardWithEffects.effects) {
    return null;
  }
  
  const effectData = cardWithEffects.effects.find(effect => effect[0] === effectId);
  
  if (!effectData) {
    return 0;
  }
  
  const maxLevel = getMaxLevel(card);
  const maxValue = getEffectValueAtLevel(effectData, maxLevel);
  
  if (shouldApplyUniqueEffects(card, maxLevel)) {
    const uniqueValue = getUniqueEffectValue(card, effectId);
    return maxValue + uniqueValue;
  }
  
  return maxValue;
}

/* ------------- SYNC CARD LEVELS ------------- */
function syncCardLevelInMainGrid(supportId, newLevel) {
    const mainGridCards = document.querySelectorAll(`.card[data-support-id="${supportId}"]`);
    
    mainGridCards.forEach(cardElement => {
        const card = cardsData.find(c => c.support_id == supportId);
        if (!card) return;
        
        const levelDiamondContainer = cardElement.querySelector('.level-diamond-container');
        if (levelDiamondContainer) {
            levelDiamondContainer.innerHTML = generateCombinedLevelDisplay(card, newLevel);
        }
        
        updateCardEffectDisplay(cardElement, supportId, newLevel);
        
        console.log(`Synced main grid card: ${card.char_name} to Lv ${newLevel}`);
    });
}

function updateCardEffectDisplay(cardElement, supportId, newLevel) {
  const card = cardsData.find(c => c.support_id == supportId);
  if (!card) return;
  
  const sortByValue = document.getElementById('sortBy').value;
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  if (!hideDataOptions.includes(sortByValue) && !isNaN(parseInt(sortByValue))) {
    const effectId = parseInt(sortByValue);
    const effectValue = getEffectValueAtCurrentLevel(card, effectId, newLevel);
    
    if (effectValue !== null) {
      const effectName = EFFECT_TYPES[effectId];
      const unit = EFFECT_UNITS[effectId] || "";
      const formattedValue = Number.isInteger(effectValue) ? 
        effectValue.toString() : effectValue.toFixed(1);
      
      let displayValue;
      if (unit === "Lv ") {
        displayValue = unit + formattedValue;
      } else {
        displayValue = formattedValue + unit;
      }
      
      const nameContainer = cardElement.querySelector('.name');
      let effectDisplay = nameContainer?.nextElementSibling;
      
      if (!effectDisplay || !effectDisplay.classList.contains('small-info-text')) {
        const existingInfoTexts = cardElement.querySelectorAll('.name + .small-info-text');
        existingInfoTexts.forEach(el => el.remove());
        
        effectDisplay = document.createElement('div');
        effectDisplay.className = 'small-info-text';
        if (nameContainer) {
          nameContainer.after(effectDisplay);
        }
      }
      
      effectDisplay.textContent = `${effectName}: ${displayValue}`;
    }
  }
}

function fixFirstSearchBoxColors() {
  const firstSearchBox = document.getElementById('skillSearch1');
  if (!firstSearchBox) return;
  
  const firstColorPicker = document.querySelector('.color-picker[data-search-id="skillSearch1"]');
  if (firstColorPicker) {
    const savedColor = localStorage.getItem('color_skillSearch1') || 'green';
    firstColorPicker.className = `color-picker ${savedColor}`;
    firstColorPicker.dataset.color = savedColor;
    
    console.log('First search box color fixed:', savedColor);
  }
}

setTimeout(fixFirstSearchBoxColors, 500);

function ensureSlotsLoaded() {
  console.log('Ensuring slots are properly loaded...');
  
  const slotsWithCards = Array.from(slots).filter(slot => slot.dataset.supportId);
  
  if (slotsWithCards.length > 0) {
    console.log(`Found ${slotsWithCards.length} slots with cards, verifying effect text...`);
    
    let needsUpdate = false;
    slotsWithCards.forEach(slot => {
      const nameContainer = slot.querySelector('.name');
      if (nameContainer) {
        const effectText = nameContainer.nextElementSibling;
        if (!effectText || !effectText.style || effectText.style.fontSize !== '8px') {
          needsUpdate = true;
        }
      }
    });
    
    if (needsUpdate) {
      console.log('Slots need effect text update, forcing refresh...');
      updateAllSlotDisplays();
    }
  }
}

/* ------------- SLOT SELECTION ------------- */
function setupSlotSelection() {
  slotContainers.forEach((container, index) => {
    container.addEventListener('click', (e) => {
      const slot = container.querySelector('.slot');
      
      if (e.target.closest('.slot-level-input') || 
          e.target.closest('.type-icon') ||
          e.target.closest('.level-badge') ||
          e.target.closest('.diamond-icons') ||
          e.target.closest('.skills') ||
          e.target.closest('.name') ||
          e.target.closest('img') ||
          slot.classList.contains('has-card')) {
        return;
      }
      
      if (!slot.classList.contains('has-card')) {
        handleSlotSelection(container, index);
      }
    });
  });
  
  const savedSelection = localStorage.getItem(SLOT_SELECTION_KEY);
  if (savedSelection !== null) {
    const slotIndex = parseInt(savedSelection);
    if (!isNaN(slotIndex) && slotContainers[slotIndex]) {
      selectedSlot = slotContainers[slotIndex];
      const slot = selectedSlot.querySelector('.slot');
      if (!slot.classList.contains('has-card')) {
        selectedSlot.classList.add('selected');
      } else {
        localStorage.removeItem(SLOT_SELECTION_KEY);
        selectedSlot = null;
      }
    }
  }
}

function handleSlotSelection(container, index) {
  const slot = container.querySelector('.slot');
  
  if (slot.classList.contains('has-card')) {
    return;
  }
  
  const isSameSlot = selectedSlot === container;
  
  if (isSameSlot) {
    clearSlotSelection();
    console.log(`Slot ${index + 1} deselected`);
    return;
  }
  
  clearSlotSelection();
  
  selectedSlot = container;
  container.classList.add('selected');
  
  localStorage.setItem(SLOT_SELECTION_KEY, index.toString());
  
  console.log(`Slot ${index + 1} selected - next card clicked will go here`);
}

function clearSlotSelection() {
  if (selectedSlot) {
    selectedSlot.classList.remove('selected');
    selectedSlot = null;
    localStorage.removeItem(SLOT_SELECTION_KEY);
  }
}

/* ------------- KEYBOARD SHORTCUTS ------------- */
function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearSlotSelection();
    }
  });
}

function flashSlot(slot) {
  const container = slot.closest('.slot-container');
  if (!container) return;
  
  container.classList.add('flash-warning');
  
  setTimeout(() => {
    container.classList.remove('flash-warning');
  }, 1000);
}

/* ------------- DECK NAME ------------- */
function setupDeckName() {
  const deckNameInput = document.getElementById('deckNameInput');
  const deckNameDisplay = document.getElementById('deckNameDisplay');
  const MAX_LENGTH = 30;
  
  const savedDeckName = localStorage.getItem('deckName');
  if (savedDeckName) {
    deckNameInput.value = savedDeckName;
    deckNameDisplay.textContent = savedDeckName;
    console.log('Loaded deck name from storage:', savedDeckName);
  }
  
  deckNameInput.addEventListener('input', (e) => {
    const name = e.target.value;
    deckNameDisplay.textContent = name || 'Unnamed Deck';
    localStorage.setItem('deckName', name);
    console.log('Deck name updated:', name || 'Unnamed Deck');
  });
}

/* ------------- COPY ALL ------------- */
function setupCopyAll() {
  const copyAllBtn = document.getElementById('copyAllBtn');
  copyAllBtn.addEventListener('click', copyAllToClipboard);
}

function copyAllToClipboard() {
  const deckName = document.getElementById('deckNameInput').value.trim() || 'Unnamed Deck';
  
  const deckData = slots.map(slot => {
    const supportId = slot.dataset.supportId;
    let level = '1';
    if (supportId) {
      level = getCardLevel(supportId).toString();
    } else {
      const levelInput = slot.closest('.slot-container').querySelector('.slot-level-input');
      level = levelInput ? levelInput.value : '1';
    }

    return {
      supportId: supportId || 'empty',
      level: supportId ? level : '1'
    };
  });

  const skillsData = skillSearches.map(search => {
    const input = document.getElementById(search.id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${search.id}"]`);
    
    if (input && colorPicker) {
      return {
        skill: input.value.trim(),
        color: colorPicker.dataset.color
      };
    }
    return null;
  }).filter(item => item !== null);

  const allData = {
    version: '1.0',
    deckName: deckName,
    deck: deckData,
    skills: skillsData,
    timestamp: new Date().toISOString()
  };

  const copyText = JSON.stringify(allData);

  navigator.clipboard.writeText(copyText).then(() => {
    const copyBtn = document.getElementById('copyAllBtn');
    const originalText = copyBtn.textContent;
    copyBtn.textContent = 'Copied!';
    copyBtn.style.background = '#57ad33';

    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.style.background = '';
    }, 1500);

    console.log('All data copied to clipboard:', allData);
  }).catch(err => {
    console.error('Failed to copy all data: ', err);
    alert('Failed to copy all data to clipboard');
  });
}

/* ------------- PASTE ALL ------------- */
function setupPasteAll() {
  const pasteAllBtn = document.getElementById('pasteAllBtn');
  pasteAllBtn.addEventListener('click', pasteAllFromClipboard);
}

function pasteAllFromClipboard() {
  navigator.clipboard.readText().then(text => {
    try {
      const allData = JSON.parse(text);
      
      if (!allData.deck || !allData.skills || !allData.version) {
        throw new Error('Invalid format: Missing required fields');
      }
      
      if (allData.version !== '1.0') {
        throw new Error('Unsupported format version');
      }
      
      console.log('Pasting data with deck name:', allData.deckName);
      
      clearAllBtn.click();
      
      setTimeout(() => {
        const deckNameInput = document.getElementById('deckNameInput');
        const deckNameDisplay = document.getElementById('deckNameDisplay');
        
        if (deckNameInput && deckNameDisplay) {
          if (allData.deckName && allData.deckName.trim() !== '') {
            deckNameInput.value = allData.deckName;
            deckNameDisplay.textContent = allData.deckName;
            localStorage.setItem('deckName', allData.deckName);
            console.log('Deck name successfully set to:', allData.deckName);
          } else {
            deckNameInput.value = '';
            deckNameDisplay.textContent = 'Unnamed Deck';
            localStorage.removeItem('deckName');
            console.log('No deck name in data, reset to default');
          }
        } else {
          console.error('Deck name elements not found!');
        }
        
allData.deck.forEach((slotData, index) => {
  if (slotData.supportId !== 'empty') {
    const card = cardsData.find(c => String(c.support_id) === String(slotData.supportId));
    if (card) {
      const slot = slots[index];
      addToSlot(card, slot, false);
      
      if (slotData.level && slotData.level !== '1') {
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        if (levelInput) {
          const validatedLevel = validateLevel(slotData.level, card);
          levelInput.value = validatedLevel;
          slotLevels[card.support_id] = validatedLevel;
          
          const levelBadge = slot.querySelector('.level-badge');
          const diamondIcons = slot.querySelector('.diamond-icons');
          
          if (levelBadge) levelBadge.textContent = `Lv ${validatedLevel}`;
          if (diamondIcons) diamondIcons.innerHTML = generateDiamondIcons(card, validatedLevel);
        }
      }
    }
  }
});

refreshAllSlotLevelDisplays();
        
        clearAllSkillSearches();
        
        allData.skills.forEach((skillItem, index) => {
          if (index < maxSearches) {
            if (index === 0) {
              const firstInput = document.getElementById('skillSearch1');
              const firstColorPicker = document.querySelector('.color-picker[data-search-id="skillSearch1"]');
              
              if (firstInput) firstInput.value = skillItem.skill;
              if (firstColorPicker) {
                firstColorPicker.className = `color-picker ${skillItem.color}`;
                firstColorPicker.dataset.color = skillItem.color;
                localStorage.setItem('color_skillSearch1', skillItem.color);
              }
              
              const firstSearch = skillSearches.find(s => s.id === 'skillSearch1');
              if (firstSearch) {
                firstSearch.value = skillItem.skill;
              }
            } else {
              const newId = `skillSearch${index + 1}`;
              
              skillSearches.push({ id: newId, value: skillItem.skill });
              
              createSearchBox(newId, skillItem.skill);
              
              const colorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
              if (colorPicker) {
                colorPicker.className = `color-picker ${skillItem.color}`;
                colorPicker.dataset.color = skillItem.color;
                localStorage.setItem(`color_${newId}`, skillItem.color);
              }
            }
          }
        });
        
        searchCounter = skillSearches.length + 1;
        SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
        
        saveSkillSearches();
        saveSlotsToLocalStorage();
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
        
        updateSelectedSkillsList();
        highlightSkills();
        highlightSelectedSkills();
        renderSections();
        updateEffectTotals();
        
        const pasteBtn = document.getElementById('pasteAllBtn');
        const originalText = pasteBtn.textContent;
        pasteBtn.textContent = 'Pasted!';
        pasteBtn.style.background = '#14a1f7';
        
        setTimeout(() => {
          pasteBtn.textContent = originalText;
          pasteBtn.style.background = '';
        }, 1500);
        
        console.log('All data pasted from clipboard:', allData);
        
        setTimeout(() => {
          const finalDeckNameInput = document.getElementById('deckNameInput');
          const finalDeckNameDisplay = document.getElementById('deckNameDisplay');
          console.log('Final deck name check - Input:', finalDeckNameInput.value, 'Display:', finalDeckNameDisplay.textContent, 'LocalStorage:', localStorage.getItem('deckName'));
        }, 200);
        
      }, 100);
      
    } catch (error) {
      console.error('Failed to parse all data: ', error);
      alert('Invalid format in clipboard! Use Copy All button first.');
    }
  }).catch(err => {
    console.error('Failed to read clipboard: ', err);
    alert('Failed to read from clipboard. Please check permissions.');
  });
}

/* ------------- RESET LEVELS ------------- */
function setupResetLevels() {
  const resetLevelsBtn = document.getElementById('resetLevelsBtn');
  resetLevelsBtn.addEventListener('click', resetAllLevels);
}

function resetAllLevels() {
  if (!confirm('Are you sure you want to reset ALL card levels to 1? This will refresh the display.')) {
    return;
  }
  
  console.log('Resetting ALL card levels to 1...');
  
  localStorage.removeItem('slotLevels');
  
  Object.keys(slotLevels).forEach(key => {
    delete slotLevels[key];
  });
  
  slotContainers.forEach(container => {
    const levelInput = container.querySelector('.slot-level-input');
    const slot = container.querySelector('.slot');
    
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        slotLevels[card.support_id] = 1;
        
        levelInput.value = '1';
        
        refreshCombinedLevelDisplay(slot, card, 1);
        
        updateUniqueEffectsDisplay(slot, card, 1);
        
        updateSlotNameWithEffectData(slot, card, 1);
        
        console.log(`Reset slot: ${card.char_name} to Lv 1`);
      }
    } else {
      levelInput.value = '1';
      levelInput.disabled = true;
    }
  });
  
  resetAllMainGridCards();
  
  localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
  
  setTimeout(updateEffectTotals, 100);
  
  setTimeout(() => {
    sectionPages.clear();
    renderSections();
    console.log('Sections re-rendered with reset levels');
  }, 200);
  
  const resetBtn = document.getElementById('resetLevelsBtn');
  const originalText = resetBtn.textContent;
  resetBtn.textContent = 'Reset!';
  
  setTimeout(() => {
    resetBtn.textContent = originalText;
  }, 1500);
  
  console.log('ALL card levels reset to 1');
}

function resetAllMainGridCards() {
  console.log('Resetting ALL main grid card levels...');
  
  const mainGridCards = document.querySelectorAll('.card');
  let updatedCount = 0;
  
  mainGridCards.forEach(cardElement => {
    const supportId = cardElement.dataset.supportId;
    if (supportId) {
      const card = cardsData.find(c => c.support_id == supportId);
      if (card) {
        refreshCombinedLevelDisplay(cardElement, card, 1);
        
        updateCardEffectDisplay(cardElement, supportId, 1);
        
        updatedCount++;
        console.log(`Reset main grid card: ${card.char_name} to Lv 1`);
      }
    }
  });
  
  console.log(`Updated ${updatedCount} main grid cards`);
  
  cardsData.forEach(card => {
    slotLevels[card.support_id] = 1;
  });
}

function refreshCombinedLevelDisplay(element, card, newLevel) {
  const container = element.querySelector('.level-diamond-container');
  if (container) {
    container.innerHTML = generateCombinedLevelDisplay(card, newLevel);
    console.log(`Refreshed level display for ${card.char_name}: Lv ${newLevel}`);
  } else {
    console.warn(`No level-diamond-container found for ${card.char_name}, creating one`);
    
    const newContainer = document.createElement('div');
    newContainer.className = 'level-diamond-container';
    newContainer.innerHTML = generateCombinedLevelDisplay(card, newLevel);
    
    const typeIcon = element.querySelector('.type-icon');
    if (typeIcon && typeIcon.nextElementSibling) {
      typeIcon.parentNode.insertBefore(newContainer, typeIcon.nextElementSibling);
    } else {
      element.insertBefore(newContainer, element.querySelector('img'));
    }
  }
}

/* ------------- CLEAR DECK WITH NAME RESET ------------- */
function setupClearDeckWithNameReset() {
  let isProgrammaticClear = false;
  
  clearAllBtn.addEventListener('click', () => {
    if (!isProgrammaticClear) {
      const deckNameInput = document.getElementById('deckNameInput');
      const deckNameDisplay = document.getElementById('deckNameDisplay');
      
      if (deckNameInput && deckNameDisplay) {
        deckNameInput.value = '';
        deckNameDisplay.textContent = 'Unnamed Deck';
        localStorage.removeItem('deckName');
        console.log('Manual clear: Deck name reset to default');
      }
    }
    
    selectedCardIds.clear();

    slotContainers.forEach(container => {
      const levelInput = container.querySelector('.slot-level-input');
      levelInput.disabled = true;
      levelInput.value = '1';
      levelInput.min = '1';
      levelInput.max = '50';

      const slot = container.querySelector('.slot');
      if (slotListeners.has(slot)) {
        slot.removeEventListener('click', slotListeners.get(slot));
        slotListeners.delete(slot);
      }
      slot.classList.remove('has-card');
      delete slot.dataset.cardId;
      delete slot.dataset.supportId;
      slot.innerHTML = '<div class="placeholder">Empty</div>';
    });

    localStorage.removeItem(SLOT_KEY);
    updateSelectedSkillsList();
    highlightSkills();
    highlightSelectedSkills();
    renderSections();

    setTimeout(() => {
      updateEffectTotals();
    }, 100);
    
    isProgrammaticClear = false;
  });
  
  window.programmaticClearDeck = function() {
    isProgrammaticClear = true;
    clearAllBtn.click();
  };
}

/* ------------- REFRESH ALL SLOT LEVEL DISPLAYS ------------- */
function refreshAllSlotLevelDisplays() {
  console.log('Refreshing all slot level displays...');
  
  slots.forEach((slot, index) => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        const currentLevel = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
        
        refreshCombinedLevelDisplay(slot, card, currentLevel);
        
        updateUniqueEffectsDisplay(slot, card, currentLevel);
        
        console.log(`Refreshed slot ${index}: ${card.char_name} Lv ${currentLevel}`);
      }
    }
  });
}

/* ------------- COMBINED LEVEL DISPLAY ------------- */
function generateCombinedLevelDisplay(card, currentLevel) {
  let thresholds;
  switch(card.rarity) {
    case 1:
      thresholds = [21, 26, 31, 36];
      break;
    case 2:
      thresholds = [26, 31, 36, 41];
      break;
    case 3:
      thresholds = [31, 36, 41, 46];
      break;
    default:
      thresholds = [21, 26, 31, 36];
  }
  
  let diamondIconsHTML = '';
  
  for (let i = 0; i < 4; i++) {
    const isFilled = currentLevel >= thresholds[i];
    const iconSrc = isFilled ? 'images/diamond_filled.png' : 'images/diamond_empty.png';
    
    diamondIconsHTML += `<img src="${iconSrc}" alt="Diamond ${i+1}" class="diamond-icon-combined" data-threshold="${thresholds[i]}">`;
  }
  
  return `
    <div class="level-badge-combined">Lv ${currentLevel}</div>
    <div class="diamond-icons-combined">${diamondIconsHTML}</div>
  `;
}

function refreshAllMainGridCardLevels() {
  console.log('Refreshing all main grid card levels...');
  
  const allCards = document.querySelectorAll('.card');
  allCards.forEach(cardElement => {
    const supportId = cardElement.dataset.supportId;
    if (supportId) {
      const currentLevel = getCardLevel(supportId);
      const card = cardsData.find(c => c.support_id == supportId);
      
      if (card) {
        refreshCombinedLevelDisplay(cardElement, card, currentLevel);
        updateCardEffectDisplay(cardElement, supportId, currentLevel);
      }
    }
  });
}

document.addEventListener('DOMContentLoaded', function() {
  const checkDataLoaded = setInterval(() => {
    if (cardsData && cardsData.length > 0) {
      clearInterval(checkDataLoaded);
      setTimeout(() => {
        setupEffectCalculation();
        updateEffectTotals();
        highlightSkills();
      }, 1000);
    }
  }, 100);
});
  
  const originalPasteDeck = window.pasteDeckFromClipboard;
  if (originalPasteDeck) {
    window.pasteDeckFromClipboard = function() {
      originalPasteDeck().then(() => {
        setTimeout(updateEffectTotals, 500);
      });
    };
  }
  document.addEventListener('DOMContentLoaded', setupCopyPasteButtons);


/* ------------- FUNCTION CHARACTER PICKER MODAL ------------- */
// Remove the currentRegion variable declaration and replace with this:
// Get region from your existing sidebar selector
function getCurrentRegion() {
    const regionSelect = document.getElementById('region');
    return regionSelect ? regionSelect.value : 'global';
}

// Update the region checking functions to use the current selector value:
function isCharacterAvailableInRegion(characterData) {
    const currentRegion = getCurrentRegion();
    if (currentRegion === 'global') {
        // For global, character must have a release_en date
        return characterData.release_en && characterData.release_en !== 'Unknown';
    } else {
        // For Japan, character must have a release date
        return characterData.release && characterData.release !== 'Unknown';
    }
}

// Update applyRegionFilter to use current region
function applyRegionFilter() {
    if (!characters || characters.length === 0) return;
    
    const currentRegion = getCurrentRegion();
    const filteredCharacters = characters.filter(character => 
        isCharacterAvailableInRegion(character.originalData)
    );
    
    // Apply current search and sort to filtered results
    const searchTerm = characterSearch ? characterSearch.value.toLowerCase() : '';
    const searchedCharacters = searchTerm ? 
        filteredCharacters.filter(character => 
            character.name.toLowerCase().includes(searchTerm) || 
            character.title.toLowerCase().includes(searchTerm)
        ) : 
        filteredCharacters;
    
    const sortedCharacters = sortCharacterList(searchedCharacters);
    populateCharacterGrid(sortedCharacters);
}

// Update handleRegionChange to be simpler
function handleRegionChange() {
    applyRegionFilter();
    
    // If we have a selected character, check if it should still be visible
    if (selectedCharacter && !isCharacterAvailableInRegion(selectedCharacter.originalData)) {
        // Deselect character if it's not available in current region
        selectedCharacter = null;
        updateCharacterDisplay();
    }
}

// Update the updateCharacterSkills function to dynamically manage boxes
function updateCharacterSkills(characterData) {
    const currentRegion = getCurrentRegion();
    
    // Determine which event skills to use based on region
    let eventSkillsToUse;
    if (currentRegion === 'global') {
        // For global, use skills_event_en if available, otherwise fall back to skills_event
        eventSkillsToUse = characterData.skills_event_en || characterData.skills_event || [];
    } else {
        // For Japan, always use skills_event
        eventSkillsToUse = characterData.skills_event || [];
    }
    
    // Update innate skills with dynamic box management
    updateSkillColumn('.character-skills-column:nth-child(1)', 'Innate Skills', characterData.skills_innate);
    
    // Update awakening skills with dynamic box management
    updateSkillColumn('.character-skills-column:nth-child(2)', 'Awakening Skills', characterData.skills_awakening);
    
    // Update event skills with dynamic box management
    updateSkillColumn('.character-skills-column:nth-child(3)', 'Event Skills', eventSkillsToUse);
}

// Update the updateSkillColumn function to remove the extra class
function updateSkillColumn(columnSelector, headerText, skillIds) {
    const column = document.querySelector(columnSelector);
    if (!column) return;
    
    // Clear existing content
    column.innerHTML = '';
    
    // Add header
    const header = document.createElement('div');
    header.className = 'character-skills-header';
    header.textContent = headerText;
    column.appendChild(header);
    
    // If no skills, hide the entire column
    if (!skillIds || skillIds.length === 0) {
        column.style.display = 'none';
        return;
    }
    
    // Show the column
    column.style.display = 'flex';
    
    // Create skill boxes based on the number of skills
    skillIds.forEach((skillId, index) => {
        const skillElement = document.createElement('div');
        skillElement.className = 'character-skill'; // Removed character-skill-text class
        
        const skillName = getSkillNameById(skillId);
        skillElement.textContent = skillName;
        
        column.appendChild(skillElement);
    });
    
    // Add empty boxes if we have fewer than 3 skills (for consistent layout)
    const currentSkillCount = skillIds.length;
    if (currentSkillCount < 3) {
        const emptySlotsNeeded = 3 - currentSkillCount;
        for (let i = 0; i < emptySlotsNeeded; i++) {
            const emptySkill = document.createElement('div');
            emptySkill.className = 'character-skill';
            emptySkill.style.visibility = 'hidden';
            column.appendChild(emptySkill);
        }
    }
}

// Update the resetCharacterSkills function
function resetCharacterSkills() {
    const columns = document.querySelectorAll('.character-skills-column');
    
    columns.forEach((column, index) => {
        // Clear existing content
        column.innerHTML = '';
        
        const skillTypes = ['Innate Skills', 'Awakening Skills', 'Event Skills'];
        
        // Add header
        const header = document.createElement('div');
        header.className = 'character-skills-header';
        header.textContent = skillTypes[index];
        column.appendChild(header);
        
        // Add 3 empty placeholder boxes
        for (let i = 0; i < 3; i++) {
            const skillElement = document.createElement('div');
            skillElement.className = 'character-skill'; // Removed character-skill-text class
            skillElement.textContent = `${skillTypes[index].replace(' Skills', '')} Skill ${i + 1}`;
            column.appendChild(skillElement);
        }
        
        // Show the column
        column.style.display = 'flex';
    });
}

function getSkillNameById(skillId) {
    if (!skillsData || skillsData.length === 0) {
        console.warn('Skills data not loaded yet for skill ID:', skillId);
        return `Skill ${skillId}`;
    }
    
    const skill = skillsData.find(s => s.id === skillId);
    if (skill) {
        // Use region to determine which name to show
        const currentRegion = getCurrentRegion();
        let skillName;
        if (currentRegion === 'global') {
            skillName = skill.name_en || skill.jpname || `Skill ${skillId}`;
        } else {
            skillName = skill.jpname || skill.name_en || `Skill ${skillId}`;
        }
        
        // Remove symbols like â—‹, â—Ž, etc.
        return skillName.replace(/[â—Žâ—‹â—â—†â– â–²â–¼â˜…â˜†â–ªâ–«â—¼â—»â—¾â—½]/g, '').trim();
    }
    
    console.warn('Skill not found for ID:', skillId);
    return `Skill ${skillId}`;
}


// Update the initCharacterPicker to wait for skills data if needed
function initCharacterPicker() {
    // Wait a bit for skills data to load if it's not ready yet
    if (!skillsData || skillsData.length === 0) {
        console.log('Skills data not ready, waiting...');
        setTimeout(initCharacterPicker, 500);
        return;
    }
    
    // Load character data
    loadCharacterData();
    
    // Add click event to empty box
    characterPickerBox.addEventListener('click', openCharacterPicker);
    
    // Add close event to modal
    characterPickerClose.addEventListener('click', closeCharacterPicker);
    
    // Add search functionality
    characterSearch.addEventListener('input', filterCharacters);
    
    // Add sort functionality
    characterSort.addEventListener('change', sortCharacters);
    characterSortOrder.addEventListener('click', toggleSortOrder);
    
    // Add region change listener - get the region select from left sidebar
    const regionSelect = document.getElementById('region');
    if (regionSelect) {
        // Remove any existing listener to avoid duplicates
        regionSelect.removeEventListener('change', handleRegionChange);
        regionSelect.addEventListener('change', handleRegionChange);
    }
    
    // Close modal when clicking outside
    characterPickerModal.addEventListener('click', (e) => {
        if (e.target === characterPickerModal) {
            closeCharacterPicker();
        }
    });
    
    console.log('Character picker initialized with skills data');
}


// Open character picker modal
function openCharacterPicker() {
    characterPickerModal.classList.add('active');
    // Focus on search input when modal opens
    setTimeout(() => {
        characterSearch.focus();
    }, 100);
}

// Close character picker modal
function closeCharacterPicker() {
    characterPickerModal.classList.remove('active');
}

// Populate character grid with character cards
function populateCharacterGrid(charactersToShow) {
    characterGrid.innerHTML = '';
    
    if (charactersToShow.length === 0) {
        characterGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;">No characters found</div>';
        return;
    }
    
    charactersToShow.forEach(character => {
        const characterCard = document.createElement('div');
        characterCard.className = 'character-card';
        characterCard.innerHTML = `
            <img src="${character.portrait}" alt="${character.name}" class="character-portrait" onerror="this.src='https://via.placeholder.com/100x100?text=No+Image'">
            <div class="character-name">${character.name}</div>
            <div class="character-rarity">${character.rarity}</div>
            <div class="character-title">${character.title}</div>
        `;
        
        characterCard.addEventListener('click', () => selectCharacter(character));
        characterGrid.appendChild(characterCard);
    });
}

// Select a character
function selectCharacter(character) {
    selectedCharacter = character;
    updateCharacterDisplay();
    closeCharacterPicker();
}

// Update the character display in the right sidebar
function updateCharacterDisplay() {
    if (selectedCharacter) {
        // Update the empty box to show selected character
        characterPickerBox.classList.add('has-character');
        characterPickerBox.innerHTML = `
            <img src="${selectedCharacter.portrait}" alt="${selectedCharacter.name}" class="selected-character-portrait" onerror="this.src='https://via.placeholder.com/100x100?text=No+Image'">
            <div class="selected-character-info">
                <div class="selected-character-name">${selectedCharacter.name}</div>
                <div class="selected-character-title">${selectedCharacter.title}</div>
            </div>
        `;
        
        // Update character info
        characterPickerName.textContent = selectedCharacter.name;
        characterPickerCostume.textContent = selectedCharacter.title;
        
        // Update aptitude percentages (using stat_bonus from your JSON)
        const percentages = document.querySelectorAll('.character-picker-percentage');
        if (selectedCharacter.stat_bonus && selectedCharacter.stat_bonus.length >= 5) {
            percentages.forEach((percentage, index) => {
                if (index < 5) {
                    percentage.textContent = `${selectedCharacter.stat_bonus[index]}%`;
                }
            });
        }
        
        // Update aptitude grades - CORRECTED ORDER
        const grades = document.querySelectorAll('.character-picker-grade');
        if (selectedCharacter.aptitude && selectedCharacter.aptitude.length >= 10) {
            // CORRECTED APTITUDE ORDER:
            // [0] Turf, [1] Dirt, [2] Sprint, [3] Mile, [4] Middle, [5] Long, 
            // [6] Runner, [7] Leader, [8] Betweener, [9] Chaser
            grades.forEach((grade, index) => {
                if (index < 10) {
                    grade.textContent = selectedCharacter.aptitude[index];
                }
            });
        }
        
        // Update character skills if you have that data
        updateCharacterSkills(selectedCharacter.originalData);
    } else {
        // Reset to empty state
        characterPickerBox.classList.remove('has-character');
        characterPickerBox.innerHTML = '<div class="character-picker-empty-text">Empty</div>';
        characterPickerName.textContent = 'Character Name';
        characterPickerCostume.textContent = 'Character Costume';
        
        // Reset percentages and grades
        document.querySelectorAll('.character-picker-percentage').forEach(p => p.textContent = '20%');
        document.querySelectorAll('.character-picker-grade').forEach(g => g.textContent = 'A');
        
        // Reset skills
        resetCharacterSkills();
    }
}

// Filter characters based on search input
function filterCharacters() {
    const searchTerm = characterSearch.value.toLowerCase();
    const filteredCharacters = characters.filter(character => 
        character.name.toLowerCase().includes(searchTerm) || 
        character.title.toLowerCase().includes(searchTerm)
    );
    
    // Apply current sort to filtered results
    const sortedCharacters = sortCharacterList(filteredCharacters);
    populateCharacterGrid(sortedCharacters);
}

// Sort characters based on selected criteria
function sortCharacters() {
    const sortedCharacters = sortCharacterList(characters);
    populateCharacterGrid(sortedCharacters);
}

// Toggle sort order
function toggleSortOrder() {
    isAscending = !isAscending;
    characterSortOrder.textContent = isAscending ? 'â†‘' : 'â†“';
    characterSortOrder.classList.toggle('ascending', isAscending);
    
    const sortedCharacters = sortCharacterList(characters);
    populateCharacterGrid(sortedCharacters);
}

// Helper function to sort character list
function sortCharacterList(characterList) {
    const sortBy = characterSort.value;
    const order = isAscending ? 1 : -1;
    
    return [...characterList].sort((a, b) => {
        let aValue, bValue;
        
        switch(sortBy) {
            case 'name':
                aValue = a.name;
                bValue = b.name;
                break;
            case 'rarity':
                // Convert rarity to numerical value for proper sorting
                const rarityValues = { 'SSR': 3, 'SR': 2, 'R': 1, 'Unknown': 0 };
                aValue = rarityValues[a.rarity] || 0;
                bValue = rarityValues[b.rarity] || 0;
                break;
            case 'implemented':
                aValue = new Date(a.implemented);
                bValue = new Date(b.implemented);
                break;
            case 'id':
                aValue = a.card_id;
                bValue = b.card_id;
                break;
            // Aptitude sorting
            case 'turf':
                aValue = getAptitudeValue(a.aptitude[0]);
                bValue = getAptitudeValue(b.aptitude[0]);
                break;
            case 'dirt':
                aValue = getAptitudeValue(a.aptitude[1]);
                bValue = getAptitudeValue(b.aptitude[1]);
                break;
            case 'sprint':
                aValue = getAptitudeValue(a.aptitude[2]);
                bValue = getAptitudeValue(b.aptitude[2]);
                break;
            case 'mile':
                aValue = getAptitudeValue(a.aptitude[3]);
                bValue = getAptitudeValue(b.aptitude[3]);
                break;
            case 'middle':
                aValue = getAptitudeValue(a.aptitude[4]);
                bValue = getAptitudeValue(b.aptitude[4]);
                break;
            case 'long':
                aValue = getAptitudeValue(a.aptitude[5]);
                bValue = getAptitudeValue(b.aptitude[5]);
                break;
            case 'runner':
                aValue = getAptitudeValue(a.aptitude[6]);
                bValue = getAptitudeValue(b.aptitude[6]);
                break;
            case 'leader':
                aValue = getAptitudeValue(a.aptitude[7]);
                bValue = getAptitudeValue(b.aptitude[7]);
                break;
            case 'betweener':
                aValue = getAptitudeValue(a.aptitude[8]);
                bValue = getAptitudeValue(b.aptitude[8]);
                break;
            case 'chaser':
                aValue = getAptitudeValue(a.aptitude[9]);
                bValue = getAptitudeValue(b.aptitude[9]);
                break;
            // Stat bonus sorting
            case 'bonus_speed':
                aValue = a.stat_bonus[0];
                bValue = b.stat_bonus[0];
                break;
            case 'bonus_stamina':
                aValue = a.stat_bonus[1];
                bValue = b.stat_bonus[1];
                break;
            case 'bonus_power':
                aValue = a.stat_bonus[2];
                bValue = b.stat_bonus[2];
                break;
            case 'bonus_guts':
                aValue = a.stat_bonus[3];
                bValue = b.stat_bonus[3];
                break;
            case 'bonus_int':
                aValue = a.stat_bonus[4];
                bValue = b.stat_bonus[4];
                break;
            default:
                aValue = a.name;
                bValue = b.name;
        }
        
        if (aValue < bValue) return -1 * order;
        if (aValue > bValue) return 1 * order;
        return 0;
    });
}

// Helper function to convert aptitude letter to numerical value for sorting
function getAptitudeValue(aptitude) {
    const values = { 'S': 5, 'A': 4, 'B': 3, 'C': 2, 'D': 1, 'E': 0, 'F': -1, 'G': -2 };
    return values[aptitude] || -3;
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initCharacterPicker);

</script>
</body>
</html>