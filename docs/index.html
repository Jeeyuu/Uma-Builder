<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Uma Builder — Card Picker</title>
<style>
:root {
  --card-w: 120px;
  --gap: 8px;
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

body {
  font-family: Arial, Helvetica, sans-serif;
  background: #fff;
  color: #111;
}

/* --------- HEADER STYLES --------- */
.header {
  height: 70px;
  background: #fff;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 30px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header-left {
  display: flex;
  align-items: center;
}

.header-logo {
  height: 40px;
  width: auto;
}

.header-title {
  margin-left: 12px;
  font-size: 18px;
  font-weight: bold;
  color: #333;
}

.header-nav {
  display: none;
}

/* ---------- CONTAINER & SIDEBARS ---------- */
.container {
  display: flex;
  width: 100%;
  height: calc(100vh - 70px);
  overflow: hidden;
}

.sidebar {
  flex-shrink: 0;
  width: 200px;
  padding: 16px 12px;
  box-sizing: border-box;
  background: #f9f9f9;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.right-sidebar {
  flex-shrink: 0;
  /* Remove fixed width and let it size based on content */
  padding: 16px 12px;
  box-sizing: border-box;
  background: #f5f5f5;
  overflow-y: auto;
  border-left: 1px solid #ddd;
  display: flex;
  flex-direction: column;
  align-items: center;
  /* Add min-width to prevent it from getting too small */
  min-width: fit-content;
}

.sidebar > *:not(:last-child),
.right-sidebar > *:not(:last-child) {
  margin-bottom: 12px;
}

/* Hide scrollbars for both sidebars */
.sidebar::-webkit-scrollbar,
.right-sidebar::-webkit-scrollbar {
  display: none;
}

.sidebar, .right-sidebar {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.right-sidebar .slots-header {
  margin-top: 0;
  margin-bottom: 0;
}

/* ---------- MAIN CONTENT ---------- */
.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  overflow-y: auto;
  padding: 16px;
  box-sizing: border-box;
  width: 100%; /* Take all available space between sidebars */
}

.main-content::-webkit-scrollbar {
  display: none;
}

.main-content {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.content-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  width: 100%;
  max-width: 100%; /* Remove fixed width constraint */
  margin: 0 auto;
}

/* ---------- SIDEBAR FILTERS ---------- */
.sidebar .filter-group {
  display: flex;
  flex-direction: column;
}

/* Regular filter labels */
.sidebar .filter-group > label:not(.checkbox-label) {
    margin-bottom: 4px;
    font-weight: 600;
    font-size: 13px;
}

.sidebar select, .sidebar .skill-search {
  width: 100%;
  padding: 6px 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

/* ---------- TOGGLE BUTTONS ---------- */
.toggle-button-group {
  display: flex;
  flex-direction: column;
}

.toggle-button-group label {
  margin-bottom: 4px;
  font-weight: 600;
  font-size: 13px;
}

.toggle-buttons-row {
  display: flex;
  justify-content: flex-start;
}

.toggle-button {
  background: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border: none;
}

.toggle-button:hover {
  background: #f0f0f0;
}

.toggle-button.active {
  background: none;
}

/* Rarity buttons */
.rarity-buttons .toggle-buttons-row {
  width: 100%;
  gap: 2px;
}

.rarity-buttons .toggle-button {
  flex: 1;
  aspect-ratio: 53 / 22;
  border-radius: 0;
  border-right: none;
  background: none;
}

.rarity-buttons .toggle-button img,
.type-buttons .toggle-button img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  filter: grayscale(100%) opacity(0.6);
  transition: filter 0.2s ease;
}

.rarity-buttons .toggle-button.active img,
.type-buttons .toggle-button.active img {
  filter: grayscale(0%) opacity(1);
}

.rarity-buttons .toggle-button:hover {
  background: #f0f0f0;
}

.rarity-buttons .toggle-button:hover img,
.type-buttons .toggle-button:hover img {
  filter: grayscale(100%) opacity(0.8);
}

/* Type buttons */
.type-buttons .toggle-buttons-row {
  width: 100%;
  gap: 1px;
  flex-wrap: wrap;
}

.type-buttons .toggle-button {
  flex: 1;
  border: none;
  border-radius: 0;
  aspect-ratio: 1;
  min-width: 0;
}

.toggle-button img {
  display: block;
  max-width: 100%;
  max-height: 100%;
}

/* ---------- BUTTONS ---------- */
.clear-all, #clearFiltersBtn, #togglePresetCardsBtn {
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  width: 100%;
}

.clear-all:hover, #clearFiltersBtn:hover, #togglePresetCardsBtn:hover {
  background: #333;
}

.slots-header .clear-all {
  width: 100%; /* Make it fill the available width */
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2); /* But don't exceed slot grid width */
  margin-bottom: 12px;
  padding: 8px 12px;
  height: auto;
}

/* ---------- SKILL SEARCH ---------- */
#skillSearchGroup {
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}

#skillSearchGroup label {
  margin-bottom: 0px;
  font-weight: 600;
  font-size: 13px;
}

.skill-search-divider {
  min-height: 1px;
  background: #333;
  margin: 0px 0;
  width: 100%;
}

.skill-search-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0px;
}

.add-search-btn {
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  width: 48px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

.add-search-btn:hover {
  background: #333;
}

.search-input-container {
  display: flex;
  align-items: center;
  gap: 4px;
  width: 100%;
}

.search-input-container input {
  flex: 1;
  padding: 6px 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

.remove-search-btn {
  width: 24px;
  height: 24px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #f5f5f5;
  color: #666;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  flex-shrink: 0;
}

.remove-search-btn:hover {
  background: #e5e5e5;
  color: #333;
}

/* ---------- SLOTS & CARDS ---------- */
.slots {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(2, 1fr);
  gap: var(--gap);
  /* Remove fixed width calculation, let it size naturally */
  width: 100%;
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2);
  margin: 0 auto;
}

.slot {
  border: 1px solid #ddd;
  padding: 8px;
  box-sizing: border-box;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  width: var(--card-w);
  min-height: var(--card-w);
  position: relative;
  transition: min-height 0.3s ease;
}

.slot:not(.has-card) {
  border: 2px dashed #ccc;
  background: #fafafa;
  aspect-ratio: 1;
  min-height: var(--card-w);
  height: var(--card-w);
}

.slot.has-card {
  min-height: calc(var(--card-w) * 2.2);
  aspect-ratio: auto;
  height: auto;
  max-height: none;
}

.slot .placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ccc;
  font-size: 11px;
}

/* Responsive cards grid */
.cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--card-w), 1fr));
  gap: var(--gap);
  width: 100%;
  justify-content: center;
}

.card, .slot.has-card {
  border: 1px solid #ddd;
  padding: 6px;
  box-sizing: border-box;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: var(--card-w);
  position: relative;
  min-height: 0;
  height: auto;
  justify-self: center; /* Center cards in their grid cells */
}
.card .name, .slot.has-card .name {
  margin: 6px 0 4px 0;
  font-weight: 700;
  text-align: center;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card img, .slot.has-card img {
  max-width: calc(var(--card-w) * 0.8);
  max-height: calc(var(--card-w) * 0.8);
  object-fit: contain;
}

.card .skills, .slot.has-card .skills,
.card .skills-group, .slot.has-card .skills-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 100%;
  align-items: center;
}

.card .skill, .slot.has-card .skill {
  width: 100%;
  background: #eef2ff;
  border-radius: 4px;
  padding: 2px 4px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
}

/* Add this to ensure skills containers collapse properly */
.card .skills, .slot.has-card .skills {
  min-height: 0;
  width: 100%;
}

/* Ensure skills groups collapse when empty */
.skills-group {
  min-height: 0;
}

/* Make sure empty skills containers don't take up space */
.skills:empty {
  display: none;
}

/* Add this to handle the case where all skills in a group are hidden */
.skills-group:has(.skill.hidden-skill:only-child),
.skills-group:has(.skill.hidden-skill:first-child + .skill.hidden-skill:last-child) {
  display: none;
}

/* TYPE ICON */
.card .type-icon, .slot.has-card .type-icon {
  position: absolute;
  top: 0px;
  right: 0px;
  width: 32px;
  height: 32px;
  border: 1px solid #ccc;
  background: #fff;
  border-radius: 3px;
  overflow: hidden;
  text-align: center;
  font-size: 8px;
  line-height: 14px;
  font-weight: bold;
}

.card .type-icon img, .slot.has-card .type-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

/* ---------- SKILLS & HIGHLIGHTING ---------- */
.skill.search-highlighted {
  background: #ff4444; /* REMOVED !important */
  color: white; /* REMOVED !important */
}

.skills-header {
  font-size: 9px;
  font-weight: bold;
  margin-bottom: 0px;
  text-align: center;
  background: #000000;
  color: #ffffff;
  padding: 3px 4px;
  border-radius: 0;
  width: 100%;
}

/* ---------- PAGINATION & SECTIONS ---------- */
.card-section {
  position: relative;
  width: 100%;
}

.card-section-header {
  position: relative;
  display: block;
  margin-top: 0px;
  margin-bottom: 10px;
  width: 100%;
}

.card-section-header h2 {
  margin: 0;
}

.page-controls {
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  gap: 8px;
}

.page-controls button {
  border: none;
  background: #444;
  color: #fff;
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 12px;
  font-weight: bold;
  cursor: pointer;
  min-width: 32px;
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
  line-height: 1;
}

.page-controls button:hover:not(:disabled) {
  background: #333;
}

.page-controls button:disabled {
  background: #999;
  color: #ccc;
  cursor: not-allowed;
}

.card.disabled {
  opacity: 0.45;
}

.card-sections {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  gap: 10px;
}

/* ---------- SORT ORDER & CHECKBOX ---------- */
.sort-order-btn {
  border: 1px solid #ccc;
  background: #f5f5f5;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

.sort-order-btn:hover {
  background: #e5e5e5;
  border-color: #999;
}

.sort-order-btn.ascending {
  background: #444;
  color: #fff;
  border-color: #444;
}

/* Checkbox labels */
.checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    font-size: 13px;
    cursor: pointer;
    margin-bottom: -4px;
}

.checkbox-label input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
}

/* ---------- SKILL HIDING ---------- */
.skill.hidden-skill,
.skills-header.hidden-skill {
  display: none;
}

/* Fix for skills groups - remove them from layout completely when hidden */
.skills-group.hidden-skill {
  display: none !important;
}

/* Remove the old gap adjustment rules since we're using display: none */
/* .skills-group:not(.hidden-skill) + .skills-group:not(.hidden-skill) {
  margin-top: 8px;
} */

/* Handle empty skills containers */
.skills:empty,
.skills:has(.skills-group.hidden-skill:only-child),
.skills:has(.skills-group.hidden-skill:first-child + .skills-group.hidden-skill:last-child) {
  display: none;
}

/* Remove margin from the first visible skills group */
.skills-group:not(.hidden-skill):first-child {
  margin-top: 0;
}

/* Add consistent gap between visible skills groups */
.skills-group:not(.hidden-skill) + .skills-group:not(.hidden-skill) {
  margin-top: 8px;
}

/* ---------- PRESET CARDS TOGGLE ---------- */
.sidebar-filters-section {
  transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar-filters-section.hidden {
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  pointer-events: none;
  margin-bottom: 0 !important;
  gap: 0;
}

.filter-group, .toggle-button-group {
  transition: opacity 0.3s ease;
}

/* ---------- COLOR PICKER ---------- */
.color-picker {
  width: 20px;
  height: 20px;
  border: 2px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  flex-shrink: 0;
  background: #ff4444; /* Default red */
  transition: all 0.2s ease;
}

.color-picker:hover {
  border-color: #999;
  transform: scale(1.1);
}

.color-picker.yellow { background: #cc9900; }
.color-picker.green { background: #008800; }
.color-picker.blue { background: #0044cc; }
.color-picker.red { background: #cc0000; }

/* ---------- SELECTED SKILLS LIST ---------- */
.selected-skills-section {
  width: 100%;
  margin-top: 16px;
}

.skills-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding: 0 4px;
}

.skills-list-header h3 {
  margin: 0;
  font-size: 14px;
  font-weight: bold;
  color: #333;
}

.skills-count {
  font-size: 12px;
  color: #666;
  font-weight: normal;
}

.skills-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 400px;
  overflow-y: auto;
  padding-right: 4px;
}

.skills-list::-webkit-scrollbar {
  width: 4px;
}

.skills-list::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 2px;
}

.skills-list::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 2px;
}

.skills-list::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

.skill-item {
  background: #eef2ff;
  border-radius: 4px;
  padding: 6px 8px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
  transition: all 0.2s ease;
  border: 1px solid #ddd;
}

.skill-item.highlighted {
  background: #ffae77;
  color: #000;
}

.skill-item.search-highlighted {
  color: white;
}

.skill-item.hidden-skill {
  display: none;
}

</style>
</head>

<body>
<!-- Header -->
<div class="header">
  <div class="header-left">
    <img src="your-logo.png" alt="Logo" class="header-logo">
    <div class="header-title">Uma Builder</div>
  </div>
  <div class="header-nav">
    <!-- Navigation links are hidden -->
  </div>
</div>

<div class="container">

<!-- Left Sidebar (Filters) -->
<div class="sidebar">

  <!-- Card Name Search -->
  <div class="filter-group">
    <label for="cardSearch">Search Card</label>
    <input type="text" id="cardSearch" class="skill-search" placeholder="Search card name">
  </div>

  <!-- Rarity Toggle Buttons -->
  <div class="toggle-button-group rarity-buttons">
    <label>Rarity</label>
    <div class="toggle-buttons-row">
      <button class="toggle-button" data-rarity="SSR">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_03.png" alt="SSR">
      </button>
      <button class="toggle-button" data-rarity="SR">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_02.png" alt="SR">
      </button>
      <button class="toggle-button" data-rarity="R">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_01.png" alt="R">
      </button>
    </div>
  </div>

  <!-- Type Toggle Buttons -->
  <div class="toggle-button-group type-buttons">
    <label>Type</label>
    <div class="toggle-buttons-row">
      <button class="toggle-button" data-type="speed">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_00.png" alt="Speed">
      </button>
      <button class="toggle-button" data-type="stamina">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_01.png" alt="Stamina">
      </button>
      <button class="toggle-button" data-type="power">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_02.png" alt="Power">
      </button>
      <button class="toggle-button" data-type="guts">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_03.png" alt="Guts">
      </button>
      <button class="toggle-button" data-type="intelligence">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_04.png" alt="Intelligence">
      </button>
<button class="toggle-button" data-type="friend">
  <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_05.png" alt="Friend">
</button>
      <button class="toggle-button" data-type="group">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_06.png" alt="Group">
      </button>
    </div>
  </div>

  
  <!-- ADD SORTING CONTROLS HERE -->
  <div class="filter-group">
    <label for="sortBy">Sort By</label>
    <div style="display: flex; gap: 6px; align-items: center;">
      <select id="sortBy" style="flex: 1;">
        <option value="rarity">Rarity</option>
        <option value="name">Name</option>
        <option value="type">Type</option>
        <option value="release">Release Date</option>
        <option value="support_id">Game ID Number</option>
      </select>
      <button id="sortOrder" class="sort-order-btn ascending" style="width: 32px; height: 32px; border: 1px solid #ccc; background: #444; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; border-radius: 4px; flex-shrink: 0;">
        ↑
      </button>
    </div>
  </div>

  <div class="filter-group">
    <label for="region">Region</label>
    <select id="region">
      <option value="global">Global</option>
      <option value="japan">Japan</option>
    </select>
  </div>

  <!-- ADD THIS CHECKBOX -->
  <div class="filter-group">
    <label class="checkbox-label">
      <input type="checkbox" id="hideUncolored">
      Hide Uncoloured Skills
    </label>
  </div>

  <!-- ADD THIS DIVIDER -->
  <div class="skill-search-divider"></div>

  <!-- Toggle Preset Cards Button -->
  <button id="togglePresetCardsBtn" class="clear-all">Hide Preset Cards</button>

  <!-- Wrap Clear Filters Button inside the hidden section so it gets hidden too -->
  <div class="sidebar-filters-section" id="sidebarFiltersSection">
    <!-- Clear Filters Button at top -->
    <button id="clearFiltersBtn" class="clear-all clear-filters-top">Clear Filters</button>

    <div class="filter-group">
      <label for="presets">Presets</label>
      <select id="presets">
        <option value="">-- Select --</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="racecourse">Racecourse</label>
      <select id="racecourse">
        <option value="">-- Select --</option>
        <option value="Sapporo">Sapporo</option>
        <option value="Hakodate">Hakodate</option>
        <option value="Niigata">Niigata</option>
        <option value="Fukushima">Fukushima</option>
        <option value="Nakayama">Nakayama</option>
        <option value="Tokyo">Tokyo</option>
        <option value="Chukyo">Chukyo</option>
        <option value="Kyoto">Kyoto</option>
        <option value="Hanshin">Hanshin</option>
        <option value="Kokura">Kokura</option>
        <option value="Oi">Oi</option>
        <option value="Kawasaki">Kawasaki</option>
        <option value="Funabashi">Funabashi</option>
        <option value="Morioka">Morioka</option>
        <option value="Longchamp">Longchamp</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="length">Length</label>
      <select id="length">
        <option value="">-- Select --</option>
        <option value="1000">1000m</option>
        <option value="1150">1150m</option>
        <option value="1200">1200m</option>
        <option value="1300">1300m</option>
        <option value="1400">1400m</option>
        <option value="1500">1500m</option>
        <option value="1600">1600m</option>
        <option value="1700">1700m</option>
        <option value="1800">1800m</option>
        <option value="1900">1900m</option>
        <option value="2000">2000m</option>
        <option value="2100">2100m</option>
        <option value="2200">2200m</option>
        <option value="2300">2300m</option>
        <option value="2400">2400m</option>
        <option value="2500">2500m</option>
        <option value="2600">2600m</option>
        <option value="3000">3000m</option>
        <option value="3200">3200m</option>
        <option value="3400">3400m</option>
        <option value="3600">3600m</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="direction">Direction</label>
      <select id="direction">
        <option value="">-- Select --</option>
        <option value="Clockwise">Clockwise</option>
        <option value="Counterclockwise">Counterclockwise</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="track">Track Conditions</label>
      <select id="track">
        <option value="">-- Select --</option>
        <option value="Firm">Firm</option>
        <option value="Good">Good</option>
        <option value="Soft">Soft</option>
        <option value="Heavy">Heavy</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="season">Season</label>
      <select id="season">
        <option value="">-- Select --</option>
        <option value="Spring">Spring</option>
        <option value="Summer">Summer</option>
        <option value="Fall">Autumn</option>
        <option value="Winter">Winter</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="weather">Weather</label>
      <select id="weather">
        <option value="">-- Select --</option>
        <option value="Sunny">Sunny</option>
        <option value="Cloudy">Cloudy</option>
        <option value="Rainy">Rain</option>
        <option value="Snowy">Snow</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="strategy">Strategy</label>
      <select id="strategy">
        <option value="">-- Select --</option>
        <option value="Front Runner">Front Runner</option>
        <option value="Pace Chaser">Pace Chaser</option>
        <option value="Late Surger">Late Surger</option>
        <option value="End Closer">End Closer</option>
      </select>
    </div>
  </div> <!-- End of sidebar-filters-section -->

  <!-- Thin divider -->
  <div class="skill-search-divider"></div>

  <!-- Skill Search Section -->
  <div id="skillSearchGroup">
    <div class="skill-search-header">
      <label for="skillSearch1">Skill Search</label>
      <button class="add-search-btn" id="addSearchBtn">Add</button>
    </div>
    
    <!-- Default search box -->
    <div class="search-input-container">
    <div class="color-picker red" data-search-id="skillSearch1" data-color="red"></div>
      <input type="text" id="skillSearch1" class="skill-search" placeholder="Search skill">
      <button class="remove-search-btn" data-search-id="skillSearch1">×</button>
    </div>
    
    <!-- Additional search boxes will be added here dynamically -->
  </div>
</div>

<!-- Main Content -->
  <div class="main-content">
    <div class="content-wrapper">
      <div id="cardSections" class="card-sections"></div>
    </div>
  </div>

<!-- Right Sidebar (Slots) -->
<div class="right-sidebar">
  <div class="slots-header">
    <button class="clear-all" id="clearAllBtn">Clear All</button>
  </div>

  <div class="slots" id="slots">
    <div class="slot" data-slot="0"><div class="placeholder">Empty</div></div>
    <div class="slot" data-slot="1"><div class="placeholder">Empty</div></div>
    <div class="slot" data-slot="2"><div class="placeholder">Empty</div></div>
    <div class="slot" data-slot="3"><div class="placeholder">Empty</div></div>
    <div class="slot" data-slot="4"><div class="placeholder">Empty</div></div>
    <div class="slot" data-slot="5"><div class="placeholder">Empty</div></div>
  </div>

  <!-- ADD THIS DIVIDER -->
  <div class="skill-search-divider"></div>

  <!-- ADD THIS NEW SKILLS LIST SECTION -->
  <div class="selected-skills-section">
    <div class="skills-list-header">
      <h3>Selected Card Skills</h3>
      <span class="skills-count">(<span id="skillsCount">0</span> unique skills)</span>
    </div>
    <div class="skills-list" id="selectedSkillsList">
      <!-- Skills will be populated here dynamically -->
    </div>
  </div>
</div>
  
  </div>

</div>

<script>
/* ------------- CONFIG ------------- */
const JSON_FILE = "transformed_supports.json";
const HIDE = { char_id: false, url_name: true };

/* ------------- STATE ------------- */
let cardsData = [];
const cardSections = document.getElementById('cardSections');
const slots = Array.from(document.querySelectorAll('.right-sidebar .slot'));
const clearAllBtn = document.getElementById('clearAllBtn');
const clearFiltersBtn = document.getElementById('clearFiltersBtn');
const selectedCardIds = new Set();
const sectionPages = new Map();
const slotListeners = new Map();
const SLOT_KEY = 'saved_slots';
const FILTER_KEYS = ['racecourse','length','direction','track','season','weather','strategy'];
let SKILL_SEARCH_KEYS = []; // This will be populated from localStorage
let showPresetCards = true; // Start with preset cards visible

/* ------------- CARD SEARCH STATE ------------- */
let cardSearchValue = '';

/* ------------- SKILL SEARCH STATE ------------- */
let skillSearches = JSON.parse(localStorage.getItem('skillSearches')) || [{ id: 'skillSearch1', value: '' }];
let searchCounter = skillSearches.length + 1;

/* ------------- TOGGLE BUTTON STATE ------------- */
const selectedRarities = new Set();
const selectedTypes = new Set();

/* ------------- NEW STATE VARIABLES ------------- */
let hideUncolored = false;
let sortBy = 'rarity';
let sortOrder = 'descending'; // CHANGED TO DESCENDING
let region = 'global';

/* ------------- SORTING FUNCTION ------------- */
function sortCards(cards, sortBy, order) {
  const sortedCards = [...cards];
  
  sortedCards.sort((a, b) => {
    let aValue, bValue;
    
    switch (sortBy) {
      case 'rarity':
        if (a.rarity !== b.rarity) {
          return order === 'ascending' ? a.rarity - b.rarity : b.rarity - a.rarity;
        }
        // If same rarity, sort by appropriate release date
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'name':
        aValue = a.char_name.toLowerCase();
        bValue = b.char_name.toLowerCase();
        
        // First, compare by name based on the sort order
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        // If names are exactly the same, ALWAYS sort by rarity descending (SSR first)
        return b.rarity - a.rarity; // SSR > SR > R always
        
      case 'type':
        aValue = a.type;
        bValue = b.type;
        
        // First, compare by type based on the sort order
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        // If types are exactly the same, ALWAYS sort by rarity descending (SSR first)
        return b.rarity - a.rarity; // SSR > SR > R always
        
      case 'release':
        // Use appropriate release date based on region
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'support_id':
        aValue = a.support_id;
        bValue = b.support_id;
        break;
        
      default:
        return 0;
    }
    
    // Handle empty values
    if (!aValue && bValue) return order === 'ascending' ? -1 : 1;
    if (aValue && !bValue) return order === 'ascending' ? 1 : -1;
    if (!aValue && !bValue) return 0;
    
    // For dates, convert to timestamps for proper comparison
    if (sortBy === 'release' || (sortBy === 'rarity' && a.rarity === b.rarity)) {
      try {
        const aDate = new Date(aValue);
        const bDate = new Date(bValue);
        if (isNaN(aDate.getTime()) && !isNaN(bDate.getTime())) return order === 'ascending' ? -1 : 1;
        if (!isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return order === 'ascending' ? 1 : -1;
        if (isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return 0;
        
        aValue = aDate.getTime();
        bValue = bDate.getTime();
      } catch (e) {
        console.warn('Date parsing failed for:', aValue, bValue);
      }
    }
    
    // Compare values
    if (aValue < bValue) return order === 'ascending' ? -1 : 1;
    if (aValue > bValue) return order === 'ascending' ? 1 : -1;
    return 0;
  });
  
  return sortedCards;
}

/* ------------- CARD NAME SEARCH ------------- */
function setupCardSearch() {
  const cardSearchInput = document.getElementById('cardSearch');
  const savedCardSearch = localStorage.getItem('cardSearch');
  
  if (savedCardSearch) {
    cardSearchValue = savedCardSearch;
    cardSearchInput.value = savedCardSearch;
  }
  
  cardSearchInput.addEventListener('input', (e) => {
    cardSearchValue = e.target.value.trim().toLowerCase();
    localStorage.setItem('cardSearch', cardSearchValue);
    sectionPages.clear();
    renderSections();
  });
}

function renderCardSearchSection() {
  // Get the current filtered cards based on all active filters
  let filteredCards = cardsData.filter(card => {
    if (region === 'global') {
      // For Global, only show cards that have release_en date (released globally)
      if (!card.release_en || card.release_en === '') return false;
    }
    
    // Apply rarity filters
    if (selectedRarities.size > 0) {
      const hasRarity = 
        (selectedRarities.has('R') && card.rarity === 1) ||
        (selectedRarities.has('SR') && card.rarity === 2) ||
        (selectedRarities.has('SSR') && card.rarity === 3);
      if (!hasRarity) return false;
    }
    
    // Apply type filters
    if (selectedTypes.size > 0 && !selectedTypes.has(card.type)) {
      return false;
    }
    
    return true;
  });
  
  // Filter by card name search
  const matches = filteredCards.filter(card => {
    const cardName = card.char_name.toLowerCase();
    return cardName.includes(cardSearchValue);
  });
  
  // Sort matches: SSR > SR > R, then by type order
  const typeOrder = { 'speed': 0, 'stamina': 1, 'power': 2, 'guts': 3, 'intelligence': 4, 'friend': 5, 'group': 6 };
  
  matches.sort((a, b) => {
    // First by rarity (SSR first)
    if (a.rarity !== b.rarity) {
      return b.rarity - a.rarity; // SSR (3) > SR (2) > R (1)
    }
    // Then by type order
    return typeOrder[a.type] - typeOrder[b.type];
  });

  // COMPLETELY HIDE SECTION IF NO MATCHES
  if (matches.length === 0) {
    return; // Don't create any section at all
  }

  // Convert search value to proper case for display
  const displaySearchValue = cardSearchValue
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'card-search-header';
  header.textContent = `Card Search: "${displaySearchValue}" (${matches.length} cards)`;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `cardSearch-${cardSearchValue}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  function renderPage(page) {
    grid.innerHTML = '';
    const startIdx = page * CARDS_PER_PAGE;
    const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
    pageCards.forEach(card => grid.appendChild(createCardElement(card)));

    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
    leftBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    rightBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    leftBtn.disabled = page === 0;
    rightBtn.disabled = page >= totalPages - 1;
    
    highlightSkills();
  }

  renderPage(currentPage);

  leftBtn.addEventListener('click', () => {
    const newPage = sectionPages.get(pageKey) - 1;
    if (newPage >= 0) {
      sectionPages.set(pageKey, newPage);
      renderPage(newPage);
      highlightSkills();
    }
  });

  rightBtn.addEventListener('click', () => {
    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
    const newPage = sectionPages.get(pageKey) + 1;
    if (newPage < totalPages) {
      sectionPages.set(pageKey, newPage);
      renderPage(newPage);
      highlightSkills();
    }
  });
}

/* ------------- DYNAMIC SKILL SEARCH ------------- */
const maxSearches = 30;

function setupDynamicSkillSearch() {
  const addSearchBtn = document.getElementById('addSearchBtn');
  
  // Clear existing search boxes first
  const existingContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  existingContainers.forEach(container => container.remove());
  
  // Recreate search boxes from saved state
  skillSearches.forEach((search, index) => {
    createSearchBox(search.id, search.value, index === 0); // First one can't be removed
  });
  
  // CRITICAL FIX: Update SKILL_SEARCH_KEYS array with ACTUAL current values
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  // CRITICAL FIX: Also update the search values in the inputs
  skillSearches.forEach(search => {
    const input = document.getElementById(search.id);
    if (input) {
      input.value = search.value;
    }
  });
  
  addSearchBtn.addEventListener('click', addSearchBox);
  
  // Setup color picker for all search boxes
  skillSearches.forEach(search => {
    setupColorPicker(search.id);
  });
}

function createSearchBox(searchId, value = '') {
  const searchContainer = document.createElement('div');
  searchContainer.className = 'search-input-container';
  
  searchContainer.innerHTML = `
    <div class="color-picker yellow" data-search-id="${searchId}" data-color="yellow"></div>
    <input type="text" id="${searchId}" class="skill-search" placeholder="Search skill" value="${value}">
    <button class="remove-search-btn" data-search-id="${searchId}" title="Remove search">
      ×
    </button>
  `;

  const skillSearchGroup = document.getElementById('skillSearchGroup');
  skillSearchGroup.appendChild(searchContainer);

  setupSearchInput(searchId);
  setupRemoveButton(searchId);
  setupColorPicker(searchId);
}

/* ------------- COLOR PICKER FUNCTIONALITY ------------- */
const colorSequence = ['yellow', 'green', 'blue', 'red'];

function setupColorPicker(searchId) {
  const colorPicker = document.querySelector(`.color-picker[data-search-id="${searchId}"]`);
  if (!colorPicker) return;

  // Load saved color - default to yellow
  const savedColor = localStorage.getItem(`color_${searchId}`) || 'yellow';
  colorPicker.className = `color-picker ${savedColor}`;
  colorPicker.dataset.color = savedColor;

  colorPicker.addEventListener('click', () => {
    const currentColor = colorPicker.dataset.color;
    const currentIndex = colorSequence.indexOf(currentColor);
    const nextIndex = (currentIndex + 1) % colorSequence.length;
    const nextColor = colorSequence[nextIndex];
    
    colorPicker.className = `color-picker ${nextColor}`;
    colorPicker.dataset.color = nextColor;
    
    localStorage.setItem(`color_${searchId}`, nextColor);
    
    // Update highlighting immediately
    highlightSkills();
  });
}

function addSearchBox() {
  if (skillSearches.length >= 30) return;

  const newId = `skillSearch${searchCounter}`;
  searchCounter++;
  
  // Add to our state
  skillSearches.push({ id: newId, value: '' });
  saveSkillSearches();
  
  // Create the UI element
  createSearchBox(newId, '', false);
  
  // CRITICAL: Update the global array immediately
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  sectionPages.clear();
  renderSections();
}

function saveSkillSearches() {
  // Update values from current inputs before saving
  skillSearches.forEach(search => {
    const input = document.getElementById(search.id);
    if (input) {
      search.value = input.value;
    }
  });
  localStorage.setItem('skillSearches', JSON.stringify(skillSearches));
}

// Modified setupSearchInput to use our persistence system
function setupSearchInput(searchId) {
  const input = document.getElementById(searchId);
  if (!input) return;

  // Find the saved value
  const savedSearch = skillSearches.find(search => search.id === searchId);
  if (savedSearch) {
    input.value = savedSearch.value;
  }

  input.addEventListener('input', () => {
    // Update our state
    const search = skillSearches.find(s => s.id === searchId);
    if (search) {
      search.value = input.value;
      saveSkillSearches();
    }
    
    sectionPages.clear();
    renderSections();
  });
}

// Modified setupRemoveButton
function setupRemoveButton(searchId) {
  const removeBtn = document.querySelector(`.remove-search-btn[data-search-id="${searchId}"]`);
  if (!removeBtn) return;

  // Remove any existing listeners to prevent duplicates
  const newRemoveBtn = removeBtn.cloneNode(true);
  removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);

  newRemoveBtn.addEventListener('click', () => {
    removeSearchBox(searchId);
  });
}

// Update the existing removeSearchBox function to use our new system
function removeSearchBox(searchId) {
  // Don't remove if it's the last search box
  if (skillSearches.length <= 1) {
    // If it's the last one, just clear the value instead of removing
    const input = document.getElementById(searchId);
    if (input) {
      input.value = '';
      // Update state
      const search = skillSearches.find(s => s.id === searchId);
      if (search) {
        search.value = '';
        saveSkillSearches();
      }
      sectionPages.clear();
      renderSections();
    }
    return;
  }
  
  // Remove from our state
  skillSearches = skillSearches.filter(search => search.id !== searchId);
  saveSkillSearches();
  
  // Remove from UI
  const container = document.querySelector(`.search-input-container input[id="${searchId}"]`)?.parentElement;
  if (container) {
    container.remove();
  }
  
  // Remove color picker data from localStorage
  localStorage.removeItem(`color_${searchId}`);
  
  // CRITICAL: Update SKILL_SEARCH_KEYS after removal
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  // If we removed the first search box and there are others, rename the remaining ones to maintain order
  reorganizeSearchBoxes();
  
  sectionPages.clear();
  renderSections();
}

function reorganizeSearchBoxes() {
  // Sort searches by their numeric ID to maintain order
  skillSearches.sort((a, b) => {
    const aNum = parseInt(a.id.replace('skillSearch', '')) || 0;
    const bNum = parseInt(b.id.replace('skillSearch', '')) || 0;
    return aNum - bNum;
  });
  
  // Clear all existing search containers
  const existingContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  existingContainers.forEach(container => container.remove());
  
  // Recreate all search boxes with new IDs if needed
  skillSearches.forEach((search, index) => {
    const newId = `skillSearch${index + 1}`;
    const oldId = search.id;
    
    // If the ID needs to change (like if we removed skillSearch1)
    if (oldId !== newId) {
      search.id = newId;
    }
    
    createSearchBox(newId, search.value);
  });
  
  // Update the global array
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  // Update search counter
  searchCounter = skillSearches.length + 1;
  
  // Save the reorganized state
  saveSkillSearches();
}

function removeFromSlot(slotEl, card){
  if(slotListeners.has(slotEl)){
    slotEl.removeEventListener('click', slotListeners.get(slotEl));
    slotListeners.delete(slotEl);
  }
  
  slotEl.classList.remove('has-card');
  delete slotEl.dataset.cardId;
  delete slotEl.dataset.supportId;
  slotEl.innerHTML='<div class="placeholder">Empty</div>';
  
  // Remove from selectedCardIds using the actual card's char_id
  if (card && card.char_id) {
    selectedCardIds.delete(Number(card.char_id));
  } else if (slotEl.dataset.cardId) {
    // Fallback: try to get char_id from slot data
    selectedCardIds.delete(Number(slotEl.dataset.cardId));
  }
  
  saveSlotsToLocalStorage();
  
  // NEW: Update the skills list
  updateSelectedSkillsList();
  
  renderSections();
}

/* ------------- TOGGLE BUTTON SETUP ------------- */
function setupToggleButtons() {
  // Rarity buttons
  document.querySelectorAll('.rarity-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const rarity = button.dataset.rarity;
      if (selectedRarities.has(rarity)) {
        selectedRarities.delete(rarity);
        button.classList.remove('active');
      } else {
        selectedRarities.add(rarity);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });

  // Type buttons
  document.querySelectorAll('.type-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const type = button.dataset.type;
      if (selectedTypes.has(type)) {
        selectedTypes.delete(type);
        button.classList.remove('active');
      } else {
        selectedTypes.add(type);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- UTIL ------------- */
function normalizeSkill(s){ return String(s||'').replace(/[◎○]/g,'').trim().toLowerCase(); }
function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase(); }
function getLengthCategory(distance){ if(distance<=1400)return'Sprint'; if(distance<=1800)return'Mile'; if(distance<=2400)return'Medium'; return'Long'; }
function isStandardDistance(distance){ return distance%400===0; }
const typeMap = { "speed":"00","stamina":"01","power":"02","guts":"03","intelligence":"04","friend":"05","group":"06" };
function escapeHtml(s){ return String(s).replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

/* ------------- AUTO-RESET PRESETS ------------- */
function setupPresetReset() {
  // Get all filter elements that should reset presets
  const resetFilters = [
    'racecourse', 'length', 'direction', 'track', 'season', 'weather'
  ];
  
  resetFilters.forEach(filterId => {
    const element = document.getElementById(filterId);
    if (element) {
      element.addEventListener('change', () => {
        // Only reset if the filter actually has a value selected
        if (element.value) {
          const presetsSelect = document.getElementById('presets');
          if (presetsSelect && presetsSelect.value) {
            presetsSelect.value = '';
            localStorage.removeItem('filter_presets');
          }
        }
      });
    }
  });
}

/* ------------- Fetch JSON ------------- */
fetch(JSON_FILE)
  .then(r => { 
    if (!r.ok) throw new Error(`Failed to fetch JSON: ${r.status} ${r.statusText}`); 
    return r.json(); 
  })
  .then(data => {
    if (!Array.isArray(data)) {
      throw new Error('JSON data is not an array');
    }
    
    cardsData = data.map(card => ({
      ...card,
      char_id: card.char_id || 0,
      char_name: card.char_name || 'Unknown',
      hint_skills: card.hint_skills || [],
      event_skills: card.event_skills || [],
      event_skills_en: card.event_skills_en || [],
      rarity: card.rarity || 1,
      release: card.release || '',
      release_en: card.release_en || '',
      support_id: card.support_id || 0,
      type: (card.type || '').toLowerCase(),
      url_name: card.url_name || ''
    }));

    setupFilterPersistence();
    setupToggleButtons();
    setupSortingControls();
    setupDynamicSkillSearch(); // This should be here
    setupPresets();
    setupPresetReset();
    setupTogglePresetCards();
    setupCardSearch();
    loadSlotsFromLocalStorage();
    
    // NEW: Initialize the skills list
    updateSelectedSkillsList();
    
    renderSections();
  })
  .catch(err => {
    console.error('Could not load JSON:', err);
    cardSections.innerHTML = `
      <div style="opacity:0.7;padding:12px;text-align:center;">
        <h3>Error loading data</h3>
        <p>${err.message}</p>
        <p>Check browser console for details.</p>
      </div>
    `;
  });

/* ------------- PRESETS ------------- */
const PRESETS_JSON_FILE = "champions_meeting.json";

let presetRaceNumbers = new Map(); // Store race numbers by title

function formatPresetDate(dateString) {
  const date = new Date(dateString);
  const month = date.toLocaleString('en-US', { month: 'short' });
  const year = date.getFullYear();
  return `${month} ${year}`;
}

function createPresetLabel(cup, index) {
  const distance = cup.distance === "Mile" ? "MILE" : cup.distance;
  const trackType = cup.aptitude === "Turf" ? "Turf" : "Dirt";
  const length = cup.length.replace(/\s*m/g, 'm');
  
  // Store the race number for this cup title
  presetRaceNumbers.set(cup.title, index + 1);
  
  return `${index + 1}. ${cup.title} — ${cup.racecourse} ${trackType} ${length} ${cup.track_conditions}`;
}

function setupPresets() {
  const presetsSelect = document.getElementById('presets');
  if (!presetsSelect) return;

  const savedPreset = localStorage.getItem('filter_presets');

  fetch(PRESETS_JSON_FILE)
    .then(response => {
      if (!response.ok) throw new Error('Failed to fetch presets JSON');
      return response.json();
    })
    .then(data => {
      presetsSelect.innerHTML = '<option value="">-- Select --</option>';
      
      // Sort cups by start_date to ensure proper numbering
      const sortedCups = data.cups.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
      
      sortedCups.forEach((cup, index) => {
        const option = document.createElement('option');
        option.value = cup.title;
        option.textContent = createPresetLabel(cup, index);
        option.dataset.cupData = JSON.stringify(cup);
        presetsSelect.appendChild(option);
      });
      
      if (savedPreset) presetsSelect.value = savedPreset;
      
      presetsSelect.addEventListener('change', function() {
        localStorage.setItem('filter_presets', this.value);
        
        if (this.value) {
          const selectedOption = this.options[this.selectedIndex];
          const cup = JSON.parse(selectedOption.dataset.cupData);
          applyPreset(cup);
        } else {
          sectionPages.clear();
          renderSections();
        }
      });
    })
    .catch(err => {
      console.error('Could not load presets:', err);
      const option = document.createElement('option');
      option.textContent = 'Error loading presets';
      option.disabled = true;
      presetsSelect.appendChild(option);
    });
}

function applyPreset(cup) {
  document.getElementById('racecourse').value = cup.racecourse;
  document.getElementById('length').value = cup.length.replace(' m', '');
  document.getElementById('direction').value = cup.direction;
  document.getElementById('track').value = cup.track_conditions;
  
  // Fix season mapping: JSON has "Autumn" but dropdown uses "Fall"
  const seasonMap = {
    'Autumn': 'Fall', // Map JSON "Autumn" to dropdown "Fall"
    'Spring': 'Spring', 
    'Summer': 'Summer',
    'Winter': 'Winter'
  };
  document.getElementById('season').value = seasonMap[cup.season] || cup.season;
  
  // Fix weather mapping: JSON has "Rain"/"Snow" but dropdown uses "Rainy"/"Snowy"
  const weatherMap = {
    'Rain': 'Rainy', // Map JSON "Rain" to dropdown "Rainy"
    'Snow': 'Snowy', // Map JSON "Snow" to dropdown "Snowy"
    'Sunny': 'Sunny',
    'Cloudy': 'Cloudy'
  };
  document.getElementById('weather').value = weatherMap[cup.weather] || cup.weather;
  
  document.getElementById('strategy').value = '';
  
  FILTER_KEYS.forEach(id => {
    const el = document.getElementById(id);
    if (el && el.value) localStorage.setItem('filter_' + id, el.value);
  });
  
  sectionPages.clear();
  renderSections();
}

FILTER_KEYS.push('presets');

/* ------------- SETUP NEW CONTROLS ------------- */
function setupSortingControls() {
  const sortBySelect = document.getElementById('sortBy');
  const sortOrderBtn = document.getElementById('sortOrder');
  const regionSelect = document.getElementById('region');

  // Load saved values
  const savedSortBy = localStorage.getItem('sortBy');
  const savedSortOrder = localStorage.getItem('sortOrder');
  const savedRegion = localStorage.getItem('region');

  if (savedSortBy) {
    sortBy = savedSortBy;
    sortBySelect.value = savedSortBy;
  } else {
    // SET DEFAULT TO RARITY
    sortBySelect.value = 'rarity';
  }
  
  if (savedSortOrder) {
    sortOrder = savedSortOrder;
    sortOrderBtn.textContent = sortOrder === 'ascending' ? '↑' : '↓';
    sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
  } else {
    // SET DEFAULT TO DESCENDING
    sortOrder = 'descending';
    sortOrderBtn.textContent = '↓';
    sortOrderBtn.classList.remove('ascending');
  }
  
  if (savedRegion) {
    region = savedRegion;
    regionSelect.value = savedRegion;
  } else {
    // SET DEFAULT TO GLOBAL
    regionSelect.value = 'global';
  }

  // Event listeners
  sortBySelect.addEventListener('change', (e) => {
    sortBy = e.target.value;
    localStorage.setItem('sortBy', sortBy);
    sectionPages.clear();
    renderSections();
  });

  sortOrderBtn.addEventListener('click', () => {
    sortOrder = sortOrder === 'ascending' ? 'descending' : 'ascending';
    sortOrderBtn.textContent = sortOrder === 'ascending' ? '↑' : '↓';
    sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
    localStorage.setItem('sortOrder', sortOrder);
    sectionPages.clear();
    renderSections();
  });

regionSelect.addEventListener('change', (e) => {
  region = e.target.value;
  localStorage.setItem('region', region);
  sectionPages.clear();
  
  // Update all slots with the new region's skills
  updateSlotsForRegion();
  
  // NEW: Update the skills list
  updateSelectedSkillsList();
  
  renderSections();
});
}

// Add updateSlotsForRegion function here
function updateSlotsForRegion() {
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        // Remove the existing slot content
        if (slotListeners.has(slot)) {
          slot.removeEventListener('click', slotListeners.get(slot));
          slotListeners.delete(slot);
        }
        
        // Re-add the card with updated skills for the current region
        addToSlot(card, slot, false); // false to not trigger save (we'll do it once at the end)
      }
    }
  });
  
  // Save the updated slots
  saveSlotsToLocalStorage();
  
  // Re-apply highlighting to show/hide skills based on new region
  highlightSkills();
  updateSkillVisibility();
}

// In setupHideUncoloredCheckbox
function setupHideUncoloredCheckbox() {
  const hideUncoloredCheckbox = document.getElementById('hideUncolored');
  const savedHideUncolored = localStorage.getItem('hideUncolored');

  if (savedHideUncolored) {
    hideUncolored = savedHideUncolored === 'true';
    hideUncoloredCheckbox.checked = hideUncolored;
  }

  hideUncoloredCheckbox.addEventListener('change', (e) => {
    hideUncolored = e.target.checked;
    localStorage.setItem('hideUncolored', hideUncolored);
    updateSkillVisibility(); // Update visibility when checkbox changes
    updateSelectedSkillsVisibility(); // NEW: Also update selected skills visibility
  });
}


/* ------------- UPDATED CARD CREATION WITH BETTER ERROR HANDLING ------------- */
function createCardElement(card){
  const el = document.createElement('div');
  el.className = 'card';
  el.dataset.id = card.char_id;
  el.dataset.supportId = card.support_id;
  el.dataset.name = card.char_name;

  const imgSrc = `https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png`;
  const typeImg = `https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type]||"xx"}.png`;

  // Use English skills for Global region, Japanese skills for Japan region
  // Fall back to Japanese skills if English skills are empty
  const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
  const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

  let skillsHTML = '';
  
  // FIX: Handle hint_skills with safe string conversion
  if(card.hint_skills && card.hint_skills.length) {
    const hintSkillsHTML = card.hint_skills.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
  }

  // FIX: Handle event skills with safe string conversion
  if(eventSkillsToUse && eventSkillsToUse.length) {
    const eventSkillsHTML = eventSkillsToUse.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
  }
  
  let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;
  if(!HIDE.char_id) nameHtml += `<div style="font-size:9px;opacity:0.6;margin-bottom: 6px;">ID: ${card.char_id}</div>`;
  if(!HIDE.url_name && card.url_name) nameHtml += `<div style="font-size:9px;opacity:0.6;">${escapeHtml(card.url_name)}</div>`;

  el.innerHTML = `
    <div class="type-icon"><img src="${typeImg}" alt="${escapeHtml(card.type)}"></div>
    <img src="${imgSrc}" alt="${escapeHtml(card.char_name)}">
    ${nameHtml}
    <div class="skills">${skillsHTML}</div>
  `;

  el.addEventListener('click', ()=> {
    const slot = slots.find(s => Number(s.dataset.cardId) === card.char_id);
    if(slot) removeFromSlot(slot, card);
    else addToSlot(card);
  });

  if(selectedCardIds.has(card.char_id)){
    el.classList.add('disabled');
    const dupLabel = document.createElement('div');
    dupLabel.textContent = 'Duplicate Support';
    dupLabel.style.position = 'absolute';
    dupLabel.style.top = '0';
    dupLabel.style.left = '0';
    dupLabel.style.width = '100%';
    dupLabel.style.background = 'red';
    dupLabel.style.color = 'white';
    dupLabel.style.fontSize = '9px';
    dupLabel.style.fontWeight = 'bold';
    dupLabel.style.textAlign = 'center';
    dupLabel.style.padding = '2px 0';
    dupLabel.style.borderTopLeftRadius = '4px';
    dupLabel.style.borderTopRightRadius = '4px';
    el.appendChild(dupLabel);
  }

  return el;
}

/* ------------- Slot handling & persistence ------------- */
function saveSlotsToLocalStorage() {
  const slotData = slots.map(s => s.dataset.supportId || null);
  localStorage.setItem(SLOT_KEY, JSON.stringify(slotData));
}

function loadSlotsFromLocalStorage() {
  const saved = localStorage.getItem(SLOT_KEY);
  if (!saved) return;
  const slotData = JSON.parse(saved);

  slotData.forEach((supportId, index) => {
    if (supportId) {
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      if (card) addToSlot(card, slots[index], false);
    }
  });
  
  // NEW: Apply highlighting to all loaded slot skills
  highlightSkills();
}

function addToSlot(card, targetSlot = null, save = true){
  const freeSlot = targetSlot || slots.find(s => !s.dataset.cardId);
  if(!freeSlot) return;

  // Remove existing listener if any
  if(slotListeners.has(freeSlot)){
    freeSlot.removeEventListener('click', slotListeners.get(freeSlot));
    slotListeners.delete(freeSlot);
  }

// Use English skills for Global region, Japanese skills for Japan region
// Fall back to Japanese skills if English skills are empty
const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

  let skillsHTML = '';
  
  // Only add skills groups if there are skills to show
  if(card.hint_skills && card.hint_skills.length) {
    const hintSkillsHTML = card.hint_skills.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
  }

  if(eventSkillsToUse && eventSkillsToUse.length) {
    const eventSkillsHTML = eventSkillsToUse.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
  }

  freeSlot.dataset.cardId = card.char_id;
  freeSlot.dataset.supportId = card.support_id;
  freeSlot.classList.add('has-card');
  
  // Use compact styling for slots
  freeSlot.innerHTML = `
    <div class="type-icon"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type]||"xx"}.png" alt="${escapeHtml(card.type)}"></div>
    <img src="https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png" alt="${escapeHtml(card.char_name)}">
    <div class="name">${escapeHtml(card.char_name)}</div>
    <div class="skills">${skillsHTML}</div>
  `;

  // Create and attach the click handler - store the actual card object
  const slotCard = {...card}; // Create a copy to avoid reference issues
  
  function slotClickHandler(){ 
    removeFromSlot(freeSlot, slotCard); 
  }
  
  // Attach the event listener to the slot element
  freeSlot.addEventListener('click', slotClickHandler);
  slotListeners.set(freeSlot, slotClickHandler);

  selectedCardIds.add(card.char_id);
  if(save) saveSlotsToLocalStorage();
  
  // NEW: Update the skills list
  updateSelectedSkillsList();
  
  // NEW: Apply highlighting to the slot skills immediately
  highlightSkills();
  renderSections();
}


/* ------------- Clear buttons ------------- */
clearAllBtn.addEventListener('click', ()=>{
  selectedCardIds.clear();
  slots.forEach(slot=>{
    if(slotListeners.has(slot)){
      slot.removeEventListener('click', slotListeners.get(slot));
      slotListeners.delete(slot);
    }
    slot.classList.remove('has-card');
    delete slot.dataset.cardId;
    slot.innerHTML='<div class="placeholder">Empty</div>';
  });
  localStorage.removeItem(SLOT_KEY);
  
  // NEW: Update the skills list
  updateSelectedSkillsList();
  
  renderSections();
});

clearFiltersBtn.addEventListener('click', () => {
  FILTER_KEYS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
    localStorage.removeItem('filter_' + id);
  });

  const cardSearchInput = document.getElementById('cardSearch');
  if (cardSearchInput) {
    cardSearchInput.value = '';
    cardSearchValue = '';
    localStorage.removeItem('cardSearch');
  }

  // Clear skill searches - ONLY clear the values, don't reset the structure
  const searchInputs = document.querySelectorAll('.skill-search');
  searchInputs.forEach(input => {
    input.value = ''; // Clear the input value
    localStorage.setItem('filter_' + input.id, ''); // Clear from storage
  });

  // Clear toggle buttons (rarity and type)
  selectedRarities.clear();
  selectedTypes.clear();
  document.querySelectorAll('.toggle-button').forEach(button => {
    button.classList.remove('active');
  });

  // Reset preset cards to visible state when clearing filters
  showPresetCards = true;
  localStorage.setItem('showPresetCards', 'true');
  updateTogglePresetCardsButton();
  updateSidebarFiltersVisibility(); // ADD THIS

  // DO NOT clear sorting and region controls - keep them as they are
  
  const presetsSelect = document.getElementById('presets');
  if (presetsSelect) presetsSelect.value = '';
  sectionPages.clear();
  renderSections();
  updateSkillVisibility();
});

/* ------------- Filter persistence ------------- */
function setupFilterPersistence(){
  FILTER_KEYS.forEach(id=>{
    const el=document.getElementById(id); if(!el)return;
    const saved=localStorage.getItem('filter_'+id); if(saved) el.value=saved;
    el.addEventListener('change', ()=>{
      localStorage.setItem('filter_'+id, el.value);
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- CONCISE HIGHLIGHTING LOGIC ------------- */
function highlightSkills() {
  // Process ALL skills (both in main content and slots)
  document.querySelectorAll('.skill').forEach(skill => {
    skill.classList.remove('highlighted', 'search-highlighted');
    skill.style.background = '#eef2ff';
    skill.style.color = '#000';
  });

  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

  const searchTerms = SKILL_SEARCH_KEYS
    .map(id => {
      const input = document.getElementById(id);
      const colorPicker = document.querySelector(`.color-picker[data-search-id="${id}"]`);
      const color = colorPicker ? colorPicker.dataset.color : 'red';
      return {
        term: input?.value.trim().toLowerCase(),
        color: color
      };
    })
    .filter(item => item.term);

  const colorMap = {
    racecourse: '#ff7792', length: '#ffae77', direction: '#ffff77',
    track: '#77ff92', season: '#77c9ff', weather: '#c977ff', strategy: '#ff77e4'
  };

  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },
      { term: `${s} Straightaways`, color: colorMap.strategy },
      { term: `${s} Savvy`, color: colorMap.strategy }
    );
  }
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },
      { term: `${label} Straightaways`, color: colorMap.length },
      { term: distType, color: colorMap.length }
    );
  }

  document.querySelectorAll('.skill').forEach(skill => {
    const skillText = normalizeSkill(skill.textContent || '');
    
    // Check search terms with custom colors
    for (const { term, color } of searchTerms) {
      if (skillText.includes(term)) {
        const colorValue = getColorValue(color);
        const textColor = getTextColor(color);
        
        // Use !important in JavaScript to override any CSS
        skill.style.setProperty('background', colorValue, 'important');
        skill.style.setProperty('color', textColor, 'important');
        skill.classList.add('search-highlighted');
        return; // Only highlight with first matching search term
      }
    }
    
    // Check dropdown terms
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skill.style.background = color;
        skill.style.color = '#000';
        skill.classList.add('highlighted');
        break;
      }
    }
  });

  // NEW: Update skill visibility for ALL skills (main content and slots)
  updateSkillVisibility();
}

// Helper functions for colors
// Helper functions for colors
function getColorValue(colorName) {
  const colorMap = {
    red: '#cc0000',
    blue: '#0044cc', 
    green: '#008800',
    yellow: '#cc9900'
  };
  return colorMap[colorName] || '#cc0000';
}

function getTextColor(colorName) {
  // Always use white text for all colors
  return '#ffffff';
}

function updateSkillVisibility() {
  const shouldHide = hideUncolored;
  
  // Process ALL skills (both in main content and slots)
  document.querySelectorAll('.skill').forEach(skill => {
    const isHighlighted = skill.classList.contains('highlighted') || 
                         skill.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skill.classList.add('hidden-skill');
    } else {
      skill.classList.remove('hidden-skill');
    }
  });
  
  // Hide empty headers AND entire groups when hiding uncolored skills
  document.querySelectorAll('.skills-group').forEach(group => {
    const skills = group.querySelectorAll('.skill');
    const visibleSkills = Array.from(skills).filter(skill => !skill.classList.contains('hidden-skill'));
    
    const header = group.querySelector('.skills-header');
    if (header) {
      if (shouldHide && visibleSkills.length === 0) {
        header.classList.add('hidden-skill');
        group.classList.add('hidden-skill'); // Hide the entire group
      } else {
        header.classList.remove('hidden-skill');
        group.classList.remove('hidden-skill'); // Show the entire group
      }
    }
  });
}

/* ------------- FILTER BUILDING & MATCHING ------------- */
function buildFilterTerms(filters){
  const terms=[];
  if(filters.racecourse) terms.push(`${filters.racecourse} Racecourse`);
  if(filters.direction) terms.push(filters.direction==='Clockwise'?'Right-Handed':'Left-Handed');
  if(filters.track) terms.push(filters.track==='Firm'?'Firm Conditions':'Wet Conditions');
  
  // Handle season - dropdown uses "Fall" but skills use "Fall Runner"
  if(filters.season) {
    terms.push(`${filters.season} Runner`);
  }
  
  // Handle weather - dropdown uses "Rainy"/"Snowy" but skills use "Rainy Days"/"Snowy Days"
  if(filters.weather) {
    terms.push(`${filters.weather} Days`);
  }
  
  if(filters.strategy){
    const s=filters.strategy;
    terms.push(`${s} Corners`,`${s} Straightaways`,`${s} Savvy`);
  }
  if(filters.length){
    const dist=parseInt(filters.length);
    const label=getLengthCategory(dist);
    terms.push(`${label} Corners`,`${label} Straightaways`,isStandardDistance(dist)?'Standard Distance':'Non-Standard Distance');
  }
  return terms;
}

function filterCardsWithRules(cards,filters){
  const terms=buildFilterTerms(filters).map(normalizeSkill);
  const strictDistanceKeys=['standard distance','non-standard distance'];
  const strictTerms=terms.filter(t=>strictDistanceKeys.includes(t));
  const looseTerms=terms.filter(t=>!strictDistanceKeys.includes(t));
  return cards.filter(card=>{
    const skills=[...card.hint_skills,...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t=>skills.includes(t)) && looseTerms.every(term=>skills.some(s=>s.includes(term)));
  });
}

/* ------------- UPDATED RENDER SECTIONS WITH CARD SEARCH AT TOP ------------- */
function renderSections() {
  cardSections.innerHTML='';

  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

const anyDropdownActive = Object.values(filters).some(v => v);
const anySkillActive = SKILL_SEARCH_KEYS.some(key => document.getElementById(key)?.value.trim());
const anyRarityActive = selectedRarities.size > 0;
const anyTypeActive = selectedTypes.size > 0;
const anyCardSearchActive = cardSearchValue.length > 0;

  if(!anyDropdownActive && !anySkillActive && !anyRarityActive && !anyTypeActive && !anyCardSearchActive) {
    const section = document.createElement('div');
    section.className = 'card-section';
    section.style.display = 'flex';
    section.style.flexDirection = 'column';
    section.style.alignItems = 'center';
    section.style.justifyContent = 'center';
    const msg = document.createElement('div');
    msg.style.opacity = '0.7';
    msg.style.padding = '0px';
    msg.style.marginTop = '20px';
    msg.style.marginBottom = '10px';
    msg.textContent = 'Pick a label on the left or type a skill to show matching cards.';
    section.appendChild(msg);
    cardSections.appendChild(section);
    return;
  }

// Apply region filter first - CORRECTED
let baseFilteredCards = cardsData.filter(card => {
  if (region === 'global') {
    // For Global, only show cards that have release_en date (released globally)
    return card.release_en && card.release_en !== '';
  } else { // japan
    // For Japan, show ALL cards (including those not released globally)
    return true;
  }
});
  
  // Apply rarity and type filters to base cards
  if (anyRarityActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      if (selectedRarities.has('R') && card.rarity === 1) return true;
      if (selectedRarities.has('SR') && card.rarity === 2) return true;
      if (selectedRarities.has('SSR') && card.rarity === 3) return true;
      return false;
    });
  }
  
  if (anyTypeActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      return selectedTypes.has(card.type);
    });
  }

  // APPLY SORTING to base cards
  baseFilteredCards = sortCards(baseFilteredCards, sortBy, sortOrder);

  // ADD THIS NEW SECTION AT THE TOP - Render Card Name Search FIRST
  if (anyCardSearchActive) {
    renderCardSearchSection();
  }

// Render dropdown filter sections (separated as before)
const filterOrder = ['racecourse','length','direction','track','season','weather','strategy'];
filterOrder.forEach(catId => {
  if (!filters[catId]) return;

  // ADD THIS CHECK - only render if preset cards should be shown
  if (!shouldShowFilterSection(catId)) return;

  if (catId === 'length') {
      const dist = parseInt(filters.length);
      const label = getLengthCategory(dist);
      const distanceType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';

      [
        { title: `${label} Corners`, terms: [`${label} Corners`] },
        { title: `${label} Straightaways`, terms: [`${label} Straightaways`] },
        { title: distanceType, terms: [distanceType] }
      ].forEach((row, idx) => renderFilterRow(catId, row.title, row.terms, idx, baseFilteredCards));

    } else if (catId === 'strategy') {
      const strat = filters.strategy;
      const stratRows = [
        { title: `${strat} Corners`, term: `${strat} Corners` },
        { title: `${strat} Straightaways`, term: `${strat} Straightaways` },
        { title: `${strat} Savvy`, term: `${strat} Savvy` }
      ];
      stratRows.forEach((row, idx) => renderFilterRow(catId, row.title, [row.term], idx, baseFilteredCards));

    } else {
      let rowTerms = [], headerText = '';
      switch (catId) {
        case 'racecourse': rowTerms.push(`${filters.racecourse} Racecourse`); headerText = `${filters.racecourse} Racecourse`; break;
        case 'direction': const dir = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed'; rowTerms.push(dir); headerText = dir; break;
        case 'track': const trackLabel = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions'; rowTerms.push(trackLabel); headerText = trackLabel; break;
        case 'season': rowTerms.push(`${filters.season} Runner`); headerText = `${filters.season} Runner`; break;
        case 'weather': rowTerms.push(`${capitalize(filters.weather)} Days`); headerText = `${capitalize(filters.weather)} Days`; break;
      }
      renderFilterRow(catId, headerText, rowTerms, 0, baseFilteredCards);
    }
  });

// Render skill search sections (separated as before)
SKILL_SEARCH_KEYS.forEach((key, i) => {
  const val = document.getElementById(key)?.value.trim();
  if (!val) return;

  const normalized = normalizeSkill(val);
  
  // Use a Set to track unique cards by support_id to avoid duplicates
  const uniqueMatches = new Set();
  const matches = [];
  
  baseFilteredCards.forEach(card => {
    // Use English skills for Global region, Japanese skills for Japan region
    // Fall back to Japanese skills if English skills are empty
    const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
    const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
    
    const skills = [...card.hint_skills, ...eventSkillsToUse].map(normalizeSkill);
    const hasMatch = skills.some(s => s.includes(normalized));
    
    if (hasMatch && !uniqueMatches.has(card.support_id)) {
      uniqueMatches.add(card.support_id);
      matches.push(card);
    }
  });

  const header = `Skill Search ${i + 1}: "${val}"`;
  renderSkillSearchRow(key, header, matches, i);
});

  highlightSkills();
} // This closes the renderSections function

function renderFilterRow(catId, headerText, termList, rowIndex, baseCards){
  const termsNormalized = termList.map(normalizeSkill);
  const strictDistanceKeys = ['standard distance','non-standard distance'];
  const strictTerms = termsNormalized.filter(t => strictDistanceKeys.includes(t));
  const looseTerms = termsNormalized.filter(t => !strictDistanceKeys.includes(t));

  const matches = baseCards.filter(card => {
    const skills = [...card.hint_skills, ...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t => skills.includes(t)) && looseTerms.every(term => skills.some(s => s.includes(term)));
  });

  // COMPLETELY HIDE SECTION IF NO MATCHES
  if(matches.length === 0){
    return; // Don't create any section at all
  }

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.textContent = headerText;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button'); 
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  const rightBtn = document.createElement('button'); 
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  const pageKey = `${catId}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  function renderPage(page, matches, grid, leftBtn, rightBtn, pageKey){
    grid.innerHTML = '';
    const startIdx = page * CARDS_PER_PAGE;
    const endIdx = startIdx + CARDS_PER_PAGE;
    const pageCards = matches.slice(startIdx, endIdx);
    pageCards.forEach(card => grid.appendChild(createCardElement(card)));

    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);

    leftBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    rightBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    leftBtn.disabled = page === 0;
    rightBtn.disabled = page >= totalPages - 1;

    leftBtn.onclick = ()=>{ 
      renderPage(page-1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey,page-1);
      highlightSkills();
    };
    rightBtn.onclick = ()=>{ 
      renderPage(page+1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey,page+1);
      highlightSkills();
    };
    
    highlightSkills();
  }

  renderPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);
  cardSections.appendChild(section);
}

function properCaseSkill(s) {
  return String(s || '')
    .split(' ')
    .map(word => {
      // Handle hyphenated words like "fast-paced"
      if (word.includes('-')) {
        return word
          .split('-')
          .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
          .join('-');
      }
      // Regular words
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

function renderSkillSearchRow(key, headerText, matches, rowIndex) {
  // COMPLETELY HIDE SECTION IF NO MATCHES
  if (matches.length === 0) {
    return; // Don't create any section at all
  }

  // Get the actual search value and convert to proper case for display
  const input = document.getElementById(key);
  const searchValue = input ? input.value.trim() : '';
  const displaySearchValue = searchValue
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'skill-search-header';
  header.textContent = `Skill Search ${rowIndex + 1}: "${displaySearchValue}"`;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `${key}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  function renderPage(page) {
    grid.innerHTML = '';
    const startIdx = page * CARDS_PER_PAGE;
    const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
    pageCards.forEach(card => grid.appendChild(createCardElement(card)));

    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
    leftBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    rightBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    leftBtn.disabled = page === 0;
    rightBtn.disabled = page >= totalPages - 1;
    
    highlightSkills();
  }

  renderPage(currentPage);

  leftBtn.addEventListener('click', () => {
    const newPage = sectionPages.get(pageKey) - 1;
    if (newPage >= 0) {
      sectionPages.set(pageKey, newPage);
      renderPage(newPage);
      highlightSkills();
    }
  });

  rightBtn.addEventListener('click', () => {
    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
    const newPage = sectionPages.get(pageKey) + 1;
    if (newPage < totalPages) {
      sectionPages.set(pageKey, newPage);
      renderPage(newPage);
      highlightSkills();
    }
  });
}

/* ------------- TOGGLE PRESET CARDS FUNCTIONALITY ------------- */
function setupTogglePresetCards() {
  const togglePresetCardsBtn = document.getElementById('togglePresetCardsBtn');
  
  // Load saved state
  const savedState = localStorage.getItem('showPresetCards');
  if (savedState !== null) {
    showPresetCards = savedState === 'true';
    updateTogglePresetCardsButton();
    updateSidebarFiltersVisibility(); // ADD THIS
  }

  togglePresetCardsBtn.addEventListener('click', () => {
    showPresetCards = !showPresetCards;
    localStorage.setItem('showPresetCards', showPresetCards);
    updateTogglePresetCardsButton();
    updateSidebarFiltersVisibility(); // ADD THIS
    renderSections();
  });
}

function updateTogglePresetCardsButton() {
  const togglePresetCardsBtn = document.getElementById('togglePresetCardsBtn');
  togglePresetCardsBtn.textContent = showPresetCards ? 
    'Hide Preset Cards' : 
    'Show Preset Cards';
}

// ADD THIS NEW FUNCTION
function updateSidebarFiltersVisibility() {
  const sidebarFiltersSection = document.getElementById('sidebarFiltersSection');
  if (sidebarFiltersSection) {
    if (showPresetCards) {
      sidebarFiltersSection.classList.remove('hidden');
    } else {
      sidebarFiltersSection.classList.add('hidden');
    }
  }
}

function shouldShowFilterSection(catId) {
  // If we're hiding preset cards, only show skill search sections
  if (!showPresetCards) {
    return false; // Hide all filter-based sections (racecourse, length, etc.)
  }
  return true; // Show all sections when preset cards are visible
}

/* ------------- SELECTED SKILLS MANAGEMENT ------------- */
function updateSelectedSkillsList() {
  const skillsList = document.getElementById('selectedSkillsList');
  const skillsCount = document.getElementById('skillsCount');
  
  if (!skillsList) return;
  
  // Get all unique skills from selected cards
  const allSkills = getAllSkillsFromSelectedCards();
  
  // Clear current list
  skillsList.innerHTML = '';
  
  // Create skill elements
  allSkills.forEach(skill => {
    const skillElement = document.createElement('div');
    skillElement.className = 'skill-item';
    skillElement.textContent = skill;
    skillsList.appendChild(skillElement);
  });
  
  // Update count
  if (skillsCount) {
    skillsCount.textContent = allSkills.length;
  }
  
  // NEW: Also highlight selected skills
  highlightSelectedSkills();
  updateSelectedSkillsVisibility();
}

function getAllSkillsFromSelectedCards() {
  const allSkills = new Set();
  
  // Iterate through all slots with cards
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        // Use English skills for Global region, Japanese skills for Japan region
        const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
        const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
        
        // Add hint skills
        if (card.hint_skills) {
          card.hint_skills.forEach(skill => {
            const cleanSkill = String(skill || '').replace(/○\s*/g, '').trim();
            if (cleanSkill) allSkills.add(properCaseSkill(cleanSkill));
          });
        }
        
        // Add event skills
        if (eventSkillsToUse) {
          eventSkillsToUse.forEach(skill => {
            const cleanSkill = String(skill || '').replace(/○\s*/g, '').trim();
            if (cleanSkill) allSkills.add(properCaseSkill(cleanSkill));
          });
        }
      }
    }
  });
  
  // Convert Set to Array and sort alphabetically
  return Array.from(allSkills).sort();
}

function highlightSelectedSkills() {
  const skillItems = document.querySelectorAll('.skill-item');
  if (skillItems.length === 0) return;
  
  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };
  
  const searchTerms = SKILL_SEARCH_KEYS
    .map(id => {
      const input = document.getElementById(id);
      const colorPicker = document.querySelector(`.color-picker[data-search-id="${id}"]`);
      const color = colorPicker ? colorPicker.dataset.color : 'red';
      return {
        term: input?.value.trim().toLowerCase(),
        color: color
      };
    })
    .filter(item => item.term);
  
  const colorMap = {
    racecourse: '#ff7792', length: '#ffae77', direction: '#ffff77',
    track: '#77ff92', season: '#77c9ff', weather: '#c977ff', strategy: '#ff77e4'
  };
  
  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },
      { term: `${s} Straightaways`, color: colorMap.strategy },
      { term: `${s} Savvy`, color: colorMap.strategy }
    );
  }
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },
      { term: `${label} Straightaways`, color: colorMap.length },
      { term: distType, color: colorMap.length }
    );
  }
  
  skillItems.forEach(skillItem => {
    skillItem.classList.remove('highlighted', 'search-highlighted');
    skillItem.style.background = '#eef2ff';
    skillItem.style.color = '#000';
    
    const skillText = normalizeSkill(skillItem.textContent || '');
    
    // Check search terms with custom colors
    for (const { term, color } of searchTerms) {
      if (skillText.includes(term)) {
        const colorValue = getColorValue(color);
        const textColor = getTextColor(color);
        
        skillItem.style.setProperty('background', colorValue, 'important');
        skillItem.style.setProperty('color', textColor, 'important');
        skillItem.classList.add('search-highlighted');
        return; // Only highlight with first matching search term
      }
    }
    
    // Check dropdown terms
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skillItem.style.background = color;
        skillItem.style.color = '#000';
        skillItem.classList.add('highlighted');
        break;
      }
    }
  });
}

function updateSelectedSkillsVisibility() {
  const shouldHide = hideUncolored;
  const skillItems = document.querySelectorAll('.skill-item');
  
  skillItems.forEach(skillItem => {
    const isHighlighted = skillItem.classList.contains('highlighted') || 
                         skillItem.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skillItem.classList.add('hidden-skill');
    } else {
      skillItem.classList.remove('hidden-skill');
    }
  });
}

// Initialize the hide uncolored checkbox
setupHideUncoloredCheckbox();

// Auto-update whenever a filter dropdown changes
['racecourse','length','direction','track','season','weather','strategy']
  .forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.addEventListener('change', renderSections);
    }
  });

document.addEventListener('DOMContentLoaded', () => {
  renderSections();
});

window.addEventListener('resize', renderSections);

// Initialize skill search persistence when the page loads
document.addEventListener('DOMContentLoaded', () => {
  // This will be called by the existing DOMContentLoaded listener
});

</script>
</body>
</html>