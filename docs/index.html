<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Uma Builder — Card Picker</title>
<style>
:root {
  --card-w: 120px;  /* Balanced size- */
  --gap: 8px;       /* Reduced gap */
}

/* Remove vertical scrollbar for entire page */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden; /* Prevent body scrollbar */
}

body {
  font-family: Arial, Helvetica, sans-serif;
  background: #fff;
  color: #111;
}

/* ---------- HEADER STYLES ---------- */
.header {
  height: 70px;
  background: #fff;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 30px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header-left {
  display: flex;
  align-items: center;
}

.header-logo {
  height: 40px;
  width: auto;
}

.header-title {
  margin-left: 12px;
  font-size: 18px;
  font-weight: bold;
  color: #333;
}

.header-nav {
  display: none; /* Hide nav links for now */
}

/* ---------- CONTAINER & SIDEBARS ---------- */
/* Adjust container to account for header */
.container {
  display: flex;
  width: 100%;
  height: calc(100vh - 70px);
  overflow: hidden; /* Ensure no scrollbar in container */
}

.sidebar {
  flex-shrink: 0;
  width: 200px;
  padding: 16px 12px; /* Consistent padding */
  box-sizing: border-box;
  background: #f9f9f9;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 12px; /* Consistent gap between items */
}

/* Hide sidebar scrollbars */
.sidebar::-webkit-scrollbar {
  display: none;
}
.sidebar {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

/* Right sidebar for slots */
.right-sidebar {
  flex-shrink: 0;
  padding: 16px 12px; /* Consistent padding with left sidebar */
  box-sizing: border-box;
  background: #f5f5f5;
  overflow-y: auto;
  border-left: 1px solid #ddd;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px; /* Consistent gap */
}

/* Hide right sidebar scrollbars */
.right-sidebar::-webkit-scrollbar {
  display: none;
}
.right-sidebar {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

/* Right sidebar specific styles */
.right-sidebar .slots-header {
  margin-top: 0; /* Remove extra top margin since we have consistent padding */
  margin-bottom: 0;
}

/* ---------- MAIN CONTENT (BALANCED SIZING) ---------- */

/* Hide scrollbars but keep scrolling functionality */
.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  overflow-y: auto; /* Keep scrolling enabled */
  padding: 16px;
  box-sizing: border-box;
}

/* Hide scrollbar for Webkit browsers (Chrome, Safari, Edge) */
.main-content::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for Firefox */
.main-content {
  scrollbar-width: none;
}

/* Hide scrollbar for IE/Edge */
.main-content {
  -ms-overflow-style: none;
}

/* Wrapper to center cards */
.content-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  width: calc(var(--card-w) * 6 + var(--gap) * 5);
  margin: 0 auto;
}

/* ---------- SIDEBAR IMPROVEMENTS ---------- */
.sidebar .filter-group {
  display: flex;
  flex-direction: column;
  margin-bottom: 0; /* Remove bottom margin since we use gap */
}

.sidebar .filter-group label {
  margin-bottom: 4px;
  font-weight: 600;
  font-size: 13px;
}

.sidebar select, .sidebar .skill-search {
  width: 100%;
  max-width: 180px;
  padding: 6px 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

/* ---------- TOGGLE BUTTON STYLES ---------- */
.toggle-button-group {
  display: flex;
  flex-direction: column;
  gap: 0px;
  margin-bottom: 0;
}

.toggle-button-group label {
  margin-bottom: 4px;
  font-weight: 600;
  font-size: 13px;
}

.toggle-buttons-row {
  display: flex;
  justify-content: flex-start;
}

.toggle-button {
  background: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border: none; /* Remove border by default */
}

.toggle-button:hover {
  background: #f0f0f0; /* Light gray background on hover */
}

.toggle-button.active {
  background: none; /* Remove background when active */
}

/* Rarity buttons - full width, auto height based on aspect ratio */
.rarity-buttons .toggle-buttons-row {
  width: 100%;
  gap: 2px; /* Add 2px gap between buttons */
}

.rarity-buttons .toggle-button {
  flex: 1;
  aspect-ratio: 53 / 22; /* Maintain the original 53:22 aspect ratio */
  border-radius: 0;
  border-right: none; /* Remove vertical dividers */
  background: none; /* Remove white background */
}

.rarity-buttons .toggle-button img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  filter: grayscale(100%) opacity(0.6); /* Gray and semi-transparent when inactive */
  transition: filter 0.2s ease;
}

.rarity-buttons .toggle-button.active img {
  filter: grayscale(0%) opacity(1); /* Full color and opacity when active */
}

.rarity-buttons .toggle-button:hover {
  background: #f0f0f0; /* Light gray background only on hover */
}

.rarity-buttons .toggle-button:hover img {
  filter: grayscale(100%) opacity(0.8); /* Slightly less gray on hover */
}

/* Type buttons - no border, minimal gap, square aspect ratio */
.type-buttons .toggle-buttons-row {
  width: 100%;
  gap: 1px;
  flex-wrap: wrap;
}

.type-buttons .toggle-button {
  flex: 1;
  border: none;
  border-radius: 0;
  aspect-ratio: 1; /* Makes it square */
  min-width: 0; /* Allows flex items to shrink below content size */
}

.type-buttons .toggle-button img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  filter: grayscale(100%) opacity(0.6); /* Gray and semi-transparent when inactive */
  transition: filter 0.2s ease;
}

.type-buttons .toggle-button.active img {
  filter: grayscale(0%) opacity(1); /* Full color and opacity when active */
}

.type-buttons .toggle-button:hover img {
  filter: grayscale(100%) opacity(0.8); /* Slightly less gray on hover */
}

/* Ensure images maintain aspect ratio */
.toggle-button img {
  display: block;
  max-width: 100%;
  max-height: 100%;
}

/* Clear Filters Button - Top of sidebar */
#clearFiltersBtn {
  width: 100%;
  max-width: 180px;
  margin-bottom: 0; /* Remove bottom margin since we use gap */
}

/* Clear All Button - Right sidebar */
.slots-header .clear-all {
  width: calc(var(--card-w) * 2 + var(--gap) * 1); /* Same width as two slots */
  margin-bottom: 0; /* Remove bottom margin since we use gap */
}

/* Skill Search Group */
#skillSearchGroup {
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}

#skillSearchGroup label {
  margin-bottom: 0px;
  font-weight: 600;
  font-size: 13px;
}

/* Thin divider between strategy and skill search */
.skill-search-divider {
  min-height: 1px;
  background: #333;
  margin: 4px 0;
  width: 100%;
  position: sticky;
  top: 0;
  z-index: 10;
}

/* Skill search header with Add button */
.skill-search-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0px;
}

.add-search-btn {
  font-size: 12px; /* Match Clear Filters button font size */
  cursor: pointer;
  border: none; /* Match Clear Filters button border */
  border-radius: 6px; /* Match Clear Filters button border radius */
  background: #444; /* Match Clear Filters button background */
  color: #fff; /* Match Clear Filters button text color */
  transition: background-color 0.2s; /* Match Clear Filters button transition */
  width: 48px;
  height: 24px; /* Let height be determined by padding + content */
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1; /* Ensure consistent line height */
}

.add-search-btn:hover {
  background: #333; /* Match Clear Filters button hover */
}

/* Individual search input container */
.search-input-container {
  display: flex;
  align-items: center;
  gap: 4px;
  width: 100%;
}

.search-input-container input {
  flex: 1;
  padding: 6px 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

.remove-search-btn {
  width: 24px;
  height: 24px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #f5f5f5;
  color: #666;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  flex-shrink: 0;
}

.remove-search-btn:hover {
  background: #e5e5e5;
  color: #333;
}

/* ---------- SLOTS STYLING ---------- */
.slots {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--gap);
  width: calc(var(--card-w) * 2 + var(--gap) * 1);
  margin: 0 auto;
}

.slot {
  border: 1px solid #ddd;
  padding: 8px;
  box-sizing: border-box;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  width: var(--card-w);
  min-height: var(--card-w);
  position: relative;
  transition: min-height 0.3s ease;
}

.slot:not(.has-card) {
  border: 2px dashed #ccc;
  background: #fafafa;
  aspect-ratio: 1;
  min-height: var(--card-w);
  height: var(--card-w);
}

.slot.has-card {
  min-height: calc(var(--card-w) * 2.2);
  aspect-ratio: auto;
  height: auto;
  /* Allow card to grow naturally with skills */
  max-height: none;
}

.slot .placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ccc;
  font-size: 11px;
}

/* ---------- CARDS STYLING ---------- */
.cards {
  display: grid;
  grid-template-columns: repeat(6, var(--card-w));
  gap: var(--gap);
  width: calc(var(--card-w) * 6 + var(--gap) * 5);
}

/* Card styles for both main content and slots */
.card, .slot.has-card {
  border: 1px solid #ddd;
  padding: 6px;
  box-sizing: border-box;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: var(--card-w);
  min-height: 180px;
  position: relative;
}

.card .name, .slot.has-card .name {
  margin: 6px 0 4px 0;
  font-weight: 700;
  text-align: center;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card img, .slot.has-card img {
  max-width: calc(var(--card-w) * 0.8); /* 80% of card width */
  max-height: calc(var(--card-w) * 0.8); /* 80% of card height */
  object-fit: contain;
}

.card .skills, .slot.has-card .skills,
.card .skills-group, .slot.has-card .skills-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 100%;
  align-items: center;
}

.card .skill, .slot.has-card .skill {
  width: 100%;
  background: #eef2ff;
  border-radius: 4px;
  padding: 2px 4px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
}

/* TYPE ICON */
.card .type-icon, .slot.has-card .type-icon {
  position: absolute;
  top: 0px;
  right: 0px;
  width: 32px;
  height: 32px;
  border: 1px solid #ccc;
  background: #fff;
  border-radius: 3px;
  overflow: hidden;
  text-align: center;
  font-size: 8px;
  line-height: 14px;
  font-weight: bold;
}

.card .type-icon img, .slot.has-card .type-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

/* ---------- SKILLS & HIGHLIGHTING ---------- */
.skill.search-highlighted {
  background: #ff4444 !important;
  color: white !important;
}

/* ---------- SKILLS HEADER STYLES ---------- */
.skills-header {
  font-size: 9px;
  font-weight: bold;
  margin-bottom: 0px;
  text-align: center;
  background: #000000;
  color: #ffffff;
  padding: 3px 4px;
  border-radius: 0;
  width: 100%;
}

/* ---------- PAGINATION CONTROLS ---------- */
.card-section {
  position: relative;
  width: 100%;
}

.card-section-header {
  position: relative;
  display: block;
  margin-top: 0px;
  margin-bottom: 10px;
  width: 100%;
}

.card-section-header h2 {
  margin: 0;
}

.page-controls {
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  gap: 8px;
}

.page-controls button {
  border: none;
  background: #444;
  color: #fff;
  border-radius: 6px;
  padding: 8px 12px; /* Match Clear All button padding */
  font-size: 12px;
  font-weight: bold;
  cursor: pointer;
  min-width: 32px;
  height: auto; /* Let height be determined by padding + content */
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
  line-height: 1; /* Ensure consistent line height */
}

.page-controls button:hover:not(:disabled) {
  background: #333;
}

.page-controls button:disabled {
  background: #999;
  color: #ccc;
  cursor: not-allowed;
}

/* Hide duplicates */
.card.disabled {
  opacity: 0.45;
}

/* CLEAR BUTTON */
.clear-all {
  padding: 8px 12px; /* Slightly more padding for better touch targets */
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
}

.clear-all:hover {
  background: #333;
}

/* CARD SECTIONS */
.card-sections {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  gap: 10px;
}

/* Sort Order Button */
.sort-order-btn {
  border: 1px solid #ccc;
  background: #f5f5f5;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

.sort-order-btn:hover {
  background: #e5e5e5;
  border-color: #999;
}

.sort-order-btn.ascending {
  background: #444;
  color: #fff;
  border-color: #444;
}

/* Remove margin from Hide Uncoloured Skills checkbox */
.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  margin-bottom: 0 !important; /* Add this line */
}

.checkbox-label input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
}

/* Skill hiding styles */
.skill.hidden-skill,
.skills-header.hidden-skill {
  display: none;
}

/* Fix gap when skills groups are hidden */
.skills-group.hidden-skill {
  display: none;
}

/* Adjust spacing for skills groups to remove gaps when headers are hidden */
.skills-group:not(.hidden-skill) + .skills-group:not(.hidden-skill) {
  margin-top: 8px; /* Add spacing only between visible groups */
}

/* Ensure the skills container properly collapses when groups are hidden */
.skills:empty,
.skills:has(.skills-group.hidden-skill:only-child),
.skills:has(.skills-group.hidden-skill:first-child + .skills-group.hidden-skill:last-child) {
  display: none;
}

/* Remove margin from the first visible skills group */
.skills-group:not(.hidden-skill):first-child {
  margin-top: 0;
}

/* Toggle Preset Cards Button */
#togglePresetCardsBtn {
  width: 100%;
  max-width: 180px;
  margin-bottom: 0; /* Remove bottom margin since we use gap */
}

</style>
</head>

<body>
<!-- Header -->
<div class="header">
  <div class="header-left">
    <img src="your-logo.png" alt="Logo" class="header-logo">
    <div class="header-title">Uma Builder</div>
  </div>
  <div class="header-nav">
    <!-- Navigation links are hidden -->
  </div>
</div>

  <div class="container">
<!-- Left Sidebar (Filters) -->
<div class="sidebar">
  <!-- Rarity Toggle Buttons -->
  <div class="toggle-button-group rarity-buttons">
    <label>Rarity</label>
    <div class="toggle-buttons-row">
      <button class="toggle-button" data-rarity="SSR">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_03.png" alt="SSR">
      </button>
      <button class="toggle-button" data-rarity="SR">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_02.png" alt="SR">
      </button>
      <button class="toggle-button" data-rarity="R">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_01.png" alt="R">
      </button>
    </div>
  </div>

  <!-- Type Toggle Buttons -->
  <div class="toggle-button-group type-buttons">
    <label>Type</label>
    <div class="toggle-buttons-row">
      <button class="toggle-button" data-type="speed">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_00.png" alt="Speed">
      </button>
      <button class="toggle-button" data-type="stamina">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_01.png" alt="Stamina">
      </button>
      <button class="toggle-button" data-type="power">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_02.png" alt="Power">
      </button>
      <button class="toggle-button" data-type="guts">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_03.png" alt="Guts">
      </button>
      <button class="toggle-button" data-type="intelligence">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_04.png" alt="Intelligence">
      </button>
      <button class="toggle-button" data-type="support">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_05.png" alt="Support">
      </button>
      <button class="toggle-button" data-type="group">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_06.png" alt="Group">
      </button>
    </div>
  </div>

<!-- ADD SORTING CONTROLS HERE -->
<div class="filter-group">
  <label for="sortBy">Sort By</label>
  <div style="display: flex; gap: 6px; align-items: center;">
    <select id="sortBy" style="flex: 1;">
      <option value="rarity">Rarity</option>
      <option value="name">Name</option>
      <option value="type">Type</option>
      <option value="release">Release Date</option>
      <option value="support_id">Game ID Number</option>
    </select>
    <button id="sortOrder" class="sort-order-btn ascending" style="width: 32px; height: 32px; border: 1px solid #ccc; background: #444; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; border-radius: 4px; flex-shrink: 0;">
      ↑
    </button>
  </div>
</div>

<div class="filter-group">
  <label for="region">Region</label>
  <select id="region">
    <option value="global">Global</option>
    <option value="japan">Japan</option>
  </select>
</div>

<!-- ADD THIS CHECKBOX -->
<div class="filter-group">
  <label class="checkbox-label">
    <input type="checkbox" id="hideUncolored">
    Hide Uncoloured Skills
  </label>
</div>

  <!-- ADD THIS DIVIDER -->
  <div class="skill-search-divider"></div>

  <!-- Add this right after the Clear Filters button -->
<button id="togglePresetCardsBtn" class="clear-all">Toggle Preset Cards</button>

  <!-- Clear Filters Button at top -->
  <button id="clearFiltersBtn" class="clear-all clear-filters-top">Clear Filters</button>

  <div class="filter-group">
    <label for="presets">Presets</label>
    <select id="presets">
      <option value="">-- Select --</option>
    </select>
  </div>

      <div class="filter-group">
        <label for="racecourse">Racecourse</label>
        <select id="racecourse">
          <option value="">-- Select --</option>
          <option value="Sapporo">Sapporo</option>
          <option value="Hakodate">Hakodate</option>
          <option value="Niigata">Niigata</option>
          <option value="Fukushima">Fukushima</option>
          <option value="Nakayama">Nakayama</option>
          <option value="Tokyo">Tokyo</option>
          <option value="Chukyo">Chukyo</option>
          <option value="Kyoto">Kyoto</option>
          <option value="Hanshin">Hanshin</option>
          <option value="Kokura">Kokura</option>
          <option value="Oi">Oi</option>
          <option value="Kawasaki">Kawasaki</option>
          <option value="Funabashi">Funabashi</option>
          <option value="Morioka">Morioka</option>
          <option value="Longchamp">Longchamp</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="length">Length</label>
        <select id="length">
          <option value="">-- Select --</option>
          <option value="1000">1000m</option>
          <option value="1150">1150m</option>
          <option value="1200">1200m</option>
          <option value="1300">1300m</option>
          <option value="1400">1400m</option>
          <option value="1500">1500m</option>
          <option value="1600">1600m</option>
          <option value="1700">1700m</option>
          <option value="1800">1800m</option>
          <option value="1900">1900m</option>
          <option value="2000">2000m</option>
          <option value="2100">2100m</option>
          <option value="2200">2200m</option>
          <option value="2300">2300m</option>
          <option value="2400">2400m</option>
          <option value="2500">2500m</option>
          <option value="2600">2600m</option>
          <option value="3000">3000m</option>
          <option value="3200">3200m</option>
          <option value="3400">3400m</option>
          <option value="3600">3600m</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="direction">Direction</label>
        <select id="direction">
          <option value="">-- Select --</option>
          <option value="Clockwise">Clockwise</option>
          <option value="Counterclockwise">Counterclockwise</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="track">Track Conditions</label>
        <select id="track">
          <option value="">-- Select --</option>
          <option value="Firm">Firm</option>
          <option value="Good">Good</option>
          <option value="Soft">Soft</option>
          <option value="Heavy">Heavy</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="season">Season</label>
        <select id="season">
          <option value="">-- Select --</option>
          <option value="Spring">Spring</option>
          <option value="Summer">Summer</option>
          <option value="Fall">Autumn</option>
          <option value="Winter">Winter</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="weather">Weather</label>
        <select id="weather">
          <option value="">-- Select --</option>
          <option value="Sunny">Sunny</option>
          <option value="Cloudy">Cloudy</option>
          <option value="Rainy">Rain</option>
          <option value="Snowy">Snow</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="strategy">Strategy</label>
        <select id="strategy">
          <option value="">-- Select --</option>
          <option value="Front Runner">Front Runner</option>
          <option value="Pace Chaser">Pace Chaser</option>
          <option value="Late Surger">Late Surger</option>
          <option value="End Closer">End Closer</option>
        </select>
      </div>

      <!-- Thin divider -->
      <div class="skill-search-divider"></div>

      <!-- Skill Search Section -->
      <div id="skillSearchGroup">
        <div class="skill-search-header">
          <label for="skillSearch1">Skill Search</label>
          <button class="add-search-btn" id="addSearchBtn">Add</button>
        </div>
        
        <!-- Default search box -->
        <div class="search-input-container">
          <input type="text" id="skillSearch1" class="skill-search" placeholder="Search skill">
          <button class="remove-search-btn" data-search-id="skillSearch1">×</button>
        </div>
        
        <!-- Additional search boxes will be added here dynamically -->
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <div class="content-wrapper">
        <div id="cardSections" class="card-sections"></div>
      </div>
    </div>

    <!-- Right Sidebar (Slots) -->
    <div class="right-sidebar">
      <div class="slots-header">
        <button class="clear-all" id="clearAllBtn">Clear All</button>
      </div>

      <div class="slots" id="slots">
        <div class="slot" data-slot="0"><div class="placeholder">Empty</div></div>
        <div class="slot" data-slot="1"><div class="placeholder">Empty</div></div>
        <div class="slot" data-slot="2"><div class="placeholder">Empty</div></div>
        <div class="slot" data-slot="3"><div class="placeholder">Empty</div></div>
        <div class="slot" data-slot="4"><div class="placeholder">Empty</div></div>
        <div class="slot" data-slot="5"><div class="placeholder">Empty</div></div>
      </div>
    </div>
  </div>

<script>
/* ------------- CONFIG ------------- */
const JSON_FILE = "transformed_supports.json";
const HIDE = { char_id: false, url_name: true };

/* ------------- STATE ------------- */
let cardsData = [];
const cardSections = document.getElementById('cardSections');
const slots = Array.from(document.querySelectorAll('.right-sidebar .slot'));
const clearAllBtn = document.getElementById('clearAllBtn');
const clearFiltersBtn = document.getElementById('clearFiltersBtn');
const selectedCardIds = new Set();
const sectionPages = new Map();
const slotListeners = new Map();
const SLOT_KEY = 'saved_slots';
const FILTER_KEYS = ['racecourse','length','direction','track','season','weather','strategy'];
let SKILL_SEARCH_KEYS = ['skillSearch1']; // Initialize as let so it can be updated
let showPresetCards = true; // Start with preset cards visible

/* ------------- TOGGLE BUTTON STATE ------------- */
const selectedRarities = new Set();
const selectedTypes = new Set();

/* ------------- NEW STATE VARIABLES ------------- */
let hideUncolored = false;
let sortBy = 'rarity';
let sortOrder = 'descending'; // CHANGED TO DESCENDING
let region = 'global';

/* ------------- SORTING FUNCTION ------------- */
function sortCards(cards, sortBy, order) {
  const sortedCards = [...cards];
  
  sortedCards.sort((a, b) => {
    let aValue, bValue;
    
    switch (sortBy) {
      case 'rarity':
        if (a.rarity !== b.rarity) {
          return order === 'ascending' ? a.rarity - b.rarity : b.rarity - a.rarity;
        }
        // If same rarity, sort by appropriate release date
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'name':
        aValue = a.char_name.toLowerCase();
        bValue = b.char_name.toLowerCase();
        
        // First, compare by name based on the sort order
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        // If names are exactly the same, ALWAYS sort by rarity descending (SSR first)
        return b.rarity - a.rarity; // SSR > SR > R always
        
      case 'type':
        aValue = a.type;
        bValue = b.type;
        
        // First, compare by type based on the sort order
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        // If types are exactly the same, ALWAYS sort by rarity descending (SSR first)
        return b.rarity - a.rarity; // SSR > SR > R always
        
      case 'release':
        // Use appropriate release date based on region
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'support_id':
        aValue = a.support_id;
        bValue = b.support_id;
        break;
        
      default:
        return 0;
    }
    
    // Handle empty values
    if (!aValue && bValue) return order === 'ascending' ? -1 : 1;
    if (aValue && !bValue) return order === 'ascending' ? 1 : -1;
    if (!aValue && !bValue) return 0;
    
    // For dates, convert to timestamps for proper comparison
    if (sortBy === 'release' || (sortBy === 'rarity' && a.rarity === b.rarity)) {
      try {
        const aDate = new Date(aValue);
        const bDate = new Date(bValue);
        if (isNaN(aDate.getTime()) && !isNaN(bDate.getTime())) return order === 'ascending' ? -1 : 1;
        if (!isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return order === 'ascending' ? 1 : -1;
        if (isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return 0;
        
        aValue = aDate.getTime();
        bValue = bDate.getTime();
      } catch (e) {
        console.warn('Date parsing failed for:', aValue, bValue);
      }
    }
    
    // Compare values
    if (aValue < bValue) return order === 'ascending' ? -1 : 1;
    if (aValue > bValue) return order === 'ascending' ? 1 : -1;
    return 0;
  });
  
  return sortedCards;
}

/* ------------- DYNAMIC SKILL SEARCH ------------- */
let searchCounter = 1;
const maxSearches = 30;

function setupDynamicSkillSearch() {
  const addSearchBtn = document.getElementById('addSearchBtn');
  
  // Set up the first search box
  setupSearchInput('skillSearch1');
  setupRemoveButton('skillSearch1');
  
  addSearchBtn.addEventListener('click', addSearchBox);
}

function addSearchBox() {
  if (SKILL_SEARCH_KEYS.length >= maxSearches) return;

  // Find the next available ID
  let newId;
  let attempt = 1;
  do {
    newId = `skillSearch${searchCounter + attempt}`;
    attempt++;
  } while (SKILL_SEARCH_KEYS.includes(newId) && attempt < 100);
  
  searchCounter = Math.max(searchCounter, parseInt(newId.replace('skillSearch', '')) || searchCounter);
  SKILL_SEARCH_KEYS.push(newId);

  const searchContainer = document.createElement('div');
  searchContainer.className = 'search-input-container';
  searchContainer.innerHTML = `
    <input type="text" id="${newId}" class="skill-search" placeholder="Search skill">
    <button class="remove-search-btn" data-search-id="${newId}">×</button>
  `;

  const skillSearchGroup = document.getElementById('skillSearchGroup');
  skillSearchGroup.appendChild(searchContainer);

  setupSearchInput(newId);
  setupRemoveButton(newId);

  // Update localStorage with empty value for new search
  localStorage.setItem('filter_' + newId, '');
  
  // Update search counter to avoid duplicates
  searchCounter++;
}

function setupSearchInput(searchId) {
  const input = document.getElementById(searchId);
  if (!input) return;

  // Load saved value
  const saved = localStorage.getItem('filter_' + searchId);
  if (saved) input.value = saved;

  // Set up input event
  input.addEventListener('input', () => {
    localStorage.setItem('filter_' + searchId, input.value);
    sectionPages.clear();
    renderSections();
  });
}

function setupRemoveButton(searchId) {
  const removeBtn = document.querySelector(`.remove-search-btn[data-search-id="${searchId}"]`);
  if (!removeBtn) return;

  // Remove any existing listeners to prevent duplicates
  const newRemoveBtn = removeBtn.cloneNode(true);
  removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);

  newRemoveBtn.addEventListener('click', () => {
    removeSearchBox(searchId);
  });
}

function removeSearchBox(searchId) {
  const container = document.querySelector(`.search-input-container input[id="${searchId}"]`)?.parentElement;
  if (container) {
    container.remove();
  }

  // Remove from SKILL_SEARCH_KEYS array
  SKILL_SEARCH_KEYS = SKILL_SEARCH_KEYS.filter(id => id !== searchId);

  // Remove from localStorage
  localStorage.removeItem('filter_' + searchId);

  // If no search boxes left, add one back
  if (SKILL_SEARCH_KEYS.length === 0) {
    // Reset to just the first search box
    SKILL_SEARCH_KEYS = ['skillSearch1'];
    searchCounter = 2;
    
    const skillSearchGroup = document.getElementById('skillSearchGroup');
    const searchContainer = document.createElement('div');
    searchContainer.className = 'search-input-container';
    searchContainer.innerHTML = `
      <input type="text" id="skillSearch1" class="skill-search" placeholder="Search skill">
      <button class="remove-search-btn" data-search-id="skillSearch1">×</button>
    `;
    
    // Remove all existing search containers except the header
    const existingContainers = skillSearchGroup.querySelectorAll('.search-input-container');
    existingContainers.forEach(container => container.remove());
    
    skillSearchGroup.appendChild(searchContainer);
    setupSearchInput('skillSearch1');
    setupRemoveButton('skillSearch1');
    localStorage.setItem('filter_skillSearch1', '');
  } else {
    // Update search counter to the highest existing ID + 1
    const maxId = Math.max(...SKILL_SEARCH_KEYS.map(id => parseInt(id.replace('skillSearch', '')) || 0));
    searchCounter = maxId + 1;
  }

  sectionPages.clear();
  renderSections();
}

function removeFromSlot(slotEl, card){
  if(slotListeners.has(slotEl)){
    slotEl.removeEventListener('click', slotListeners.get(slotEl));
    slotListeners.delete(slotEl);
  }
  
  slotEl.classList.remove('has-card');
  delete slotEl.dataset.cardId;
  delete slotEl.dataset.supportId;
  slotEl.innerHTML='<div class="placeholder">Empty</div>';
  
  // Remove from selectedCardIds using the actual card's char_id
  if (card && card.char_id) {
    selectedCardIds.delete(Number(card.char_id));
  } else if (slotEl.dataset.cardId) {
    // Fallback: try to get char_id from slot data
    selectedCardIds.delete(Number(slotEl.dataset.cardId));
  }
  
  saveSlotsToLocalStorage();
  renderSections();
}

/* ------------- TOGGLE BUTTON SETUP ------------- */
function setupToggleButtons() {
  // Rarity buttons
  document.querySelectorAll('.rarity-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const rarity = button.dataset.rarity;
      if (selectedRarities.has(rarity)) {
        selectedRarities.delete(rarity);
        button.classList.remove('active');
      } else {
        selectedRarities.add(rarity);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });

  // Type buttons
  document.querySelectorAll('.type-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const type = button.dataset.type;
      if (selectedTypes.has(type)) {
        selectedTypes.delete(type);
        button.classList.remove('active');
      } else {
        selectedTypes.add(type);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- UTIL ------------- */
function normalizeSkill(s){ return String(s||'').replace(/[◎○]/g,'').trim().toLowerCase(); }
function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase(); }
function getLengthCategory(distance){ if(distance<=1400)return'Sprint'; if(distance<=1800)return'Mile'; if(distance<=2400)return'Medium'; return'Long'; }
function isStandardDistance(distance){ return distance%400===0; }
const typeMap = { "speed":"00","stamina":"01","power":"02","guts":"03","intelligence":"04","support":"05","group":"06" };
function escapeHtml(s){ return String(s).replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

/* ------------- AUTO-RESET PRESETS ------------- */
function setupPresetReset() {
  // Get all filter elements that should reset presets
  const resetFilters = [
    'racecourse', 'length', 'direction', 'track', 'season', 'weather'
  ];
  
  resetFilters.forEach(filterId => {
    const element = document.getElementById(filterId);
    if (element) {
      element.addEventListener('change', () => {
        // Only reset if the filter actually has a value selected
        if (element.value) {
          const presetsSelect = document.getElementById('presets');
          if (presetsSelect && presetsSelect.value) {
            presetsSelect.value = '';
            localStorage.removeItem('filter_presets');
          }
        }
      });
    }
  });
}

/* ------------- Fetch JSON ------------- */
fetch(JSON_FILE)
  .then(r => { 
    if (!r.ok) throw new Error(`Failed to fetch JSON: ${r.status} ${r.statusText}`); 
    return r.json(); 
  })
  .then(data => {
    if (!Array.isArray(data)) {
      throw new Error('JSON data is not an array');
    }
    
    cardsData = data.map(card => ({
      ...card,
      char_id: card.char_id || 0,
      char_name: card.char_name || 'Unknown',
      hint_skills: card.hint_skills || [],
      event_skills: card.event_skills || [],
      event_skills_en: card.event_skills_en || [],
      rarity: card.rarity || 1,
      release: card.release || '',
      release_en: card.release_en || '',
      support_id: card.support_id || 0,
      type: (card.type || '').toLowerCase(),
      url_name: card.url_name || ''
    }));

    setupFilterPersistence();
    setupToggleButtons();
    setupSortingControls();
    setupDynamicSkillSearch();
    setupPresets();
    setupPresetReset();
    setupTogglePresetCards(); // ADD THIS LINE
    loadSlotsFromLocalStorage();
    renderSections();
  })
  .catch(err => {
    console.error('Could not load JSON:', err);
    cardSections.innerHTML = `
      <div style="opacity:0.7;padding:12px;text-align:center;">
        <h3>Error loading data</h3>
        <p>${err.message}</p>
        <p>Check browser console for details.</p>
      </div>
    `;
  });

/* ------------- PRESETS ------------- */
const PRESETS_JSON_FILE = "champions_meeting.json";

let presetRaceNumbers = new Map(); // Store race numbers by title

function formatPresetDate(dateString) {
  const date = new Date(dateString);
  const month = date.toLocaleString('en-US', { month: 'short' });
  const year = date.getFullYear();
  return `${month} ${year}`;
}

function createPresetLabel(cup, index) {
  const distance = cup.distance === "Mile" ? "MILE" : cup.distance;
  const trackType = cup.aptitude === "Turf" ? "Turf" : "Dirt";
  const length = cup.length.replace(/\s*m/g, 'm');
  
  // Store the race number for this cup title
  presetRaceNumbers.set(cup.title, index + 1);
  
  return `${index + 1}. ${cup.title} — ${cup.racecourse} ${trackType} ${length} ${cup.track_conditions}`;
}

function setupPresets() {
  const presetsSelect = document.getElementById('presets');
  if (!presetsSelect) return;

  const savedPreset = localStorage.getItem('filter_presets');

  fetch(PRESETS_JSON_FILE)
    .then(response => {
      if (!response.ok) throw new Error('Failed to fetch presets JSON');
      return response.json();
    })
    .then(data => {
      presetsSelect.innerHTML = '<option value="">-- Select --</option>';
      
      // Sort cups by start_date to ensure proper numbering
      const sortedCups = data.cups.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
      
      sortedCups.forEach((cup, index) => {
        const option = document.createElement('option');
        option.value = cup.title;
        option.textContent = createPresetLabel(cup, index);
        option.dataset.cupData = JSON.stringify(cup);
        presetsSelect.appendChild(option);
      });
      
      if (savedPreset) presetsSelect.value = savedPreset;
      
      presetsSelect.addEventListener('change', function() {
        localStorage.setItem('filter_presets', this.value);
        
        if (this.value) {
          const selectedOption = this.options[this.selectedIndex];
          const cup = JSON.parse(selectedOption.dataset.cupData);
          applyPreset(cup);
        } else {
          sectionPages.clear();
          renderSections();
        }
      });
    })
    .catch(err => {
      console.error('Could not load presets:', err);
      const option = document.createElement('option');
      option.textContent = 'Error loading presets';
      option.disabled = true;
      presetsSelect.appendChild(option);
    });
}

function applyPreset(cup) {
  document.getElementById('racecourse').value = cup.racecourse;
  document.getElementById('length').value = cup.length.replace(' m', '');
  document.getElementById('direction').value = cup.direction;
  document.getElementById('track').value = cup.track_conditions;
  
  // Fix season mapping: JSON has "Autumn" but dropdown uses "Fall"
  const seasonMap = {
    'Autumn': 'Fall', // Map JSON "Autumn" to dropdown "Fall"
    'Spring': 'Spring', 
    'Summer': 'Summer',
    'Winter': 'Winter'
  };
  document.getElementById('season').value = seasonMap[cup.season] || cup.season;
  
  // Fix weather mapping: JSON has "Rain"/"Snow" but dropdown uses "Rainy"/"Snowy"
  const weatherMap = {
    'Rain': 'Rainy', // Map JSON "Rain" to dropdown "Rainy"
    'Snow': 'Snowy', // Map JSON "Snow" to dropdown "Snowy"
    'Sunny': 'Sunny',
    'Cloudy': 'Cloudy'
  };
  document.getElementById('weather').value = weatherMap[cup.weather] || cup.weather;
  
  document.getElementById('strategy').value = '';
  
  FILTER_KEYS.forEach(id => {
    const el = document.getElementById(id);
    if (el && el.value) localStorage.setItem('filter_' + id, el.value);
  });
  
  sectionPages.clear();
  renderSections();
}

FILTER_KEYS.push('presets');

/* ------------- SETUP NEW CONTROLS ------------- */
function setupSortingControls() {
  const sortBySelect = document.getElementById('sortBy');
  const sortOrderBtn = document.getElementById('sortOrder');
  const regionSelect = document.getElementById('region');

  // Load saved values
  const savedSortBy = localStorage.getItem('sortBy');
  const savedSortOrder = localStorage.getItem('sortOrder');
  const savedRegion = localStorage.getItem('region');

  if (savedSortBy) {
    sortBy = savedSortBy;
    sortBySelect.value = savedSortBy;
  } else {
    // SET DEFAULT TO RARITY
    sortBySelect.value = 'rarity';
  }
  
  if (savedSortOrder) {
    sortOrder = savedSortOrder;
    sortOrderBtn.textContent = sortOrder === 'ascending' ? '↑' : '↓';
    sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
  } else {
    // SET DEFAULT TO DESCENDING
    sortOrder = 'descending';
    sortOrderBtn.textContent = '↓';
    sortOrderBtn.classList.remove('ascending');
  }
  
  if (savedRegion) {
    region = savedRegion;
    regionSelect.value = savedRegion;
  } else {
    // SET DEFAULT TO GLOBAL
    regionSelect.value = 'global';
  }

  // Event listeners
  sortBySelect.addEventListener('change', (e) => {
    sortBy = e.target.value;
    localStorage.setItem('sortBy', sortBy);
    sectionPages.clear();
    renderSections();
  });

  sortOrderBtn.addEventListener('click', () => {
    sortOrder = sortOrder === 'ascending' ? 'descending' : 'ascending';
    sortOrderBtn.textContent = sortOrder === 'ascending' ? '↑' : '↓';
    sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
    localStorage.setItem('sortOrder', sortOrder);
    sectionPages.clear();
    renderSections();
  });

  regionSelect.addEventListener('change', (e) => {
    region = e.target.value;
    localStorage.setItem('region', region);
    sectionPages.clear();
    renderSections();
  });
}

// Setup Hide Uncolored checkbox
function setupHideUncoloredCheckbox() {
  const hideUncoloredCheckbox = document.getElementById('hideUncolored');
  const savedHideUncolored = localStorage.getItem('hideUncolored');

  if (savedHideUncolored) {
    hideUncolored = savedHideUncolored === 'true';
    hideUncoloredCheckbox.checked = hideUncolored;
  }

  hideUncoloredCheckbox.addEventListener('change', (e) => {
    hideUncolored = e.target.checked;
    localStorage.setItem('hideUncolored', hideUncolored);
    updateSkillVisibility(); // Update visibility when checkbox changes
  });
}

/* ------------- UPDATED CARD CREATION WITH BETTER ERROR HANDLING ------------- */
function createCardElement(card){
  const el = document.createElement('div');
  el.className = 'card';
  el.dataset.id = card.char_id;
  el.dataset.supportId = card.support_id;
  el.dataset.name = card.char_name;

  const imgSrc = `https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png`;
  const typeImg = `https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type]||"xx"}.png`;

  // Use English skills for Global region, Japanese skills for Japan region
  // Fall back to Japanese skills if English skills are empty
  const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
  const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

  let skillsHTML = '';
  
  // FIX: Handle hint_skills with safe string conversion
  if(card.hint_skills && card.hint_skills.length) {
    const hintSkillsHTML = card.hint_skills.map(s => {
      const skillText = String(s || ''); // Ensure it's a string
      return `<div class="skill">${escapeHtml(skillText.replace(/○\s*/g, ''))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
  }
  
  // FIX: Handle event skills with safe string conversion
  if(eventSkillsToUse && eventSkillsToUse.length) {
    const eventSkillsHTML = eventSkillsToUse.map(s => {
      const skillText = String(s || ''); // Ensure it's a string
      return `<div class="skill">${escapeHtml(skillText.replace(/○\s*/g, ''))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
  }
  
  let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;
  if(!HIDE.char_id) nameHtml += `<div style="font-size:9px;opacity:0.6;margin-bottom: 6px;">ID: ${card.char_id}</div>`;
  if(!HIDE.url_name && card.url_name) nameHtml += `<div style="font-size:9px;opacity:0.6;">${escapeHtml(card.url_name)}</div>`;

  el.innerHTML = `
    <div class="type-icon"><img src="${typeImg}" alt="${escapeHtml(card.type)}"></div>
    <img src="${imgSrc}" alt="${escapeHtml(card.char_name)}">
    ${nameHtml}
    <div class="skills">${skillsHTML}</div>
  `;

  el.addEventListener('click', ()=> {
    const slot = slots.find(s => Number(s.dataset.cardId) === card.char_id);
    if(slot) removeFromSlot(slot, card);
    else addToSlot(card);
  });

  if(selectedCardIds.has(card.char_id)){
    el.classList.add('disabled');
    const dupLabel = document.createElement('div');
    dupLabel.textContent = 'Duplicate Support';
    dupLabel.style.position = 'absolute';
    dupLabel.style.top = '0';
    dupLabel.style.left = '0';
    dupLabel.style.width = '100%';
    dupLabel.style.background = 'red';
    dupLabel.style.color = 'white';
    dupLabel.style.fontSize = '9px';
    dupLabel.style.fontWeight = 'bold';
    dupLabel.style.textAlign = 'center';
    dupLabel.style.padding = '2px 0';
    dupLabel.style.borderTopLeftRadius = '4px';
    dupLabel.style.borderTopRightRadius = '4px';
    el.appendChild(dupLabel);
  }

  return el;
}

/* ------------- Slot handling & persistence ------------- */
function saveSlotsToLocalStorage() {
  const slotData = slots.map(s => s.dataset.supportId || null);
  localStorage.setItem(SLOT_KEY, JSON.stringify(slotData));
}

function loadSlotsFromLocalStorage() {
  const saved = localStorage.getItem(SLOT_KEY);
  if (!saved) return;
  const slotData = JSON.parse(saved);

  slotData.forEach((supportId, index) => {
    if (supportId) {
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      if (card) addToSlot(card, slots[index], false);
    }
  });
  
  // NEW: Apply highlighting to all loaded slot skills
  highlightSkills();
}

function addToSlot(card, targetSlot = null, save = true){
  const freeSlot = targetSlot || slots.find(s => !s.dataset.cardId);
  if(!freeSlot) return;

  // Remove existing listener if any
  if(slotListeners.has(freeSlot)){
    freeSlot.removeEventListener('click', slotListeners.get(freeSlot));
    slotListeners.delete(freeSlot);
  }

  // Use English skills for Global region, Japanese skills for Japan region
  // Fall back to Japanese skills if English skills are empty
  const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
  const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

  let skillsHTML = '';
  
  // Only add skills groups if there are skills to show
  if(card.hint_skills && card.hint_skills.length) {
    const hintSkillsHTML = card.hint_skills.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(skillText.replace(/○\s*/g, ''))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
  }
  
  if(eventSkillsToUse && eventSkillsToUse.length) {
    const eventSkillsHTML = eventSkillsToUse.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(skillText.replace(/○\s*/g, ''))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
  }

  freeSlot.dataset.cardId = card.char_id;
  freeSlot.dataset.supportId = card.support_id;
  freeSlot.classList.add('has-card');
  
  // Use compact styling for slots
  freeSlot.innerHTML = `
    <div class="type-icon"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type]||"xx"}.png" alt="${escapeHtml(card.type)}"></div>
    <img src="https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png" alt="${escapeHtml(card.char_name)}">
    <div class="name">${escapeHtml(card.char_name)}</div>
    <div class="skills">${skillsHTML}</div>
  `;

  // Create and attach the click handler - store the actual card object
  const slotCard = {...card}; // Create a copy to avoid reference issues
  
  function slotClickHandler(){ 
    removeFromSlot(freeSlot, slotCard); 
  }
  
  // Attach the event listener to the slot element
  freeSlot.addEventListener('click', slotClickHandler);
  slotListeners.set(freeSlot, slotClickHandler);

  selectedCardIds.add(card.char_id);
  if(save) saveSlotsToLocalStorage();
  
  // NEW: Apply highlighting to the slot skills immediately
  highlightSkills();
  renderSections();
}

/* ------------- Clear buttons ------------- */
clearAllBtn.addEventListener('click', ()=>{
  selectedCardIds.clear();
  slots.forEach(slot=>{
    if(slotListeners.has(slot)){
      slot.removeEventListener('click', slotListeners.get(slot));
      slotListeners.delete(slot);
    }
    slot.classList.remove('has-card');
    delete slot.dataset.cardId;
    slot.innerHTML='<div class="placeholder">Empty</div>';
  });
  localStorage.removeItem(SLOT_KEY);
  renderSections();
});

clearFiltersBtn.addEventListener('click', () => {
  FILTER_KEYS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
    localStorage.removeItem('filter_' + id);
  });

  // Reset toggle preset cards to default (show all)
  showPresetCards = true;
  localStorage.setItem('showPresetCards', 'true');
  updateTogglePresetCardsButton();

  // Clear skill searches - completely reset to just one clean search box
const skillSearchGroup = document.getElementById('skillSearchGroup');
const searchContainers = skillSearchGroup.querySelectorAll('.search-input-container');

// Remove ALL existing search containers
searchContainers.forEach(container => container.remove());

// Reset to just the first search box with fresh setup
SKILL_SEARCH_KEYS = ['skillSearch1'];
searchCounter = 2;

// Create a fresh first search box
const firstSearchContainer = document.createElement('div');
firstSearchContainer.className = 'search-input-container';
firstSearchContainer.innerHTML = `
  <input type="text" id="skillSearch1" class="skill-search" placeholder="Search skill">
  <button class="remove-search-btn" data-search-id="skillSearch1">×</button>
`;

skillSearchGroup.appendChild(firstSearchContainer);

// Set up the fresh search box
setupSearchInput('skillSearch1');
setupRemoveButton('skillSearch1');
localStorage.setItem('filter_skillSearch1', '');

// Clear toggle buttons (rarity and type)
selectedRarities.clear();
selectedTypes.clear();
document.querySelectorAll('.toggle-button').forEach(button => {
  button.classList.remove('active');
});

// DO NOT clear sorting and region controls - keep them as they are
// sortBy and region variables remain unchanged
// localStorage for sortBy, sortOrder, and region remain unchanged
  
  const presetsSelect = document.getElementById('presets');
  if (presetsSelect) presetsSelect.value = '';
  sectionPages.clear();
  renderSections();
  updateSkillVisibility(); // Still update visibility to reflect cleared filters
});

/* ------------- Filter persistence ------------- */
function setupFilterPersistence(){
  FILTER_KEYS.forEach(id=>{
    const el=document.getElementById(id); if(!el)return;
    const saved=localStorage.getItem('filter_'+id); if(saved) el.value=saved;
    el.addEventListener('change', ()=>{
      localStorage.setItem('filter_'+id, el.value);
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- CONCISE HIGHLIGHTING LOGIC ------------- */
function highlightSkills() {
  // Process ALL skills (both in main content and slots)
  document.querySelectorAll('.skill').forEach(skill => {
    skill.classList.remove('highlighted', 'search-highlighted');
    skill.style.background = '#eef2ff';
    skill.style.color = '#000';
  });

  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

  const searchTerms = SKILL_SEARCH_KEYS
    .map(id => document.getElementById(id)?.value.trim().toLowerCase())
    .filter(Boolean);

  const colorMap = {
    racecourse: '#ff7792', length: '#ffae77', direction: '#ffff77',
    track: '#77ff92', season: '#77c9ff', weather: '#c977ff', strategy: '#ff77e4'
  };

  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },
      { term: `${s} Straightaways`, color: colorMap.strategy },
      { term: `${s} Savvy`, color: colorMap.strategy }
    );
  }
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },
      { term: `${label} Straightaways`, color: colorMap.length },
      { term: distType, color: colorMap.length }
    );
  }

  document.querySelectorAll('.skill').forEach(skill => {
    const skillText = normalizeSkill(skill.textContent || '');
    
    if (searchTerms.some(term => skillText.includes(term))) {
      skill.classList.add('search-highlighted');
      return;
    }
    
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skill.style.background = color;
        skill.style.color = '#000';
        skill.classList.add('highlighted');
        break;
      }
    }
  });

  // NEW: Update skill visibility for ALL skills (main content and slots)
  updateSkillVisibility();
}

function updateSkillVisibility() {
  const shouldHide = hideUncolored;
  
  // Process ALL skills (both in main content and slots)
  document.querySelectorAll('.skill').forEach(skill => {
    const isHighlighted = skill.classList.contains('highlighted') || 
                         skill.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skill.classList.add('hidden-skill');
    } else {
      skill.classList.remove('hidden-skill');
    }
  });
  
  // Hide empty headers AND entire groups when hiding uncolored skills
  document.querySelectorAll('.skills-group').forEach(group => {
    const skills = group.querySelectorAll('.skill');
    const visibleSkills = Array.from(skills).filter(skill => !skill.classList.contains('hidden-skill'));
    
    const header = group.querySelector('.skills-header');
    if (header) {
      if (shouldHide && visibleSkills.length === 0) {
        header.classList.add('hidden-skill');
        group.classList.add('hidden-skill'); // Hide the entire group
      } else {
        header.classList.remove('hidden-skill');
        group.classList.remove('hidden-skill'); // Show the entire group
      }
    }
  });
  
  // Also handle the case where there are no skills groups but skills are directly under .skills
  document.querySelectorAll('.skills').forEach(skillsContainer => {
    const directSkills = skillsContainer.querySelectorAll(':scope > .skill');
    if (directSkills.length > 0) {
      const visibleDirectSkills = Array.from(directSkills).filter(skill => !skill.classList.contains('hidden-skill'));
      // Handle direct skills if needed
    }
  });
}

/* ------------- FILTER BUILDING & MATCHING ------------- */
function buildFilterTerms(filters){
  const terms=[];
  if(filters.racecourse) terms.push(`${filters.racecourse} Racecourse`);
  if(filters.direction) terms.push(filters.direction==='Clockwise'?'Right-Handed':'Left-Handed');
  if(filters.track) terms.push(filters.track==='Firm'?'Firm Conditions':'Wet Conditions');
  
  // Handle season - dropdown uses "Fall" but skills use "Fall Runner"
  if(filters.season) {
    terms.push(`${filters.season} Runner`);
  }
  
  // Handle weather - dropdown uses "Rainy"/"Snowy" but skills use "Rainy Days"/"Snowy Days"
  if(filters.weather) {
    terms.push(`${filters.weather} Days`);
  }
  
  if(filters.strategy){
    const s=filters.strategy;
    terms.push(`${s} Corners`,`${s} Straightaways`,`${s} Savvy`);
  }
  if(filters.length){
    const dist=parseInt(filters.length);
    const label=getLengthCategory(dist);
    terms.push(`${label} Corners`,`${label} Straightaways`,isStandardDistance(dist)?'Standard Distance':'Non-Standard Distance');
  }
  return terms;
}

function filterCardsWithRules(cards,filters){
  const terms=buildFilterTerms(filters).map(normalizeSkill);
  const strictDistanceKeys=['standard distance','non-standard distance'];
  const strictTerms=terms.filter(t=>strictDistanceKeys.includes(t));
  const looseTerms=terms.filter(t=>!strictDistanceKeys.includes(t));
  return cards.filter(card=>{
    const skills=[...card.hint_skills,...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t=>skills.includes(t)) && looseTerms.every(term=>skills.some(s=>s.includes(term)));
  });
}

/* ------------- UPDATED RENDER SECTIONS WITH SORTING AND REGION FILTERING ------------- */
function renderSections() {
  cardSections.innerHTML='';

  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

  const anyDropdownActive = Object.values(filters).some(v => v);
  const anySkillActive = SKILL_SEARCH_KEYS.some(key => document.getElementById(key)?.value.trim());
  const anyRarityActive = selectedRarities.size > 0;
  const anyTypeActive = selectedTypes.size > 0;

  if(!anyDropdownActive && !anySkillActive && !anyRarityActive && !anyTypeActive) {
    const section = document.createElement('div');
    section.className = 'card-section';
    section.style.display = 'flex';
    section.style.flexDirection = 'column';
    section.style.alignItems = 'center';
    section.style.justifyContent = 'center';
    const msg = document.createElement('div');
    msg.style.opacity = '0.7';
    msg.style.padding = '0px';
    msg.style.marginTop = '20px';
    msg.style.marginBottom = '10px';
    msg.textContent = 'Pick a label on the left or type a skill to show matching cards.';
    section.appendChild(msg);
    cardSections.appendChild(section);
    return;
  }

// Apply region filter first - CORRECTED
let baseFilteredCards = cardsData.filter(card => {
  if (region === 'global') {
    // For Global, only show cards that have release_en date (released globally)
    return card.release_en && card.release_en !== '';
  } else { // japan
    // For Japan, show ALL cards (including those not released globally)
    return true;
  }
});
  
  // Apply rarity and type filters to base cards
  if (anyRarityActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      if (selectedRarities.has('R') && card.rarity === 1) return true;
      if (selectedRarities.has('SR') && card.rarity === 2) return true;
      if (selectedRarities.has('SSR') && card.rarity === 3) return true;
      return false;
    });
  }
  
  if (anyTypeActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      return selectedTypes.has(card.type);
    });
  }

  // APPLY SORTING to base cards
  baseFilteredCards = sortCards(baseFilteredCards, sortBy, sortOrder);

// Render dropdown filter sections (separated as before)
const filterOrder = ['racecourse','length','direction','track','season','weather','strategy'];
filterOrder.forEach(catId => {
  if (!filters[catId]) return;

  // ADD THIS CHECK - only render if preset cards should be shown
  if (!shouldShowFilterSection(catId)) return;

  if (catId === 'length') {
      const dist = parseInt(filters.length);
      const label = getLengthCategory(dist);
      const distanceType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';

      [
        { title: `${label} Corners`, terms: [`${label} Corners`] },
        { title: `${label} Straightaways`, terms: [`${label} Straightaways`] },
        { title: distanceType, terms: [distanceType] }
      ].forEach((row, idx) => renderFilterRow(catId, row.title, row.terms, idx, baseFilteredCards));

    } else if (catId === 'strategy') {
      const strat = filters.strategy;
      const stratRows = [
        { title: `${strat} Corners`, term: `${strat} Corners` },
        { title: `${strat} Straightaways`, term: `${strat} Straightaways` },
        { title: `${strat} Savvy`, term: `${strat} Savvy` }
      ];
      stratRows.forEach((row, idx) => renderFilterRow(catId, row.title, [row.term], idx, baseFilteredCards));

    } else {
      let rowTerms = [], headerText = '';
      switch (catId) {
        case 'racecourse': rowTerms.push(`${filters.racecourse} Racecourse`); headerText = `${filters.racecourse} Racecourse`; break;
        case 'direction': const dir = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed'; rowTerms.push(dir); headerText = dir; break;
        case 'track': const trackLabel = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions'; rowTerms.push(trackLabel); headerText = trackLabel; break;
        case 'season': rowTerms.push(`${filters.season} Runner`); headerText = `${filters.season} Runner`; break;
        case 'weather': rowTerms.push(`${capitalize(filters.weather)} Days`); headerText = `${capitalize(filters.weather)} Days`; break;
      }
      renderFilterRow(catId, headerText, rowTerms, 0, baseFilteredCards);
    }
  });

// Render skill search sections (separated as before)
SKILL_SEARCH_KEYS.forEach((key, i) => {
  const val = document.getElementById(key)?.value.trim();
  if (!val) return;

  const normalized = normalizeSkill(val);
  
  // Use a Set to track unique cards by support_id to avoid duplicates
  const uniqueMatches = new Set();
  const matches = [];
  
  baseFilteredCards.forEach(card => {
    // Use English skills for Global region, Japanese skills for Japan region
    // Fall back to Japanese skills if English skills are empty
    const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
    const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
    
    const skills = [...card.hint_skills, ...eventSkillsToUse].map(normalizeSkill);
    const hasMatch = skills.some(s => s.includes(normalized));
    
    if (hasMatch && !uniqueMatches.has(card.support_id)) {
      uniqueMatches.add(card.support_id);
      matches.push(card);
    }
  });

  const header = `Skill Search ${i + 1}: "${val}"`;
  renderSkillSearchRow(key, header, matches, i);
});

  highlightSkills();
}

function renderFilterRow(catId, headerText, termList, rowIndex, baseCards){
  const termsNormalized = termList.map(normalizeSkill);
  const strictDistanceKeys = ['standard distance','non-standard distance'];
  const strictTerms = termsNormalized.filter(t => strictDistanceKeys.includes(t));
  const looseTerms = termsNormalized.filter(t => !strictDistanceKeys.includes(t));

  const matches = baseCards.filter(card => {
    const skills = [...card.hint_skills, ...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t => skills.includes(t)) && looseTerms.every(term => skills.some(s => s.includes(term)));
  });

  // COMPLETELY HIDE SECTION IF NO MATCHES
  if(matches.length === 0){
    return; // Don't create any section at all
  }

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.textContent = headerText;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button'); 
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  const rightBtn = document.createElement('button'); 
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  const pageKey = `${catId}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  function renderPage(page, matches, grid, leftBtn, rightBtn, pageKey){
    grid.innerHTML = '';
    const startIdx = page * CARDS_PER_PAGE;
    const endIdx = startIdx + CARDS_PER_PAGE;
    const pageCards = matches.slice(startIdx, endIdx);
    pageCards.forEach(card => grid.appendChild(createCardElement(card)));

    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);

    leftBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    rightBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    leftBtn.disabled = page === 0;
    rightBtn.disabled = page >= totalPages - 1;

    leftBtn.onclick = ()=>{ 
      renderPage(page-1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey,page-1);
      highlightSkills();
    };
    rightBtn.onclick = ()=>{ 
      renderPage(page+1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey,page+1);
      highlightSkills();
    };
    
    highlightSkills();
  }

  renderPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);
  cardSections.appendChild(section);
}

function renderSkillSearchRow(key, headerText, matches, rowIndex) {
  // COMPLETELY HIDE SECTION IF NO MATCHES
  if (matches.length === 0) {
    return; // Don't create any section at all
  }

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'skill-search-header';
  header.textContent = headerText;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `${key}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  function renderPage(page) {
    grid.innerHTML = '';
    const startIdx = page * CARDS_PER_PAGE;
    const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
    pageCards.forEach(card => grid.appendChild(createCardElement(card)));

    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
    leftBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    rightBtn.style.display = totalPages > 1 ? 'flex' : 'none';
    leftBtn.disabled = page === 0;
    rightBtn.disabled = page >= totalPages - 1;
    
    highlightSkills();
  }

  renderPage(currentPage);

  leftBtn.addEventListener('click', () => {
    const newPage = sectionPages.get(pageKey) - 1;
    if (newPage >= 0) {
      sectionPages.set(pageKey, newPage);
      renderPage(newPage);
      highlightSkills();
    }
  });

  rightBtn.addEventListener('click', () => {
    const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
    const newPage = sectionPages.get(pageKey) + 1;
    if (newPage < totalPages) {
      sectionPages.set(pageKey, newPage);
      renderPage(newPage);
      highlightSkills();
    }
  });
}

/* ------------- TOGGLE PRESET CARDS FUNCTIONALITY ------------- */
function setupTogglePresetCards() {
  // Load saved state
  const savedState = localStorage.getItem('showPresetCards');
  if (savedState !== null) {
    showPresetCards = savedState === 'true';
    updateTogglePresetCardsButton();
  }

  togglePresetCardsBtn.addEventListener('click', () => {
    showPresetCards = !showPresetCards;
    localStorage.setItem('showPresetCards', showPresetCards);
    updateTogglePresetCardsButton();
    renderSections();
  });
}

function updateTogglePresetCardsButton() {
  togglePresetCardsBtn.textContent = showPresetCards ? 
    'Hide Default Cards' : 
    'Show Default Cards';
}

function shouldShowFilterSection(catId) {
  // If we're hiding preset cards, only show skill search sections
  if (!showPresetCards) {
    return false; // Hide all filter-based sections (racecourse, length, etc.)
  }
  return true; // Show all sections when preset cards are visible
}

// Initialize the hide uncolored checkbox
setupHideUncoloredCheckbox();

// Auto-update whenever a filter dropdown changes
['racecourse','length','direction','track','season','weather','strategy']
  .forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.addEventListener('change', renderSections);
    }
  });

document.addEventListener('DOMContentLoaded', () => {
  renderSections();
});

window.addEventListener('resize', renderSections);
</script>
</body>
</html>