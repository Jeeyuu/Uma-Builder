<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Uma Builder — Card Picker</title>
<style>
:root {
  --card-w: 120px;
  --gap: 6.5px;
  --card-gap: 6.5px; /* Default for expanded sidebar */
}

/* Reset & Base Styles */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

body {
  font-family: Arial, Helvetica, sans-serif;
  background: #fff;
  color: #111;
}

/* --------- HEADER STYLES --------- */
.header {
  height: 70px;
  background: #fff;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 30px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header-left {
  display: flex;
  align-items: center;
}

.header-logo {
  height: 40px;
  width: auto;
}

.header-title {
  margin-left: 12px;
  font-size: 18px;
  font-weight: bold;
  color: #333;
}

.header-nav {
  display: flex; /* Make sure this is visible */
  align-items: center;
  gap: 10px;
}

/* ---------- LAYOUT ---------- */
.container {
  display: flex;
  width: 100%;
  height: calc(100vh - 70px);
  overflow: hidden;
}

/* Sidebar Base Styles */
.sidebar, .right-sidebar {
  flex-shrink: 0;
  padding: 16px 12px;
  box-sizing: border-box;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  scrollbar-width: none;
  -ms-overflow-style: none;
  height: 100%;
}

.sidebar::-webkit-scrollbar,
.right-sidebar::-webkit-scrollbar {
  display: none;
}

.sidebar > *:not(:last-child),
.right-sidebar > *:not(:last-child) {
  margin-bottom: 12px;
}

/* Left Sidebar */
.sidebar {
  width: 200px;
  background: #f9f9f9;
}

/* Right Sidebar */
.right-sidebar {
  background: #f5f5f5;
  border-left: 1px solid #ddd;
  align-items: center;
  min-width: fit-content;
  overflow-y: auto !important;
  overflow-x: hidden;
}

.right-sidebar .slots-header {
  margin: 0;
}

/* Main Content */
.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  overflow-y: auto;
  padding: 16px;
  box-sizing: border-box;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.main-content::-webkit-scrollbar {
  display: none;
}

.content-wrapper {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: flex-start;
  width: 100%;
  margin: 0 auto;
}

/* ---------- FORM CONTROLS ---------- */
/* Filter Groups */
.filter-group, .toggle-button-group {
  display: flex;
  flex-direction: column;
  transition: opacity 0.3s ease;
}

.filter-group > label:not(.checkbox-label),
.toggle-button-group label {
  margin-bottom: 4px;
  font-weight: 600;
  font-size: 13px;
}

/* Inputs & Selects */
.sidebar select, 
.sidebar .skill-search,
.search-input-container input {
  width: 100%;
  padding: 6px 8px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box;
}

/* ---------- BUTTONS ---------- */
.clear-all, #clearFiltersBtn, #togglePresetCardsBtn {
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  width: 100%;
}

.clear-all:hover, #clearFiltersBtn:hover, #togglePresetCardsBtn:hover {
  background: #333;
}

.slots-header .clear-all {
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2);
}

/* Toggle Buttons */
.toggle-buttons-row {
  display: flex;
  justify-content: flex-start;
}

.toggle-button {
  background: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border: none;
}

.toggle-button:hover {
  background: #f0f0f0;
}

.toggle-button.active {
  background: none;
}

.toggle-button img {
  display: block;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  filter: grayscale(100%) opacity(0.6);
  transition: filter 0.2s ease;
}

.toggle-button.active img {
  filter: grayscale(0%) opacity(1);
}

.toggle-button:hover img {
  filter: grayscale(100%) opacity(0.8);
}

/* Rarity Buttons */
.rarity-buttons .toggle-buttons-row {
  width: 100%;
  gap: 2px;
}

.rarity-buttons .toggle-button {
  flex: 1;
  aspect-ratio: 53 / 22;
  border-radius: 0;
  border-right: none;
  background: none;
}

/* Type Buttons */
.type-buttons .toggle-buttons-row {
  width: 100%;
  gap: 1px;
  flex-wrap: wrap;
}

.type-buttons .toggle-button {
  flex: 1;
  border: none;
  border-radius: 0;
  aspect-ratio: 1;
  min-width: 0;
}

/* ---------- SKILL SEARCH ---------- */
#skillSearchGroup {
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}

.skill-search-divider {
  min-height: 1px;
  background: #333;
  margin-bottom: 12px;
  width: 100%;
}

.skill-search-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0;
}

#skillSearchGroup label {
  margin-bottom: 0;
  font-weight: 600;
  font-size: 13px;
}

.add-search-btn {
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  width: 48px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

.add-search-btn:hover {
  background: #333;
}

.search-input-container {
  display: flex;
  align-items: center;
  gap: 4px;
  width: 100%;
}

.remove-search-btn {
  width: 24px;
  height: 24px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #f5f5f5;
  color: #666;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  flex-shrink: 0;
}

.remove-search-btn:hover {
  background: #e5e5e5;
  color: #333;
}

/* ---------- SKILL SEARCH BUTTONS ---------- */
.skill-search-buttons {
  display: flex;
  gap: 6px;
}

.clear-search-btn {
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #888;
  color: #fff;
  transition: background-color 0.2s;
  width: 48px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

/* Clear All Button - Dark Red */
.clear-all, #clearAllBtn {
  background: #8B0000 !important; /* Dark red */
  color: #fff;
}

.clear-all:hover, #clearAllBtn:hover {
  background: #A52A2A !important; /* Slightly lighter dark red on hover */
}

/* Dark mode support for clear buttons */
body.dark-mode .clear-all,
body.dark-mode #clearAllBtn {
  background: #8B0000 !important;
}

body.dark-mode .clear-all:hover,
body.dark-mode #clearAllBtn:hover {
  background: #A52A2A !important;
}

/* Ensure the Clear Filters button also gets the dark red color */
#clearFiltersBtn {
  background: #8B0000 !important;
  color: #fff;
}

#clearFiltersBtn:hover {
  background: #A52A2A !important;
}

body.dark-mode #clearFiltersBtn {
  background: #8B0000 !important;
}

body.dark-mode #clearFiltersBtn:hover {
  background: #A52A2A !important;
}

/* ---------- CARDS & SLOTS ---------- */
/* Card Grids */
.cards, .slots {
  display: grid;
  grid-template-columns: repeat(auto-fill, var(--card-w));
  gap: var(--card-gap); /* Use the dynamic gap variable */
  width: 100%;
  justify-content: start;
  align-items: start;
}

.cards {
  grid-auto-rows: 0;
  grid-template-rows: 1fr;
  overflow: hidden;
}

.slots {
  grid-template-columns: repeat(3, var(--card-w));
  grid-auto-rows: min-content;
  max-width: calc(var(--card-w) * 3 + var(--card-gap) * 2); /* Use dynamic gap here too */
  margin: 35px auto 0;
  height: auto;
  min-height: min-content;
}

/* Card/Slot Base Styles */
.card, .slot {
  border: 1px solid #ddd;
  padding: 6px;
  box-sizing: border-box;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: var(--card-w);
  position: relative;
  min-height: 0;
  height: auto;
}

.slot {
  padding: 8px;
  cursor: pointer;
  min-height: var(--card-w);
  height: min-content;
  justify-self: start;
  transition: min-height 0.3s ease;
}

.slot:not(.has-card) {
  border: 2px dashed #ccc;
  background: #fafafa;
  aspect-ratio: 1;
  height: var(--card-w);
}

.slot.has-card {
  /* Remove any height/min-height constraints */
  height: auto; /* Let content determine height */
}

.slot .placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ccc;
  font-size: 11px;
}

/* Card Content */
.card .name, .slot.has-card .name {
  margin: 6px 0 4px;
  font-weight: 700;
  text-align: center;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card img, .slot.has-card img {
  max-width: calc(var(--card-w) * 0.8);
  max-height: calc(var(--card-w) * 0.8);
  object-fit: contain;
}

/* Skills */
.card .skills, .slot.has-card .skills,
.card .skills-group, .slot.has-card .skills-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  width: 100%;
  align-items: center;
  min-height: 0;
}

.skills-group {
  min-height: 0;
}

/* Fix for hidden skills groups - remove gap when group is hidden */
.skills-group.hidden-skill {
  display: none !important;
  margin: 0 !important;
  gap: 0 !important;
}

/* Ensure no gap between visible groups when a hidden group is between them */
.skills-group:not(.hidden-skill) + .skills-group:not(.hidden-skill) {
  margin-top: 8px;
}

/* Remove top margin for first visible group */
.skills-group:not(.hidden-skill):first-child {
  margin-top: 0;
}

.skill {
  width: 100%;
  background: #eef2ff;
  border-radius: 4px;
  padding: 2px 4px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
}

.skills-header {
  font-size: 9px;
  font-weight: bold;
  margin-top: 6px;
  text-align: center;
  background: #000;
  color: #fff;
  padding: 3px 4px;
  border-radius: 0;
  width: 100%;
}

/* Type Icon */
.card .type-icon, .slot.has-card .type-icon {
  position: absolute;
  top: 0px;
  right: 0px;
  width: 32px;
  height: 32px;
  overflow: hidden;
}

.card .type-icon img, .slot.has-card .type-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

/* ---------- SLOT LEVEL CONTROLS ---------- */
.slot-container {
  position: relative;
  width: var(--card-w);
}

.slot-container:nth-child(-n+3) {
  margin-bottom: 40px;
}

.slot-container:nth-child(n+4) {
  margin-bottom: 0;
}

.slot-level-controls {
  position: absolute;
  top: -35px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 8px;
  background: #f8f8f8;
  border: 1px solid #ddd;
  border-radius: 4px;
  z-index: 20;
  pointer-events: auto;
}

.slot:not(.has-card) .slot-level-controls {
  display: none;
}

.slot-level-label {
  font-size: 11px;
  font-weight: bold;
  color: #333;
}

.slot-level-input {
  width: 40px;
  height: 20px;
  border: 1px solid #ccc;
  border-radius: 3px;
  text-align: center;
  font-size: 11px;
  font-weight: bold;
  background: #fff;
}

.slot-level-input:focus {
  outline: none;
  border-color: #444;
}

/* ---------- SECTIONS & PAGINATION ---------- */
.card-sections {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: 100%;
  gap: 10px;
}

.card-section {
  position: relative;
  width: 100%;
}

.card-section-header {
  position: relative;
  display: block;
  margin: 0 0 10px;
  width: 100%;
}

.card-section-header h2 {
  margin: 0;
}

.page-controls {
  position: absolute;
  top: 0;
  right: 0;
  display: flex;
  gap: 8px;
}

.page-controls button {
  border: none;
  background: #444;
  color: #fff;
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 12px;
  font-weight: bold;
  cursor: pointer;
  min-width: 32px;
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s;
  line-height: 1;
}

.page-controls button:hover:not(:disabled) {
  background: #333;
}

.page-controls button:disabled {
  background: #999;
  color: #ccc;
  cursor: not-allowed;
}

.card.disabled {
  opacity: 0.45;
}

/* ---------- UTILITY CONTROLS ---------- */
.sort-order-btn {
  border: 1px solid #ccc;
  background: #f5f5f5;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.2s ease;
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

.sort-order-btn:hover {
  background: #e5e5e5;
  border-color: #999;
}

.sort-order-btn.ascending {
  background: #444;
  color: #fff;
  border-color: #444;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  margin-bottom: -4px;
}

.checkbox-label input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
}

/* ---------- COLOR PICKER ---------- */
.color-picker {
  width: 20px;
  height: 20px;
  border: 2px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  flex-shrink: 0;
  transition: all 0.2s ease;
}

.color-picker:hover {
  border-color: #999;
  transform: scale(1.1);
}

/* Solid colors - black text, no border */
.color-picker.green { background: #bce934; }
.color-picker.blue { background: #1cd8fe; }
.color-picker.orange { background: #fdb832; }
.color-picker.red { background: #fca5a5; } /* Updated red */

/* Colors with gold border - white text */
.color-picker.green-border { 
  background: #57ad33; /* Dark green */
  border-color: #fff96b;
  border-width: 3px;
}
.color-picker.blue-border { 
  background: #14a1f7; /* Dark blue */
  border-color: #fff96b;
  border-width: 3px;
}
.color-picker.orange-border { 
  background: #fa9937; /* Dark orange */
  border-color: #fff96b;
  border-width: 3px;
}
.color-picker.red-border { 
  background: #f75757; /* Dark red */
  border-color: #fff96b;
  border-width: 3px;
}

/* ---------- SKILLS LIST ---------- */
.selected-skills-section {
  width: 100%;
  margin-top: 16px;
}

.skills-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding: 0 4px;
}

.skills-list-header h3 {
  margin: 0;
  font-size: 14px;
  font-weight: bold;
  color: #333;
}

.skills-count {
  font-size: 12px;
  color: #666;
  font-weight: normal;
}

.skills-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 400px;
  overflow-y: auto;
  padding-right: 4px;
}

.skills-list::-webkit-scrollbar {
  width: 4px;
}

.skills-list::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 2px;
}

.skills-list::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 2px;
}

.skills-list::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

.skill-item {
  background: #eef2ff;
  border-radius: 4px;
  padding: 6px 8px;
  font-size: 12px;
  word-break: break-word;
  white-space: normal;
  text-align: center;
  transition: all 0.2s ease;
  border: 1px solid #ddd;
}

.skill-item.highlighted {
  background: #ffae77;
  color: #000;
}

.skill-item.search-highlighted {
  color: white;
}

/* ---------- VISIBILITY CONTROLS ---------- */
.sidebar-filters-section {
  transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar-filters-section.hidden {
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  pointer-events: none;
  margin-bottom: 0 !important;
  gap: 0;
}

/* Skill Hiding */
.skill.hidden-skill,
.skills-header.hidden-skill,
.skills-group.hidden-skill,
.skill-item.hidden-skill {
  display: none;
}

.skills:empty,
.skills:has(.skills-group.hidden-skill:only-child),
.skills:has(.skills-group.hidden-skill:first-child + .skills-group.hidden-skill:last-child) {
  display: none;
}

.skills-group:not(.hidden-skill):first-child {
  margin-top: 0;
}

.skills-group:not(.hidden-skill) + .skills-group:not(.hidden-skill) {
  margin-top: 8px;
}

/* Skill Highlighting */
.skill.search-highlighted {
  background: #ff4444;
  color: white;
}

/* ---------- DARK MODE ---------- */
body.dark-mode {
  background: #1a1a1a;
  color: #e0e0e0;
}

/* Header */
body.dark-mode .header {
  background: #2d2d2d;
  border-bottom-color: #444;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

body.dark-mode .header-title {
  color: #e0e0e0;
}

/* Sidebars */
body.dark-mode .sidebar {
  background: #2d2d2d;
}

body.dark-mode .right-sidebar {
  background: #252525;
  border-left-color: #444;
}

/* Form Controls */
body.dark-mode select,
body.dark-mode .skill-search,
body.dark-mode .slot-level-input {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

body.dark-mode select:focus,
body.dark-mode .skill-search:focus,
body.dark-mode .slot-level-input:focus {
  border-color: #666;
  outline: none;
}

/* Cards & Slots */
body.dark-mode .card,
body.dark-mode .slot {
  background: #2d2d2d;
  border-color: #444;
  color: #e0e0e0;
}

body.dark-mode .slot:not(.has-card) {
  background: #252525;
  border-color: #555;
}

/* Skills */
body.dark-mode .skill {
  background: #3a3a3a;
  color: #e0e0e0;
}

body.dark-mode .skills-header {
  background: #444;
  color: #e0e0e0;
}

/* Buttons */
body.dark-mode .clear-all,
body.dark-mode #clearFiltersBtn,
body.dark-mode #togglePresetCardsBtn,
body.dark-mode .add-search-btn,
body.dark-mode .page-controls button {
  background: #555;
  color: #e0e0e0;
}

body.dark-mode .clear-all:hover,
body.dark-mode #clearFiltersBtn:hover,
body.dark-mode #togglePresetCardsBtn:hover,
body.dark-mode .add-search-btn:hover,
body.dark-mode .page-controls button:hover:not(:disabled) {
  background: #666;
}

body.dark-mode .page-controls button:disabled {
  background: #444;
  color: #888;
}

/* Remove Search Button */
body.dark-mode .remove-search-btn {
  background: #3a3a3a;
  border-color: #555;
  color: #888;
}

body.dark-mode .remove-search-btn:hover {
  background: #444;
  color: #e0e0e0;
}

/* Toggle Buttons */
body.dark-mode .toggle-button {
  background: #3a3a3a;
}

body.dark-mode .toggle-button:hover {
  background: #444;
}

/* Sort Order Button */
body.dark-mode .sort-order-btn {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

body.dark-mode .sort-order-btn:hover {
  background: #444;
  border-color: #666;
}

body.dark-mode .sort-order-btn.ascending {
  background: #555;
  border-color: #666;
}

/* Level Controls */
body.dark-mode .slot-level-controls {
  background: #3a3a3a;
  border-color: #555;
}

body.dark-mode .slot-level-label {
  color: #e0e0e0;
}

/* Selected Skills */
body.dark-mode .skill-item {
  background: #3a3a3a;
  border-color: #555;
  color: #e0e0e0;
}

/* Scrollbars */
body.dark-mode .skills-list::-webkit-scrollbar-track {
  background: #2d2d2d;
}

body.dark-mode .skills-list::-webkit-scrollbar-thumb {
  background: #555;
}

body.dark-mode .skills-list::-webkit-scrollbar-thumb:hover {
  background: #666;
}

/* Dividers */
body.dark-mode .skill-search-divider {
  background: #555;
}

/* Dark Mode Toggle Button */
.dark-mode-toggle {
  background: none;
  border: 2px solid #666;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 18px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dark-mode-toggle:hover {
  background: #444;
  border-color: #888;
  transform: scale(1.1);
}

body.dark-mode .dark-mode-toggle {
  border-color: #888;
  background: #444;
}

body.dark-mode .dark-mode-toggle:hover {
  background: #555;
}

/* Dark mode support for bordered highlights */
body.dark-mode .skill.search-highlighted[data-has-border="true"],
body.dark-mode .skill.highlighted[data-has-border="true"],
body.dark-mode .skill-item.search-highlighted[data-has-border="true"],
body.dark-mode .skill-item.highlighted[data-has-border="true"] {
  border-color: #fff96b;
  box-shadow: 0 0 0 1px #fff96b;
}

/* ---------- SKILL HIGHLIGHTING WITH BORDERS ---------- */
.skill.search-highlighted,
.skill.highlighted {
  position: relative;
  z-index: 1;
}

/* Skills with gold border - white text */
.skill.search-highlighted[data-has-border="true"],
.skill.highlighted[data-has-border="true"] {
  border: 2px solid #fff96b;
  box-shadow: 0 0 0 1px #fff96b;
  color: #ffffff !important; /* Force white text for bordered skills */
}

/* Adjust padding for bordered skills to maintain size */
.skill.search-highlighted[data-has-border="true"],
.skill.highlighted[data-has-border="true"] {
  padding: 1px 3px; /* Reduced padding to account for border */
}

/* Selected skills list items with borders */
.skill-item.search-highlighted[data-has-border="true"],
.skill-item.highlighted[data-has-border="true"] {
  border: 2px solid #fff96b;
  box-shadow: 0 0 0 1px #fff96b;
  padding: 5px 7px; /* Adjusted padding */
  color: #ffffff !important; /* Force white text for bordered skills */
}

/* Ensure solid colors keep black text */
.skill.search-highlighted:not([data-has-border="true"]),
.skill.highlighted:not([data-has-border="true"]) {
  color: #000000 !important;
}

.skill-item.search-highlighted:not([data-has-border="true"]),
.skill-item.highlighted:not([data-has-border="true"]) {
  color: #000000 !important;
}

/* ---------- COPY/PASTE BUTTONS ---------- */
.copy-paste-buttons {
  display: flex;
  gap: 6px;
  width: 100%;
  margin-bottom: 8px;
}

.copy-paste-btn {
  flex: 1;
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  font-weight: 600;
}

.copy-paste-btn:hover {
  background: #333;
}

.copy-paste-btn:active {
  transform: translateY(1px);
}

/* Dark mode support */
body.dark-mode .copy-paste-btn {
  background: #555;
  color: #e0e0e0;
}

body.dark-mode .copy-paste-btn:hover {
  background: #666;
}

/* ---------- DECK BUTTONS ---------- */
.deck-buttons {
  display: grid;
  grid-template-columns: repeat(3, var(--card-w));
  gap: var(--gap);
  width: 100%;
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2);
  margin-bottom: 1px; /* Added margin bottom */
}

.deck-btn, .slots-header .clear-all {
  width: var(--card-w);
  padding: 8px 12px;
  font-size: 12px;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  background: #444;
  color: #fff;
  transition: background-color 0.2s;
  font-weight: 600;
  box-sizing: border-box;
}

.deck-btn:hover, .slots-header .clear-all:hover {
  background: #333;
}

.deck-btn:active, .slots-header .clear-all:active {
  transform: translateY(1px);
}

/* Dark mode support */
body.dark-mode .deck-btn,
body.dark-mode .slots-header .clear-all {
  background: #555;
  color: #e0e0e0;
}

body.dark-mode .deck-btn:hover,
body.dark-mode .slots-header .clear-all:hover {
  background: #666;
}

/* Clear All Button - Dark Red */
.clear-all, #clearAllBtn {
  background: #8B0000 !important; /* Dark red */
  color: #fff;
}

.clear-all:hover, #clearAllBtn:hover {
  background: #A52A2A !important; /* Slightly lighter dark red on hover */
}

/* Dark mode support for clear buttons */
body.dark-mode .clear-all,
body.dark-mode #clearAllBtn {
  background: #8B0000 !important;
}

body.dark-mode .clear-all:hover,
body.dark-mode #clearAllBtn:hover {
  background: #A52A2A !important;
}

/* Ensure the Clear Filters button also gets the dark red color */
#clearFiltersBtn {
  background: #8B0000 !important;
  color: #fff;
}

#clearFiltersBtn:hover {
  background: #A52A2A !important;
}

body.dark-mode #clearFiltersBtn {
  background: #8B0000 !important;
}

body.dark-mode #clearFiltersBtn:hover {
  background: #A52A2A !important;
}

/* Hide Preset Cards button should remain normal color (not red) */
#togglePresetCardsBtn {
  background: #444 !important; /* Normal gray color */
  color: #fff;
}

#togglePresetCardsBtn:hover {
  background: #333 !important;
}

body.dark-mode #togglePresetCardsBtn {
  background: #555 !important;
}

body.dark-mode #togglePresetCardsBtn:hover {
  background: #666 !important;
}

/* Search Clear button - Dark Red */
.clear-search-btn {
  background: #8B0000 !important; /* Dark red */
  color: #fff;
}

.clear-search-btn:hover {
  background: #A52A2A !important;
}

body.dark-mode .clear-search-btn {
  background: #8B0000 !important;
}

body.dark-mode .clear-search-btn:hover {
  background: #A52A2A !important;
}

/* Effect cards styling */
.effect-cards {
  display: flex;
  gap: 1px;
  align-items: center;
  justify-content: flex-end;
  min-height: 40px;
  flex-wrap: nowrap;
  max-width: 186px; /* 6 cards * 30px + 5 gaps * 1px */
  overflow: hidden;
}

.effect-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 30px;
  flex-shrink: 0;
  position: relative;
}

.effect-card-img {
  width: 24px;
  height: 24px;
  border-radius: 2px;
  border: 1px solid #ddd;
  object-fit: cover;
  background: #fff;
}

.effect-card-value {
  font-size: 8px;
  font-weight: bold;
  color: #2c5e1a;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 1px;
  padding: 0 1px;
  margin-top: 1px;
  line-height: 1.1;
  text-align: center;
  min-width: 100%;
  border: 0.5px solid #e0e0e0;
}

/* Effect row styling */
.effect-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-bottom: 3px;
  padding: 3px 0px;
  border-radius: 3px;
  transition: background-color 0.2s ease;
  min-height: 36px;
}

.effect-row:hover {
  background-color: rgba(0, 0, 0, 0.03);
}

.effect-info {
  display: flex;
  align-items: center;
  min-width: 150px;
  flex-shrink: 0;
}

.effect-name {
  font-size: 11px;
  font-weight: 500;
  color: #333;
  min-width: 130px;
}

.effect-value {
  font-size: 11px;
  font-weight: bold;
  color: #2c5e1a;
  min-width: 30px;
  text-align: center;
  background: #f0f8f0;
  margin-left: 3px;
  padding: 13px 4px;
  border-radius: 2px;
  border: 1px solid #e0f0e0;
}

/* Compact layout for many cards - show scroll for more than 6 */
.effect-cards.has-many-cards {
  overflow-x: auto;
  scrollbar-width: thin;
  scrollbar-color: #ccc transparent;
}

.effect-cards.has-many-cards::-webkit-scrollbar {
  height: 3px;
}

.effect-cards.has-many-cards::-webkit-scrollbar-track {
  background: transparent;
}

.effect-cards.has-many-cards::-webkit-scrollbar-thumb {
  background-color: #ccc;
  border-radius: 2px;
}

/* Dark mode support */
body.dark-mode .effect-row:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

body.dark-mode .effect-name {
  color: #e0e0e0;
}

body.dark-mode .effect-card-img {
  border-color: #555;
  background: #3a3a3a;
}

body.dark-mode .effect-card-value {
  background: rgba(60, 60, 60, 0.95);
  color: #8bc34a;
  border-color: #555;
}

body.dark-mode .effect-value {
  background: #2a3a2a;
  color: #8bc34a;
  border-color: #3a4a3a;
}

/* ------------- COLLAPSIBLE SIDEBAR ------------- */
.right-sidebar {
  position: relative;
  transition: all 0.3s ease;
  min-width: 160px;
  overflow-y: auto !important;
  height: 100%;
}

/* When right sidebar is collapsed, override the card gap */
.right-sidebar.collapsed {
  --card-gap: 7px;
}

/* Collapse Toggle Button - YOUR PREFERRED SETTINGS */
.collapse-toggle {
    position: sticky;
    top: 50vh;
    left: 0;
    width: 15px;
    height: 150px;
    margin-left: 3.95px;
    border: 2px solid #ddd;
    border-radius: 4px 0 0 4px; /* Top-left and bottom-left corners only */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 14px;
    font-weight: bold;
    z-index: 1000;
    transition: all 0.3s ease;
    float: left;
    transform: translateY(-50%); /* This centers it properly */
}

.collapse-toggle:hover {
  background: #333;
  transform: translateY(-50%) scale(1.1);
}

/* Make main section ignore the arrow by using proper flex layout */
.container {
  display: flex;
  width: 100%;
  height: calc(100vh - 70px);
  overflow: hidden;
}

/* Ensure main content takes remaining space and ignores sidebar layout */
.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  overflow-y: auto;
  padding: 16px 0 16px 16px; /* top: 16px, right: 0, bottom: 16px, left: 16px */
  box-sizing: border-box;
  scrollbar-width: none;
  -ms-overflow-style: none;
  /* Main content doesn't care about sidebar internal layout */
  position: relative;
  z-index: 1;
}

.main-content::-webkit-scrollbar {
  display: none;
}

/* Adjust sidebar content to account for sticky button */
.right-sidebar-content {
  display: flex;
  flex-direction: column;
  width: 100%;
}

/* Adjust slots margin to account for sticky button */
.slots {
  grid-template-columns: repeat(3, var(--card-w));
  grid-auto-rows: min-content;
  max-width: calc(var(--card-w) * 3 + var(--gap) * 2);
  margin: 40px auto 0; /* Reduced top margin since button is sticky */
  height: auto;
  min-height: min-content;
}

/* Collapsed Layout adjustments */
.right-sidebar.collapsed .slots {
  grid-template-columns: 1fr;
  max-width: 100%;
  margin-top: 40px;
  margin-bottom: 8px;
  gap: 30px;
  height: auto;
  min-height: min-content;
}

.right-sidebar.collapsed .slot-container {
  width: 100%;
  margin-bottom: 8px;
}

.right-sidebar.collapsed .slot {
  width: 100%;
  min-height: 70px;
  height: 70px;
  padding: 6px;
  gap: 3px;
}

.right-sidebar.collapsed .slot:not(.has-card) {
  height: 70px;
}

.right-sidebar.collapsed .slot.has-card .name,
.right-sidebar.collapsed .slot.has-card .skills,
.right-sidebar.collapsed .slot.has-card .skills-group,
.right-sidebar.collapsed .slot.has-card .skills-header,
.right-sidebar.collapsed .slot.has-card .skill {
  display: none !important;
}

.right-sidebar.collapsed .slot.has-card img {
  max-width: 48px;
  max-height: 48px;
}

.right-sidebar.collapsed .slot.has-card .type-icon {
  width: 20px;
  height: 20px;
  top: 6px;
  right: 4px;
}

/* Collapsed Level Controls */
.right-sidebar.collapsed .slot-level-controls {
  padding: 2px 4px;
  top: -25px;
}

.right-sidebar.collapsed .slot-level-label {
  font-size: 9px;
}

.right-sidebar.collapsed .slot-level-input {
  width: 30px;
  height: 16px;
  font-size: 9px;
}

/* Collapsed Deck Buttons */
.right-sidebar.collapsed .deck-buttons {
  grid-template-columns: 1fr;
  margin-bottom: 0px;
  gap: 4px;
}

.right-sidebar.collapsed .deck-btn,
.right-sidebar.collapsed .slots-header .clear-all {
  width: 100%;
  padding: 6px 8px;
  font-size: 10px;
  min-height: 32px;
}

/* Collapsed Effect Rows */
.right-sidebar.collapsed .effect-row {
  min-height: 24px;
  padding: 2px 4px;
  margin-bottom: 2px;
  flex-wrap: nowrap;
  overflow: hidden;
  max-width: 100%;
  box-sizing: border-box;
}

.right-sidebar.collapsed .effect-info {
  min-width: 0;
  flex: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  overflow: hidden;
}

.right-sidebar.collapsed .effect-name {
  font-size: 9px;
  min-width: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  margin-right: 4px;
}

.right-sidebar.collapsed .effect-value {
  font-size: 9px;
  min-width: 20px;
  padding: 0 2px;
  margin-left: 0;
  flex-shrink: 0;
}

.right-sidebar.collapsed .effect-cards {
  display: none !important;
}

/* Hide debug buttons in collapsed mode */
.right-sidebar.collapsed .deck-buttons:nth-child(2) {
  display: none;
}

/* Ensure proper spacing in collapsed mode */
.right-sidebar.collapsed .skill-search-divider {
  margin-bottom: 12px;
}

/* Dark mode support for collapsed sidebar */
body.dark-mode .collapse-toggle {
  background: #555;
  border-color: #666;
}

body.dark-mode .collapse-toggle:hover {
  background: #666;
}

/* Effect text styling for cards and slots */
.effect-text {
  font-size: 8px;
  opacity: 0.6;
  margin-bottom: 0px;
  width: fit-content;
  max-width: 100%;
  text-align: center;
  margin-left: auto;
  margin-right: auto;
  white-space: nowrap;
  display: block;
}

/* Optional: Add some padding for very small containers */
.card .effect-text,
.slot .effect-text {
  padding: 0 2px;
  box-sizing: border-box;
}

/* Ensure the name container handles the effect text properly */
.card .name-container,
.slot .name-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}
</style>
</head>

<body>
<!-- Header -->
<div class="header">
  <div class="header-left">
    <img src="your-logo.png" alt="Logo" class="header-logo">
    <div class="header-title">Uma Builder</div>
  </div>
  <div class="header-nav">
    <!-- Dark Mode Toggle Button -->
    <button id="darkModeToggle" class="dark-mode-toggle" title="Toggle Dark Mode">
      🌙
    </button>
  </div>
</div>

<div class="container">

<!-- Left Sidebar (Filters) -->
<div class="sidebar">

  <!-- Card Name Search -->
  <div class="filter-group">
    <label for="cardSearch">Search Card</label>
    <input type="text" id="cardSearch" class="skill-search" placeholder="Search card name">
  </div>

  <!-- Rarity Toggle Buttons -->
  <div class="toggle-button-group rarity-buttons">
    <label>Rarity</label>
    <div class="toggle-buttons-row">
      <button class="toggle-button" data-rarity="SSR">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_03.png" alt="SSR">
      </button>
      <button class="toggle-button" data-rarity="SR">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_02.png" alt="SR">
      </button>
      <button class="toggle-button" data-rarity="R">
        <img src="https://gametora.com/images/umamusume/icons/utx_txt_rarity_01.png" alt="R">
      </button>
    </div>
  </div>

  <!-- Type Toggle Buttons -->
  <div class="toggle-button-group type-buttons">
    <label>Type</label>
    <div class="toggle-buttons-row">
      <button class="toggle-button" data-type="speed">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_00.png" alt="Speed">
      </button>
      <button class="toggle-button" data-type="stamina">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_01.png" alt="Stamina">
      </button>
      <button class="toggle-button" data-type="power">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_02.png" alt="Power">
      </button>
      <button class="toggle-button" data-type="guts">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_03.png" alt="Guts">
      </button>
      <button class="toggle-button" data-type="intelligence">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_04.png" alt="Intelligence">
      </button>
<button class="toggle-button" data-type="friend">
  <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_05.png" alt="Friend">
</button>
      <button class="toggle-button" data-type="group">
        <img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_06.png" alt="Group">
      </button>
    </div>
  </div>

  
  <!-- ADD SORTING CONTROLS HERE -->
<div class="filter-group">
  <label for="sortBy">Sort By</label>
  <div style="display: flex; gap: 6px; align-items: center;">
    <select id="sortBy" style="flex: 1;">
      <option value="rarity">Rarity</option>
      <option value="name">Character name</option>
      <option value="type">Card type</option>
      <option value="release">Release date</option>
      <option value="support_id">Game ID Number</option>
      <option disabled=""></option>
      <option disabled="">— Effects —</option>
      <option value="1">Friendship Bonus</option>
      <option value="2">Mood Effect</option>
      <option value="3">Speed Bonus</option>
      <option value="4">Stamina Bonus</option>
      <option value="5">Power Bonus</option>
      <option value="6">Guts Bonus</option>
      <option value="7">Wit Bonus</option>
      <option value="8">Training Effectiveness</option>
      <option value="9">Initial Speed</option>
      <option value="10">Initial Stamina</option>
      <option value="11">Initial Power</option>
      <option value="12">Initial Guts</option>
      <option value="13">Initial Wit</option>
      <option value="14">Initial Friendship Gauge</option>
      <option value="15">Race Bonus</option>
      <option value="16">Fan Bonus</option>
      <option value="17">Hint Levels</option>
      <option value="18">Hint Frequency</option>
      <option value="19">Specialty Priority</option>
      <option value="25">Event Recovery</option>
      <option value="26">Event Effectiveness</option>
      <option value="27">Failure Protection</option>
      <option value="28">Energy Cost Reduction</option>
      <option value="30">Skill Point Bonus</option>
      <option value="31">Wit Friendship Recovery</option>
      <option value="32">Initial Skill Points Up</option>
      <option value="41">All Stats Bonus</option>
    </select>
    <button id="sortOrder" class="sort-order-btn ascending" style="width: 32px; height: 32px; border: 1px solid #ccc; background: #444; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; border-radius: 4px; flex-shrink: 0;">
      ↑
    </button>
  </div>
</div>

  <div class="filter-group">
    <label for="region">Region</label>
    <select id="region">
      <option value="global">Global</option>
      <option value="japan">Japan</option>
    </select>
  </div>

  <!-- ADD THIS CHECKBOX -->
  <div class="filter-group">
    <label class="checkbox-label">
      <input type="checkbox" id="hideUncolored">
      Hide Uncoloured Skills
    </label>
  </div>

  <!-- ADD THIS DIVIDER -->
  <div class="skill-search-divider"></div>

  <!-- Toggle Preset Cards Button -->
  <button id="togglePresetCardsBtn" class="clear-all">Hide Preset Cards</button>

  <!-- Wrap Clear Filters Button inside the hidden section so it gets hidden too -->
  <div class="sidebar-filters-section" id="sidebarFiltersSection">
    <!-- Clear Filters Button at top -->
    <button id="clearFiltersBtn" class="clear-all clear-filters-top">Clear Filters</button>

    <div class="filter-group">
      <label for="presets">Presets</label>
      <select id="presets">
        <option value="">-- Select --</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="racecourse">Racecourse</label>
      <select id="racecourse">
        <option value="">-- Select --</option>
        <option value="Sapporo">Sapporo</option>
        <option value="Hakodate">Hakodate</option>
        <option value="Niigata">Niigata</option>
        <option value="Fukushima">Fukushima</option>
        <option value="Nakayama">Nakayama</option>
        <option value="Tokyo">Tokyo</option>
        <option value="Chukyo">Chukyo</option>
        <option value="Kyoto">Kyoto</option>
        <option value="Hanshin">Hanshin</option>
        <option value="Kokura">Kokura</option>
        <option value="Oi">Oi</option>
        <option value="Kawasaki">Kawasaki</option>
        <option value="Funabashi">Funabashi</option>
        <option value="Morioka">Morioka</option>
        <option value="Longchamp">Longchamp</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="length">Length</label>
      <select id="length">
        <option value="">-- Select --</option>
        <option value="1000">1000m</option>
        <option value="1150">1150m</option>
        <option value="1200">1200m</option>
        <option value="1300">1300m</option>
        <option value="1400">1400m</option>
        <option value="1500">1500m</option>
        <option value="1600">1600m</option>
        <option value="1700">1700m</option>
        <option value="1800">1800m</option>
        <option value="1900">1900m</option>
        <option value="2000">2000m</option>
        <option value="2100">2100m</option>
        <option value="2200">2200m</option>
        <option value="2300">2300m</option>
        <option value="2400">2400m</option>
        <option value="2500">2500m</option>
        <option value="2600">2600m</option>
        <option value="3000">3000m</option>
        <option value="3200">3200m</option>
        <option value="3400">3400m</option>
        <option value="3600">3600m</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="direction">Direction</label>
      <select id="direction">
        <option value="">-- Select --</option>
        <option value="Clockwise">Clockwise</option>
        <option value="Counterclockwise">Counterclockwise</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="track">Track Conditions</label>
      <select id="track">
        <option value="">-- Select --</option>
        <option value="Firm">Firm</option>
        <option value="Good">Good</option>
        <option value="Soft">Soft</option>
        <option value="Heavy">Heavy</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="season">Season</label>
      <select id="season">
        <option value="">-- Select --</option>
        <option value="Spring">Spring</option>
        <option value="Summer">Summer</option>
        <option value="Fall">Autumn</option>
        <option value="Winter">Winter</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="weather">Weather</label>
      <select id="weather">
        <option value="">-- Select --</option>
        <option value="Sunny">Sunny</option>
        <option value="Cloudy">Cloudy</option>
        <option value="Rainy">Rain</option>
        <option value="Snowy">Snow</option>
      </select>
    </div>

    <div class="filter-group">
      <label for="strategy">Strategy</label>
      <select id="strategy">
        <option value="">-- Select --</option>
        <option value="Front Runner">Front Runner</option>
        <option value="Pace Chaser">Pace Chaser</option>
        <option value="Late Surger">Late Surger</option>
        <option value="End Closer">End Closer</option>
      </select>
    </div>
  </div> <!-- End of sidebar-filters-section -->

  <!-- Thin divider -->
  <div class="skill-search-divider"></div>

  <!-- ADD THESE TWO BUTTONS -->
  <div class="copy-paste-buttons">
    <button id="copySkillsBtn" class="copy-paste-btn">Copy Skills</button>
    <button id="pasteSkillsBtn" class="copy-paste-btn">Paste Skills</button>
  </div>

<!-- Skill Search Section -->
<div id="skillSearchGroup">
  <div class="skill-search-header">
    <label for="skillSearch1">Search</label>
    <div class="skill-search-buttons">
      <button class="add-search-btn" id="addSearchBtn">Add</button>
      <button class="clear-search-btn" id="clearAllSearchesBtn" title="Clear all searches">Clear</button>
    </div>
  </div>

  <!-- Default search box -->
  <div class="search-input-container">
    <div class="color-picker green" data-search-id="skillSearch1" data-color="green"></div>
    <input type="text" id="skillSearch1" class="skill-search" placeholder="Search skill">
    <button class="remove-search-btn" data-search-id="skillSearch1">×</button>
  </div>
    
    <!-- Additional search boxes will be added here dynamically -->
  </div>
</div>

<!-- Main Content -->
  <div class="main-content">
    <div class="content-wrapper">
      <div id="cardSections" class="card-sections"></div>
    </div>
  </div>

    <!-- Toggle button INSIDE the sidebar at the top -->
  <button class="collapse-toggle" id="collapseSidebar" title="Collapse sidebar">◀</button>

<!-- Right Sidebar (Slots) -->
<div class="right-sidebar" id="rightSidebar">
  
  <div class="right-sidebar-content">
    <div class="skill-search-divider"></div>
    <div class="slots-header">
      <div class="deck-buttons">
        <button id="copyDeckBtn" class="deck-btn">Copy Deck</button>
        <button id="pasteDeckBtn" class="deck-btn">Paste Deck</button>
        <button id="clearAllBtn" class="clear-all">Clear Deck</button>
      </div>
    </div>

  <div class="slots" id="slots">
    <div class="slot-container" data-slot="0">
      <div class="slot-level-controls">
        <span class="slot-level-label">Level</span>
        <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
      </div>
      <div class="slot" data-slot="0"><div class="placeholder">Empty</div></div>
    </div>
    <div class="slot-container" data-slot="1">
      <div class="slot-level-controls">
        <span class="slot-level-label">Level</span>
        <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
      </div>
      <div class="slot" data-slot="1"><div class="placeholder">Empty</div></div>
    </div>
    <div class="slot-container" data-slot="2">
      <div class="slot-level-controls">
        <span class="slot-level-label">Level</span>
        <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
      </div>
      <div class="slot" data-slot="2"><div class="placeholder">Empty</div></div>
    </div>
    <div class="slot-container" data-slot="3">
      <div class="slot-level-controls">
        <span class="slot-level-label">Level</span>
        <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
      </div>
      <div class="slot" data-slot="3"><div class="placeholder">Empty</div></div>
    </div>
    <div class="slot-container" data-slot="4">
      <div class="slot-level-controls">
        <span class="slot-level-label">Level</span>
        <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
      </div>
      <div class="slot" data-slot="4"><div class="placeholder">Empty</div></div>
    </div>
    <div class="slot-container" data-slot="5">
      <div class="slot-level-controls">
        <span class="slot-level-label">Level</span>
        <input type="number" class="slot-level-input" min="1" max="50" value="1" disabled>
      </div>
      <div class="slot" data-slot="5"><div class="placeholder">Empty</div></div>
    </div>
  </div>

  <div class="skill-search-divider"></div>

<div class="effect-row" data-effect="Friendship Bonus">
  <div class="effect-info">
    <span class="effect-name">Friendship Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Mood Effect">
  <div class="effect-info">
    <span class="effect-name">Mood Effect</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Speed Bonus">
  <div class="effect-info">
    <span class="effect-name">Speed Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Stamina Bonus">
  <div class="effect-info">
    <span class="effect-name">Stamina Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Power Bonus">
  <div class="effect-info">
    <span class="effect-name">Power Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Guts Bonus">
  <div class="effect-info">
    <span class="effect-name">Guts Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Wit Bonus">
  <div class="effect-info">
    <span class="effect-name">Wit Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Training Effectiveness">
  <div class="effect-info">
    <span class="effect-name">Training Effectiveness</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Speed">
  <div class="effect-info">
    <span class="effect-name">Initial Speed</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Stamina">
  <div class="effect-info">
    <span class="effect-name">Initial Stamina</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Power">
  <div class="effect-info">
    <span class="effect-name">Initial Power</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Guts">
  <div class="effect-info">
    <span class="effect-name">Initial Guts</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Wit">
  <div class="effect-info">
    <span class="effect-name">Initial Wit</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Friendship Gauge">
  <div class="effect-info">
    <span class="effect-name">Initial Friendship Gauge</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Race Bonus">
  <div class="effect-info">
    <span class="effect-name">Race Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Fan Bonus">
  <div class="effect-info">
    <span class="effect-name">Fan Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Hint Levels">
  <div class="effect-info">
    <span class="effect-name">Hint Levels</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Hint Frequency">
  <div class="effect-info">
    <span class="effect-name">Hint Frequency</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Specialty Priority">
  <div class="effect-info">
    <span class="effect-name">Specialty Priority</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Event Recovery">
  <div class="effect-info">
    <span class="effect-name">Event Recovery</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Event Effectiveness">
  <div class="effect-info">
    <span class="effect-name">Event Effectiveness</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Failure Protection">
  <div class="effect-info">
    <span class="effect-name">Failure Protection</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Energy Cost Reduction">
  <div class="effect-info">
    <span class="effect-name">Energy Cost Reduction</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Skill Point Bonus">
  <div class="effect-info">
    <span class="effect-name">Skill Point Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Wit Friendship Recovery">
  <div class="effect-info">
    <span class="effect-name">Wit Friendship Recovery</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="Initial Skill Points Up">
  <div class="effect-info">
    <span class="effect-name">Initial Skill Points Up</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
<div class="effect-row" data-effect="All Stats Bonus">
  <div class="effect-info">
    <span class="effect-name">All Stats Bonus</span>
    <span class="effect-value">0</span>
  </div>
  <div class="effect-cards"></div>
</div>
</div>
  
</div>

</div>

<script>
/* ------------- CONFIG ------------- */
const JSON_FILE = "transformed_supports.json";
const HIDE = { char_id: false, url_name: true };

/* ------------- STATE ------------- */
let cardsData = [];
const cardSections = document.getElementById('cardSections');
const slotContainers = Array.from(document.querySelectorAll('.slot-container'));
const slots = Array.from(document.querySelectorAll('.right-sidebar .slot'));
const clearAllBtn = document.getElementById('clearAllBtn');
const clearFiltersBtn = document.getElementById('clearFiltersBtn');
const selectedCardIds = new Set();
const sectionPages = new Map();
const slotListeners = new Map();
const SLOT_KEY = 'saved_slots';
const FILTER_KEYS = ['racecourse','length','direction','track','season','weather','strategy'];
let SKILL_SEARCH_KEYS = []; // This will be populated from localStorage
let showPresetCards = true; // Start with preset cards visible

/* ------------- CARD SEARCH STATE ------------- */
let cardSearchValue = '';

/* ------------- SKILL SEARCH STATE ------------- */
let skillSearches = JSON.parse(localStorage.getItem('skillSearches')) || [{ id: 'skillSearch1', value: '' }];
let searchCounter = skillSearches.length + 1;

/* ------------- TOGGLE BUTTON STATE ------------- */
const selectedRarities = new Set();
const selectedTypes = new Set();

/* ------------- NEW STATE VARIABLES ------------- */
let hideUncolored = false;
let sortBy = 'rarity';
let sortOrder = 'descending'; // CHANGED TO DESCENDING
let region = 'global';

/* ------------- ENHANCED LEVEL PERSISTENCE ------------- */
// This replaces the existing slotLevels initialization
const slotLevels = JSON.parse(localStorage.getItem('slotLevels')) || {};
const MAX_LEVELS = { 'R': 40, 'SR': 45, 'SSR': 50 };

// Store levels by support_id instead of by slot position
function saveCardLevel(supportId, level) {
    if (supportId) {
        slotLevels[supportId] = parseInt(level) || 1;
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
        console.log(`Saved level ${level} for card ${supportId}`);
    }
}

function getCardLevel(supportId) {
    return slotLevels[supportId] || 1;
}

function removeCardLevel(supportId) {
    if (slotLevels[supportId]) {
        delete slotLevels[supportId];
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
    }
}
/* ------------- DYNAMIC PAGINATION ------------- */
function calculateCardsPerPage() {
  const grid = document.querySelector('.cards');
  if (!grid) return 6; // fallback
  
  const gridWidth = grid.clientWidth;
  const cardWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w')) || 120;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 8;
  
  // Calculate how many cards fit in one row
  const cardsPerRow = Math.floor((gridWidth + gap) / (cardWidth + gap));
  
  // Always show at least 1 row, but you can adjust this if you want multiple rows
  const rowsPerPage = 1; // Change this to 2 or more if you want multiple rows per page
  
  return cardsPerRow * rowsPerPage;
}

function renderFilterPage(page, matches, grid, leftBtn, rightBtn, pageKey) {
  grid.innerHTML = '';
  const CARDS_PER_PAGE = calculateCardsPerPage();
  const startIdx = page * CARDS_PER_PAGE;
  const endIdx = startIdx + CARDS_PER_PAGE;
  const pageCards = matches.slice(startIdx, endIdx);
  
  pageCards.forEach(card => grid.appendChild(createCardElement(card)));

  const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);

  // Show/hide pagination controls based on whether pagination is needed
  const needsPagination = totalPages > 1;
  leftBtn.style.display = needsPagination ? 'flex' : 'none';
  rightBtn.style.display = needsPagination ? 'flex' : 'none';
  leftBtn.disabled = page === 0;
  rightBtn.disabled = page >= totalPages - 1;

  leftBtn.onclick = () => { 
    if (page > 0) {
      renderFilterPage(page-1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey, page-1);
      highlightSkills();
    }
  };
  
  rightBtn.onclick = () => { 
    if (page < totalPages - 1) {
      renderFilterPage(page+1, matches, grid, leftBtn, rightBtn, pageKey); 
      sectionPages.set(pageKey, page+1);
      highlightSkills();
    }
  };
  
  highlightSkills();
}

function renderCardSearchPage(page, matches, grid, leftBtn, rightBtn, pageKey) {
  grid.innerHTML = '';
  const CARDS_PER_PAGE = calculateCardsPerPage();
  const startIdx = page * CARDS_PER_PAGE;
  const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
  pageCards.forEach(card => grid.appendChild(createCardElement(card)));

  const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
  
  // Show/hide pagination controls
  const needsPagination = totalPages > 1;
  leftBtn.style.display = needsPagination ? 'flex' : 'none';
  rightBtn.style.display = needsPagination ? 'flex' : 'none';
  leftBtn.disabled = page === 0;
  rightBtn.disabled = page >= totalPages - 1;
  
  highlightSkills();
}

function renderSkillSearchPage(page, matches, grid, leftBtn, rightBtn, pageKey) {
  grid.innerHTML = '';
  const CARDS_PER_PAGE = calculateCardsPerPage();
  const startIdx = page * CARDS_PER_PAGE;
  const pageCards = matches.slice(startIdx, startIdx + CARDS_PER_PAGE);
  pageCards.forEach(card => grid.appendChild(createCardElement(card)));

  const totalPages = Math.ceil(matches.length / CARDS_PER_PAGE);
  
  // Show/hide pagination controls
  const needsPagination = totalPages > 1;
  leftBtn.style.display = needsPagination ? 'flex' : 'none';
  rightBtn.style.display = needsPagination ? 'flex' : 'none';
  leftBtn.disabled = page === 0;
  rightBtn.disabled = page >= totalPages - 1;
  
  highlightSkills();
}

/* ------------- SORTING FUNCTION ------------- */
function sortCards(cards, sortBy, order) {
  const sortedCards = [...cards];
  
  sortedCards.sort((a, b) => {
    let aValue, bValue;
    
    switch (sortBy) {
      case 'rarity':
        if (a.rarity !== b.rarity) {
          return order === 'ascending' ? a.rarity - b.rarity : b.rarity - a.rarity;
        }
        // If same rarity, sort by appropriate release date
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'name':
        aValue = a.char_name.toLowerCase();
        bValue = b.char_name.toLowerCase();
        
        // First, compare by name based on the sort order
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        // If names are exactly the same, ALWAYS sort by rarity descending (SSR first)
        return b.rarity - a.rarity; // SSR > SR > R always
        
      case 'type':
        aValue = a.type;
        bValue = b.type;
        
        // First, compare by type based on the sort order
        if (aValue !== bValue) {
          if (aValue < bValue) return order === 'ascending' ? -1 : 1;
          if (aValue > bValue) return order === 'ascending' ? 1 : -1;
        }
        
        // If types are exactly the same, ALWAYS sort by rarity descending (SSR first)
        return b.rarity - a.rarity; // SSR > SR > R always
        
      case 'release':
        // Use appropriate release date based on region
        aValue = region === 'global' ? a.release_en : a.release;
        bValue = region === 'global' ? b.release_en : b.release;
        break;
        
      case 'support_id':
        aValue = a.support_id;
        bValue = b.support_id;
        break;
        
      default:
        // Handle effect sorting (numeric values)
        if (!isNaN(parseInt(sortBy))) {
          const effectId = parseInt(sortBy);
          aValue = getEffectValueForSorting(a, effectId) || 0;
          bValue = getEffectValueForSorting(b, effectId) || 0;
          break;
        }
        return 0;
    }
    
    // Handle empty values
    if (!aValue && bValue) return order === 'ascending' ? -1 : 1;
    if (aValue && !bValue) return order === 'ascending' ? 1 : -1;
    if (!aValue && !bValue) return 0;
    
    // For dates, convert to timestamps for proper comparison
    if (sortBy === 'release' || (sortBy === 'rarity' && a.rarity === b.rarity)) {
      try {
        const aDate = new Date(aValue);
        const bDate = new Date(bValue);
        if (isNaN(aDate.getTime()) && !isNaN(bDate.getTime())) return order === 'ascending' ? -1 : 1;
        if (!isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return order === 'ascending' ? 1 : -1;
        if (isNaN(aDate.getTime()) && isNaN(bDate.getTime())) return 0;
        
        aValue = aDate.getTime();
        bValue = bDate.getTime();
      } catch (e) {
        console.warn('Date parsing failed for:', aValue, bValue);
      }
    }
    
    // Compare values
    if (aValue < bValue) return order === 'ascending' ? -1 : 1;
    if (aValue > bValue) return order === 'ascending' ? 1 : -1;
    return 0;
  });
  
  return sortedCards;
}

/* ------------- CARD NAME SEARCH ------------- */
function setupCardSearch() {
  const cardSearchInput = document.getElementById('cardSearch');
  const savedCardSearch = localStorage.getItem('cardSearch');
  
  if (savedCardSearch) {
    cardSearchValue = savedCardSearch;
    cardSearchInput.value = savedCardSearch;
  }
  
  cardSearchInput.addEventListener('input', (e) => {
    cardSearchValue = e.target.value.trim().toLowerCase();
    localStorage.setItem('cardSearch', cardSearchValue);
    sectionPages.clear();
    renderSections();
  });
}

function renderCardSearchSection() {
  // Get the current filtered cards based on all active filters
  let filteredCards = cardsData.filter(card => {
    if (region === 'global') {
      // For Global, only show cards that have release_en date (released globally)
      if (!card.release_en || card.release_en === '') return false;
    }
    
    // Apply rarity filters
    if (selectedRarities.size > 0) {
      const hasRarity = 
        (selectedRarities.has('R') && card.rarity === 1) ||
        (selectedRarities.has('SR') && card.rarity === 2) ||
        (selectedRarities.has('SSR') && card.rarity === 3);
      if (!hasRarity) return false;
    }
    
    // Apply type filters
    if (selectedTypes.size > 0 && !selectedTypes.has(card.type)) {
      return false;
    }
    
    return true;
  });
  
  // Filter by card name search
  const matches = filteredCards.filter(card => {
    const cardName = card.char_name.toLowerCase();
    return cardName.includes(cardSearchValue);
  });
  
  // Sort matches: SSR > SR > R, then by type order
  const typeOrder = { 'speed': 0, 'stamina': 1, 'power': 2, 'guts': 3, 'intelligence': 4, 'friend': 5, 'group': 6 };
  
  matches.sort((a, b) => {
    // First by rarity (SSR first)
    if (a.rarity !== b.rarity) {
      return b.rarity - a.rarity; // SSR (3) > SR (2) > R (1)
    }
    // Then by type order
    return typeOrder[a.type] - typeOrder[b.type];
  });

  // COMPLETELY HIDE SECTION IF NO MATCHES
  if (matches.length === 0) {
    return; // Don't create any section at all
  }

  // Convert search value to proper case for display
  const displaySearchValue = cardSearchValue
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'card-search-header';
  header.textContent = `Card Search: "${displaySearchValue}" (${matches.length} cards)`;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `cardSearch-${cardSearchValue}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  renderSkillSearchPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);

leftBtn.addEventListener('click', () => {
  const newPage = sectionPages.get(pageKey) - 1;
  if (newPage >= 0) {
    sectionPages.set(pageKey, newPage);
    renderSkillSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
  }
});

rightBtn.addEventListener('click', () => {
  const totalPages = Math.ceil(matches.length / calculateCardsPerPage());
  const newPage = sectionPages.get(pageKey) + 1;
  if (newPage < totalPages) {
    sectionPages.set(pageKey, newPage);
    renderSkillSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
  }
});
}

/* ------------- DYNAMIC SKILL SEARCH ------------- */
const maxSearches = 30;

function setupDynamicSkillSearch() {
  const addSearchBtn = document.getElementById('addSearchBtn');
  const skillSearchGroup = document.getElementById('skillSearchGroup');
  
  if (!skillSearchGroup) {
    console.error('Skill search group not found!');
    return;
  }
  
  // Clear existing search boxes first
  const existingContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  existingContainers.forEach(container => container.remove());
  
  // Recreate search boxes from saved state
  skillSearches.forEach((search, index) => {
    createSearchBox(search.id, search.value, index === 0); // First one can't be removed
  });
  
  // CRITICAL FIX: Update SKILL_SEARCH_KEYS array with ACTUAL current values
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  // CRITICAL FIX: Also update the search values in the inputs
  skillSearches.forEach(search => {
    const input = document.getElementById(search.id);
    if (input) {
      input.value = search.value;
    }
  });
  
  if (addSearchBtn) {
    addSearchBtn.addEventListener('click', addSearchBox);
  }
  
  // Setup color picker for all search boxes
  skillSearches.forEach(search => {
    setupColorPicker(search.id);
  });
}

function createSearchBox(searchId, value = '') {
  const searchContainer = document.createElement('div');
  searchContainer.className = 'search-input-container';
  
  // FORCE green color for all new boxes, ignore localStorage for new creations
  const isNewBox = !document.getElementById(searchId);
  const savedColor = isNewBox ? 'green' : (localStorage.getItem(`color_${searchId}`) || 'green');
  
  searchContainer.innerHTML = `
    <div class="color-picker ${savedColor}" data-search-id="${searchId}" data-color="${savedColor}"></div>
    <input type="text" id="${searchId}" class="skill-search" placeholder="Search skill" value="${value}">
    <button class="remove-search-btn" data-search-id="${searchId}" title="Remove search">
      ×
    </button>
  `;

  const skillSearchGroup = document.getElementById('skillSearchGroup');
  if (!skillSearchGroup) {
    console.error('skillSearchGroup element not found!');
    return;
  }
  
  skillSearchGroup.appendChild(searchContainer);

  setupSearchInput(searchId);
  setupRemoveButton(searchId);
  setupColorPicker(searchId);
}

/* ------------- COLOR PICKER FUNCTIONALITY ------------- */
const colorSequence = [
  'green', 'blue', 'orange', 'red',
  'green-border', 'blue-border', 'orange-border', 'red-border'
];

function setupColorPicker(searchId) {
  const colorPicker = document.querySelector(`.color-picker[data-search-id="${searchId}"]`);
  if (!colorPicker) return;

  // Load saved color - default to green instead of red
  const savedColor = localStorage.getItem(`color_${searchId}`) || 'green';
  colorPicker.className = `color-picker ${savedColor}`;
  colorPicker.dataset.color = savedColor;

  colorPicker.addEventListener('click', () => {
    const currentColor = colorPicker.dataset.color;
    const currentIndex = colorSequence.indexOf(currentColor);
    const nextIndex = (currentIndex + 1) % colorSequence.length;
    const nextColor = colorSequence[nextIndex];
    
    colorPicker.className = `color-picker ${nextColor}`;
    colorPicker.dataset.color = nextColor;
    
    localStorage.setItem(`color_${searchId}`, nextColor);
    
    // Update highlighting immediately
    highlightSkills();
  });
}

function addSearchBox() {
  if (skillSearches.length >= 30) return;

  const newId = `skillSearch${searchCounter}`;
  searchCounter++;
  
  // Add to our state with empty value
  skillSearches.push({ id: newId, value: '' });
  saveSkillSearches();
  
  // Create the UI element - ALWAYS use default green color for new boxes
  createSearchBox(newId, '');
  
  // CRITICAL: Force the new box to be green, regardless of what's in localStorage
  const newColorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
  if (newColorPicker) {
    newColorPicker.className = 'color-picker green';
    newColorPicker.dataset.color = 'green';
    localStorage.setItem(`color_${newId}`, 'green');
  }
  
  // CRITICAL: Update the global array immediately
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  sectionPages.clear();
  renderSections();
  highlightSkills();
  highlightSelectedSkills();
}

function saveSkillSearches() {
  // Update values from current inputs before saving
  skillSearches.forEach(search => {
    const input = document.getElementById(search.id);
    if (input) {
      search.value = input.value;
    }
  });
  localStorage.setItem('skillSearches', JSON.stringify(skillSearches));
}

// Modified setupSearchInput to use our persistence system
function setupSearchInput(searchId) {
  const input = document.getElementById(searchId);
  if (!input) return;

  // Find the saved value
  const savedSearch = skillSearches.find(search => search.id === searchId);
  if (savedSearch) {
    input.value = savedSearch.value;
  }

  input.addEventListener('input', () => {
    // Update our state
    const search = skillSearches.find(s => s.id === searchId);
    if (search) {
      search.value = input.value;
      saveSkillSearches();
    }
    
    sectionPages.clear();
    renderSections();
    highlightSkills(); // Add this line
    highlightSelectedSkills(); // Add this line
  });
}

// Modified setupRemoveButton
function setupRemoveButton(searchId) {
  const removeBtn = document.querySelector(`.remove-search-btn[data-search-id="${searchId}"]`);
  if (!removeBtn) return;

  // Remove any existing listeners to prevent duplicates
  const newRemoveBtn = removeBtn.cloneNode(true);
  removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);

  newRemoveBtn.addEventListener('click', () => {
    removeSearchBox(searchId);
  });
}

// Update the existing removeSearchBox function to use our new system
function removeSearchBox(searchId) {
  // Don't remove if it's the last search box
  if (skillSearches.length <= 1) {
    // If it's the last one, just clear the value and reset color
    const input = document.getElementById(searchId);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${searchId}"]`);
    
    if (input) input.value = '';
    if (colorPicker) {
      colorPicker.className = 'color-picker green';
      colorPicker.dataset.color = 'green';
      localStorage.setItem(`color_${searchId}`, 'green');
    }
    
    // Update state
    const search = skillSearches.find(s => s.id === searchId);
    if (search) {
      search.value = '';
      saveSkillSearches();
    }
    
    sectionPages.clear();
    renderSections();
    highlightSkills();
    highlightSelectedSkills();
    return;
  }
  
  // Remove from UI first
  const container = document.querySelector(`.search-input-container input[id="${searchId}"]`)?.parentElement;
  if (container) {
    container.remove();
  }
  
  // Then update state
  skillSearches = skillSearches.filter(search => search.id !== searchId);
  saveSkillSearches();
  
  // Remove from localStorage
  localStorage.removeItem(`color_${searchId}`);
  
  // Update global array
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  // Only reorganize if we removed a box that's NOT the last one
  // This prevents unnecessary reorganization when removing the last box
  const removedIndex = parseInt(searchId.replace('skillSearch', '')) || 0;
  if (removedIndex < skillSearches.length + 1) {
    reorganizeSearchBoxes();
  } else {
    // If we removed the last box, just update the UI
    sectionPages.clear();
    renderSections();
    highlightSkills();
    highlightSelectedSkills();
  }
}

function reorganizeSearchBoxes() {
  // Sort searches by their numeric ID to maintain order
  skillSearches.sort((a, b) => {
    const aNum = parseInt(a.id.replace('skillSearch', '')) || 0;
    const bNum = parseInt(b.id.replace('skillSearch', '')) || 0;
    return aNum - bNum;
  });
  
  // Get all current search containers and their colors BEFORE removing them
  const existingContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  const currentColors = [];
  
  existingContainers.forEach((container, index) => {
    const colorPicker = container.querySelector('.color-picker');
    const color = colorPicker ? colorPicker.dataset.color : 'green';
    currentColors.push(color);
  });
  
  // Clear all existing search containers
  existingContainers.forEach(container => container.remove());
  
  // Recreate all search boxes with new sequential IDs and PRESERVE their colors
  skillSearches.forEach((search, index) => {
    const newId = `skillSearch${index + 1}`;
    
    // Get the color from the current position (not the old ID)
    // If we have more boxes than saved colors, use green for new ones
    const color = currentColors[index] || 'green';
    
    // Update the search ID in our state
    search.id = newId;
    
    // Create new search box with the preserved color
    createSearchBox(newId, search.value);
    
    // Immediately set the color to match the preserved one
    const newColorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
    if (newColorPicker) {
      newColorPicker.className = `color-picker ${color}`;
      newColorPicker.dataset.color = color;
      localStorage.setItem(`color_${newId}`, color);
    }
  });
  
  // Update the global array
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
  
  // Update search counter
  searchCounter = skillSearches.length + 1;
  
  // Save the reorganized state
  saveSkillSearches();
  
  // Update highlighting
  highlightSkills();
  highlightSelectedSkills();
}

/* ------------- TOGGLE BUTTON SETUP ------------- */
function setupToggleButtons() {
  // Rarity buttons
  document.querySelectorAll('.rarity-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const rarity = button.dataset.rarity;
      if (selectedRarities.has(rarity)) {
        selectedRarities.delete(rarity);
        button.classList.remove('active');
      } else {
        selectedRarities.add(rarity);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });

  // Type buttons
  document.querySelectorAll('.type-buttons .toggle-button').forEach(button => {
    button.addEventListener('click', () => {
      const type = button.dataset.type;
      if (selectedTypes.has(type)) {
        selectedTypes.delete(type);
        button.classList.remove('active');
      } else {
        selectedTypes.add(type);
        button.classList.add('active');
      }
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- UTIL ------------- */
function normalizeSkill(s){ return String(s||'').replace(/[◎○]/g,'').trim().toLowerCase(); }
function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase(); }
function getLengthCategory(distance){ if(distance<=1400)return'Sprint'; if(distance<=1800)return'Mile'; if(distance<=2400)return'Medium'; return'Long'; }
function isStandardDistance(distance){ return distance%400===0; }
const typeMap = { "speed":"00","stamina":"01","power":"02","guts":"03","intelligence":"04","friend":"05","group":"06" };
function escapeHtml(s){ return String(s).replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

/* ------------- AUTO-RESET PRESETS ------------- */
function setupPresetReset() {
  // Get all filter elements that should reset presets
  const resetFilters = [
    'racecourse', 'length', 'direction', 'track', 'season', 'weather'
  ];
  
  resetFilters.forEach(filterId => {
    const element = document.getElementById(filterId);
    if (element) {
      element.addEventListener('change', () => {
        // Only reset if the filter actually has a value selected
        if (element.value) {
          const presetsSelect = document.getElementById('presets');
          if (presetsSelect && presetsSelect.value) {
            presetsSelect.value = '';
            localStorage.removeItem('filter_presets');
          }
        }
      });
    }
  });
}

/* ------------- Fetch JSON ------------- */
fetch(JSON_FILE)
  .then(r => { 
    if (!r.ok) throw new Error(`Failed to fetch JSON: ${r.status} ${r.statusText}`); 
    return r.json(); 
  })
  .then(data => {
    if (!Array.isArray(data)) {
      throw new Error('JSON data is not an array');
    }
    
    cardsData = data.map(card => ({
      ...card,
      char_id: card.char_id || 0,
      char_name: card.char_name || 'Unknown',
      hint_skills: card.hint_skills || [],
      event_skills: card.event_skills || [],
      event_skills_en: card.event_skills_en || [],
      rarity: card.rarity || 1,
      release: card.release || '',
      release_en: card.release_en || '',
      support_id: card.support_id || 0,
      type: (card.type || '').toLowerCase(),
      url_name: card.url_name || ''
    }));

    // Initialize all components with error handling
    try {
      setupFilterPersistence();
      setupToggleButtons();
      setupSortingControls();
      setupDynamicSkillSearch();
      setupPresets();
      setupPresetReset();
      setupTogglePresetCards();
      setupCardSearch();
      setupCopyPasteButtons();
      loadSlotsFromLocalStorage(); // This now has proper waiting logic
      setupClearAllSearches();
      updateSelectedSkillsList();
      setupDeckCopyPaste();
      
      // Final refresh to ensure everything is synced - ADD THESE LINES:
      setTimeout(() => {
        sectionPages.clear();
        renderSections();
        updateAllSlotDisplays();
        
        // Double check after everything settles
        setTimeout(() => {
          ensureSlotsLoaded();
          updateAllSlotDisplays();
        }, 500);
      }, 500);
    } catch (error) {
      console.error('Error during setup:', error);
    }
  })
  .catch(err => {
    console.error('Could not load JSON:', err);
    cardSections.innerHTML = `
      <div style="opacity:0.7;padding:12px;text-align:center;">
        <h3>Error loading data</h3>
        <p>${err.message}</p>
        <p>Check browser console for details.</p>
      </div>
    `;
  });

/* ------------- PRESETS ------------- */
const PRESETS_JSON_FILE = "champions_meeting.json";

let presetRaceNumbers = new Map(); // Store race numbers by title

function formatPresetDate(dateString) {
  const date = new Date(dateString);
  const month = date.toLocaleString('en-US', { month: 'short' });
  const year = date.getFullYear();
  return `${month} ${year}`;
}

function createPresetLabel(cup, index) {
  const distance = cup.distance === "Mile" ? "MILE" : cup.distance;
  const trackType = cup.aptitude === "Turf" ? "Turf" : "Dirt";
  const length = cup.length.replace(/\s*m/g, 'm');
  
  // Store the race number for this cup title
  presetRaceNumbers.set(cup.title, index + 1);
  
  return `${index + 1}. ${cup.title} — ${cup.racecourse} ${trackType} ${length} ${cup.track_conditions}`;
}

function setupPresets() {
  const presetsSelect = document.getElementById('presets');
  if (!presetsSelect) return;

  const savedPreset = localStorage.getItem('filter_presets');
  const hasManuallySelectedNone = localStorage.getItem('manuallySelectedNone') === 'true';

  fetch(PRESETS_JSON_FILE)
    .then(response => {
      if (!response.ok) throw new Error('Failed to fetch presets JSON');
      return response.json();
    })
    .then(data => {
      presetsSelect.innerHTML = '<option value="">-- Select --</option>';
      
      // Sort cups by start_date to ensure proper numbering
      const sortedCups = data.cups.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
      
      sortedCups.forEach((cup, index) => {
        const option = document.createElement('option');
        option.value = cup.title;
        option.textContent = createPresetLabel(cup, index);
        option.dataset.cupData = JSON.stringify(cup);
        presetsSelect.appendChild(option);
      });
      
      // Set default selection logic
      if (savedPreset) {
        presetsSelect.value = savedPreset;
      } else if (!hasManuallySelectedNone && sortedCups.length >= 2) {
        // On first visit, automatically select the 2nd option (Taurus Cup)
        const secondCup = sortedCups[0]; // Index 1 is the 2nd item
        presetsSelect.value = secondCup.title;
        localStorage.setItem('filter_presets', secondCup.title);
        
        // Apply the preset immediately
        applyPreset(secondCup);
      }
      
      presetsSelect.addEventListener('change', function() {
        const selectedValue = this.value;
        localStorage.setItem('filter_presets', selectedValue);
        
        if (selectedValue) {
          const selectedOption = this.options[this.selectedIndex];
          const cup = JSON.parse(selectedOption.dataset.cupData);
          applyPreset(cup);
          
          // Clear the manual selection flag when a preset is chosen
          localStorage.removeItem('manuallySelectedNone');
        } else {
          // User manually selected "-- Select --"
          localStorage.setItem('manuallySelectedNone', 'true');
          clearPresetFilters();
          sectionPages.clear();
          renderSections();
        }
      });
    })
    .catch(err => {
      console.error('Could not load presets:', err);
      const option = document.createElement('option');
      option.textContent = 'Error loading presets';
      option.disabled = true;
      presetsSelect.appendChild(option);
    });
}

function clearPresetFilters() {
  // Only clear the preset filters (racecourse through strategy)
  const presetFilterIds = ['racecourse', 'length', 'direction', 'track', 'season', 'weather', 'strategy'];
  
  presetFilterIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.value = '';
      localStorage.removeItem('filter_' + id);
    }
  });
  
  // Update UI without affecting other filters
  sectionPages.clear();
  renderSections();
  highlightSkills();
}

function applyPreset(cup) {
  document.getElementById('racecourse').value = cup.racecourse;
  document.getElementById('length').value = cup.length.replace(' m', '');
  document.getElementById('direction').value = cup.direction;
  document.getElementById('track').value = cup.track_conditions;
  
  // Fix season mapping: JSON has "Autumn" but dropdown uses "Fall"
  const seasonMap = {
    'Autumn': 'Fall', // Map JSON "Autumn" to dropdown "Fall"
    'Spring': 'Spring', 
    'Summer': 'Summer',
    'Winter': 'Winter'
  };
  document.getElementById('season').value = seasonMap[cup.season] || cup.season;
  
  // Fix weather mapping: JSON has "Rain"/"Snow" but dropdown uses "Rainy"/"Snowy"
  const weatherMap = {
    'Rain': 'Rainy', // Map JSON "Rain" to dropdown "Rainy"
    'Snow': 'Snowy', // Map JSON "Snow" to dropdown "Snowy"
    'Sunny': 'Sunny',
    'Cloudy': 'Cloudy'
  };
  document.getElementById('weather').value = weatherMap[cup.weather] || cup.weather;
  
  document.getElementById('strategy').value = '';
  
  FILTER_KEYS.forEach(id => {
    const el = document.getElementById(id);
    if (el && el.value) localStorage.setItem('filter_' + id, el.value);
  });
  
  // Clear manual selection flag when applying a preset
  localStorage.removeItem('manuallySelectedNone');
  
  sectionPages.clear();
  renderSections();
}

FILTER_KEYS.push('presets');

/* ------------- SETUP NEW CONTROLS ------------- */
function setupSortingControls() {
  const sortBySelect = document.getElementById('sortBy');
  const sortOrderBtn = document.getElementById('sortOrder');
  const regionSelect = document.getElementById('region');

  // Load saved values
  const savedSortBy = localStorage.getItem('sortBy');
  const savedSortOrder = localStorage.getItem('sortOrder');
  const savedRegion = localStorage.getItem('region');

  if (savedSortBy) {
    sortBy = savedSortBy;
    sortBySelect.value = savedSortBy;
  } else {
    // SET DEFAULT TO RARITY
    sortBySelect.value = 'rarity';
  }
  
  if (savedSortOrder) {
    sortOrder = savedSortOrder;
    sortOrderBtn.textContent = sortOrder === 'ascending' ? '↑' : '↓';
    sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
  } else {
    // SET DEFAULT TO DESCENDING
    sortOrder = 'descending';
    sortOrderBtn.textContent = '↓';
    sortOrderBtn.classList.remove('ascending');
  }
  
  if (savedRegion) {
    region = savedRegion;
    regionSelect.value = savedRegion;
  } else {
    // SET DEFAULT TO GLOBAL
    regionSelect.value = 'global';
  }

  // Event listeners
sortBySelect.addEventListener('change', (e) => {
  sortBy = e.target.value;
  localStorage.setItem('sortBy', sortBy);
  sectionPages.clear();
  renderSections();
  
  // Update slot displays with new sort data
  setTimeout(() => {
    updateAllSlotDisplays(); // Add this line
  }, 50);
});

sortOrderBtn.addEventListener('click', () => {
  sortOrder = sortOrder === 'ascending' ? 'descending' : 'ascending';
  sortOrderBtn.textContent = sortOrder === 'ascending' ? '↑' : '↓';
  sortOrderBtn.classList.toggle('ascending', sortOrder === 'ascending');
  localStorage.setItem('sortOrder', sortOrder);
  sectionPages.clear();
  renderSections();
  
  // Update slot displays with new sort data
  setTimeout(() => {
    updateAllSlotDisplays(); // Add this line
  }, 50);
});

  regionSelect.addEventListener('change', (e) => {
    region = e.target.value;
    localStorage.setItem('region', region);
    sectionPages.clear();
    
    // Update all slots with the new region's skills
    updateSlotsForRegion();
    
    // Update the skills list
    updateSelectedSkillsList();
    highlightSkills(); // Add this line
    highlightSelectedSkills(); // Add this line
    
    renderSections(); // This will re-render with updated data below names
  });
}

// Add updateSlotsForRegion function here
function updateSlotsForRegion() {
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        // Remove the existing slot content
        if (slotListeners.has(slot)) {
          slot.removeEventListener('click', slotListeners.get(slot));
          slotListeners.delete(slot);
        }
        
        // Re-add the card with updated skills for the current region
        addToSlot(card, slot, false); // false to not trigger save (we'll do it once at the end)
      }
    }
  });
  
  // Save the updated slots
  saveSlotsToLocalStorage();
  
  // Re-apply highlighting to show/hide skills based on new region
  highlightSkills();
  updateSkillVisibility();
}

// In setupHideUncoloredCheckbox
function setupHideUncoloredCheckbox() {
  const hideUncoloredCheckbox = document.getElementById('hideUncolored');
  const savedHideUncolored = localStorage.getItem('hideUncolored');

  if (savedHideUncolored) {
    hideUncolored = savedHideUncolored === 'true';
    hideUncoloredCheckbox.checked = hideUncolored;
  }

  hideUncoloredCheckbox.addEventListener('change', (e) => {
    hideUncolored = e.target.checked;
    localStorage.setItem('hideUncolored', hideUncolored);
    updateSkillVisibility(); // Update visibility when checkbox changes
    updateSelectedSkillsVisibility(); // NEW: Also update selected skills visibility
  });
}

let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;

// Show different data based on current sort selection
const sortByValue = document.getElementById('sortBy').value;
const hideDataOptions = ['rarity', 'name', 'type'];

if (!hideDataOptions.includes(sortByValue)) {
  if (sortByValue === 'support_id') {
    nameHtml += `<div class="effect-text">ID: ${card.support_id}</div>`;
  } else if (sortByValue === 'release') {
    const releaseDate = region === 'global' ? card.release_en : card.release;
    if (releaseDate && releaseDate !== '') {
      const formattedDate = formatDateForDisplay(releaseDate);
      nameHtml += `<div class="effect-text">${formattedDate}</div>`;
    }
  } else if (!isNaN(parseInt(sortByValue))) {
    // Effect sorting - ALWAYS show the effect value at MAX LEVEL, even if 0
    const effectValue = getEffectValueForSorting(card, parseInt(sortByValue));
    if (effectValue !== null) {
      const effectName = EFFECT_TYPES[parseInt(sortByValue)];
      const unit = EFFECT_UNITS[parseInt(sortByValue)] || "";
      const formattedValue = Number.isInteger(effectValue) ? 
        effectValue.toString() : effectValue.toFixed(1);
      
      // Format with appropriate unit
      let displayValue;
      if (unit === "Lv ") {
        displayValue = unit + formattedValue;
      } else {
        displayValue = formattedValue + unit;
      }
      
      nameHtml += `<div class="effect-text">${effectName}: ${displayValue}</div>`;
    }
  } else {
    // Default: show character ID (only if not hidden)
    if(!HIDE.char_id) nameHtml += `<div class="effect-text">ID: ${card.char_id}</div>`;
  }
  
  if(!HIDE.url_name && card.url_name) nameHtml += `<div class="effect-text">${escapeHtml(card.url_name)}</div>`;

  el.innerHTML = `
    <div class="type-icon"><img src="${typeImg}" alt="${escapeHtml(card.type)}"></div>
    <img src="${imgSrc}" alt="${escapeHtml(card.char_name)}">
    ${nameHtml}
    <div class="skills">${skillsHTML}</div>
  `;

  // Replace your current card click handler in createCardElement():
  el.addEventListener('click', ()=> {
    const slot = slots.find(s => Number(s.dataset.cardId) === card.char_id);
    if(slot) {
        removeFromSlot(slot, card);
    } else {
        addToSlot(card);
    }
    
    // INSTEAD of calling renderSections(), just update the disabled states
    updateCardDisabledStates();
  });

  // Ensure initial disabled state is set when card is created
  if(selectedCardIds.has(card.char_id)) {
    el.classList.add('disabled');
    // Add duplicate label if needed
    if (!el.querySelector('[data-dup-label]')) {
      const dupLabel = document.createElement('div');
      dupLabel.textContent = 'Duplicate Support';
      dupLabel.setAttribute('data-dup-label', 'true');
      dupLabel.style.position = 'absolute';
      dupLabel.style.top = '0';
      dupLabel.style.left = '0';
      dupLabel.style.width = '100%';
      dupLabel.style.background = 'red';
      dupLabel.style.color = 'white';
      dupLabel.style.fontSize = '9px';
      dupLabel.style.fontWeight = 'bold';
      dupLabel.style.textAlign = 'center';
      dupLabel.style.padding = '2px 0';
      dupLabel.style.borderTopLeftRadius = '4px';
      dupLabel.style.borderTopRightRadius = '4px';
      dupLabel.style.zIndex = '10';
      el.appendChild(dupLabel);
    }
  }

  return el;
}

// Add this new function that only updates disabled states without full re-render:
function updateCardDisabledStates() {
  const allCards = document.querySelectorAll('.card');
  allCards.forEach(cardEl => {
    const cardId = parseInt(cardEl.dataset.id);
    if (selectedCardIds.has(cardId)) {
      cardEl.classList.add('disabled');
      // Ensure duplicate label exists
      if (!cardEl.querySelector('[data-dup-label]')) {
        const dupLabel = document.createElement('div');
        dupLabel.textContent = 'Duplicate Support';
        dupLabel.setAttribute('data-dup-label', 'true');
        dupLabel.style.position = 'absolute';
        dupLabel.style.top = '0';
        dupLabel.style.left = '0';
        dupLabel.style.width = '100%';
        dupLabel.style.background = 'red';
        dupLabel.style.color = 'white';
        dupLabel.style.fontSize = '9px';
        dupLabel.style.fontWeight = 'bold';
        dupLabel.style.textAlign = 'center';
        dupLabel.style.padding = '2px 0';
        dupLabel.style.borderTopLeftRadius = '4px';
        dupLabel.style.borderTopRightRadius = '4px';
        dupLabel.style.zIndex = '10';
        cardEl.appendChild(dupLabel);
      }
    } else {
      cardEl.classList.remove('disabled');
      const dupLabel = cardEl.querySelector('[data-dup-label]');
      if (dupLabel) {
        dupLabel.remove();
      }
    }
  });
  
  // Update skill highlighting without full re-render
  highlightSkills();
  highlightSelectedSkills();
}

/* ------------- Slot handling & persistence ------------- */
function saveSlotsToLocalStorage() {
  const slotData = slots.map(s => s.dataset.supportId || null);
  localStorage.setItem(SLOT_KEY, JSON.stringify(slotData));
}

/* ------------- ENHANCED SLOT LOADING ------------- */
function loadSlotsFromLocalStorage() {
  const saved = localStorage.getItem(SLOT_KEY);
  if (!saved) return;
  
  const slotData = JSON.parse(saved);
  let loadedCount = 0;
  
  // Wait for cardsData to be available
  const waitForData = setInterval(() => {
    if (cardsData && cardsData.length > 0) {
      clearInterval(waitForData);
      
      slotData.forEach((supportId, index) => {
        if (supportId && supportId !== 'empty') {
          const card = cardsData.find(c => String(c.support_id) === String(supportId));
          if (card) {
            const slot = slots[index];
            addToSlot(card, slot, false);
            loadedCount++;
          }
        }
      });
      
      console.log(`Loaded ${loadedCount} cards into slots`);
      
      // Force refresh slot displays after a short delay to ensure DOM is ready
      setTimeout(() => {
        updateAllSlotDisplays();
        // Double check after everything is settled
        setTimeout(updateAllSlotDisplays, 200);
      }, 300);
    }
  }, 100);
  
  // Timeout after 5 seconds
  setTimeout(() => {
    clearInterval(waitForData);
    if (loadedCount === 0) {
      console.warn('Failed to load slot data - cardsData not available');
    }
  }, 5000);
}

/* ------------- UNIQUE EFFECTS CALCULATION ------------- */
function shouldApplyUniqueEffects(card, level) {
  if (!card.unique || !card.unique.effects || card.unique.effects.length === 0) {
    return false;
  }
  
  const rarity = card.rarity;
  const threshold = rarity === 1 ? 20 : rarity === 2 ? 25 : 30;
  
  return level >= threshold;
}

function getUniqueEffectValue(card, effectType) {
  if (!card.unique || !card.unique.effects) return 0;
  
  const uniqueEffect = card.unique.effects.find(effect => effect.type === effectType);
  return uniqueEffect ? uniqueEffect.value : 0;
}

function calculateEffectContributions() {
  console.log('Calculating effect contributions...');
  const contributions = {};
  
  // Initialize structure for each effect type
  Object.values(EFFECT_TYPES).forEach(effectName => {
    contributions[effectName] = {
      total: 0,
      cards: [] // Array of { supportId, value, level, char_name }
    };
  });

  // Iterate through all slots with cards
  const slots = document.querySelectorAll('.slot');
  
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const slotContainer = slot.closest('.slot-container');
      const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
      const level = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
      
      // Find card in supports.json (which has the effects data)
      const card = findCardWithEffects(supportId);
      
      if (card && card.effects) {
        // Calculate values for each effect at this card's level
        card.effects.forEach(effectData => {
          const effectId = effectData[0];
          const effectName = EFFECT_TYPES[effectId];
          
          if (effectName) {
            let value = getEffectValueAtLevel(effectData, level);
            
            // ADD UNIQUE EFFECTS IF LEVEL THRESHOLD IS MET
            if (shouldApplyUniqueEffects(card, level)) {
              const uniqueValue = getUniqueEffectValue(card, effectId);
              value += uniqueValue;
            }
            
            if (value > 0) { // Only show cards that actually contribute
              contributions[effectName].total += value;
              contributions[effectName].cards.push({
                supportId: supportId,
                value: value,
                level: level,
                char_name: card.char_name,
                hasUnique: shouldApplyUniqueEffects(card, level) && getUniqueEffectValue(card, effectId) > 0
              });
            }
          }
        });
      }
    }
  });
  
  return contributions;
}

// Update the card display in slots to show unique effects
// Enhanced addToSlot function with better level persistence
function addToSlot(card, targetSlot = null, save = true) {
    const freeSlot = targetSlot || slots.find(s => !s.dataset.cardId);
    if (!freeSlot) return;

    // Find the container for this slot
    const slotContainer = freeSlot.closest('.slot-container');
    if (!slotContainer) return;

    // Remove existing listener if any
    if (slotListeners.has(freeSlot)) {
        freeSlot.removeEventListener('click', slotListeners.get(freeSlot));
        slotListeners.delete(freeSlot);
    }

    // Use English skills for Global region, Japanese skills for Japan region
    const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
    const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

    let skillsHTML = '';

    // Only add skills groups if there are skills to show
    if (card.hint_skills && card.hint_skills.length) {
        const hintSkillsHTML = card.hint_skills.map(s => {
            const skillText = String(s || '');
            return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
        }).join('');
        skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
    }

    if (eventSkillsToUse && eventSkillsToUse.length) {
        const eventSkillsHTML = eventSkillsToUse.map(s => {
            const skillText = String(s || '');
            return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
        }).join('');
        skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
    }

    // ADD UNIQUE EFFECTS DISPLAY IN SLOT
    if (card.unique && card.unique.effects && card.unique.effects.length > 0) {
        const uniqueEffectsHTML = card.unique.effects.map(effect => {
            const effectName = EFFECT_TYPES[effect.type];
            if (effectName) {
                const threshold = card.rarity === 1 ? 20 : card.rarity === 2 ? 25 : 30;
                // Check if unique effects are active at current level
                const currentLevel = getCardLevel(card.support_id);
                const isActive = shouldApplyUniqueEffects(card, currentLevel);
                const activeStyle = isActive ? 'background: #f0fff0; border-left: 3px solid #44ff44;' : 'background: #fff0f0; border-left: 3px solid #ff4444;';
                
                return `<div class="skill" style="${activeStyle}">
                    <strong>Unique:</strong> ${effectName} +${effect.value} (Lv. ${threshold}+) ${isActive ? '✅' : '🔒'}
                </div>`;
            }
            return '';
        }).filter(html => html !== '').join('');

        if (uniqueEffectsHTML) {
            skillsHTML += `<div class="skills-group"><div class="skills-header">Unique Effects</div>${uniqueEffectsHTML}</div>`;
        }
    }

    freeSlot.dataset.cardId = card.char_id;
    freeSlot.dataset.supportId = card.support_id;
    freeSlot.classList.add('has-card');

//-------------------------------------------------------------

// In addToSlot function, replace the nameHtml generation:
let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;

// Show different data based on current sort selection
const sortByValue = document.getElementById('sortBy').value;
const hideDataOptions = ['rarity', 'name', 'type'];

if (!hideDataOptions.includes(sortByValue)) {
  if (sortByValue === 'support_id') {
    nameHtml += `<div class="effect-text">ID: ${card.support_id}</div>`;
  } else if (sortByValue === 'release') {
    const releaseDate = region === 'global' ? card.release_en : card.release;
    if (releaseDate && releaseDate !== '') {
      const formattedDate = formatDateForDisplay(releaseDate);
      nameHtml += `<div class="effect-text">${formattedDate}</div>`;
    }
  } else if (!isNaN(parseInt(sortByValue))) {
    // Effect sorting - ALWAYS show the effect value AT CURRENT LEVEL, even if 0
    const effectId = parseInt(sortByValue);
    
    // FIX: Get the current level for this card
    const currentLevel = getCardLevel(card.support_id);
    const effectValue = getEffectValueAtCurrentLevel(card, effectId, currentLevel);
    
    if (effectValue !== null) {
      const effectName = EFFECT_TYPES[effectId];
      const unit = EFFECT_UNITS[effectId] || "";
      const formattedValue = Number.isInteger(effectValue) ? 
        effectValue.toString() : effectValue.toFixed(1);
      
      // Format with appropriate unit
      let displayValue;
      if (unit === "Lv ") {
        displayValue = unit + formattedValue;
      } else {
        displayValue = formattedValue + unit;
      }
      
      nameHtml += `<div class="effect-text">${effectName}: ${displayValue}</div>`;
    }
  } else {
    // Default: show character ID (only if not hidden)
    if(!HIDE.char_id) nameHtml += `<div class="effect-text">ID: ${card.char_id}</div>`;
  }
  
  if(!HIDE.url_name && card.url_name) nameHtml += `<div class="effect-text">${escapeHtml(card.url_name)}</div>`;
}

//-------------------------------------------------------------
    // Update slot content with character ID
    freeSlot.innerHTML = `
        <div class="type-icon"><img src="https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type] || "xx"}.png" alt="${escapeHtml(card.type)}"></div>
        <img src="https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png" alt="${escapeHtml(card.char_name)}">
        ${nameHtml}
        <div class="skills">${skillsHTML}</div>
    `;

    // Update level controls in the container
    const levelControls = slotContainer.querySelector('.slot-level-controls');
    const levelInput = levelControls.querySelector('.slot-level-input');

    // Enable and configure level input - USE SAVED LEVEL IF AVAILABLE
    levelInput.disabled = false;
    levelInput.min = '1';
    levelInput.max = getMaxLevel(card);
    
    // CRITICAL: Use the saved level for this specific card, or default to 1
    const savedLevel = getCardLevel(card.support_id);
    levelInput.value = savedLevel;

// Enhanced level input event listeners
const handleLevelChange = (e) => {
    const newLevel = updateSlotLevel(slotContainer, card, e.target.value);
    e.target.value = newLevel;
    
    // Update unique effects display to show if they're active
    updateUniqueEffectsDisplay(freeSlot, card, newLevel);
    
    // UPDATE: Refresh the slot display with new scaled values - SIMPLIFIED
    updateSlotNameWithEffectData(freeSlot, card, newLevel);
    refreshSlotDisplay(freeSlot, card, newLevel);
};

levelInput.onchange = handleLevelChange;
levelInput.onblur = handleLevelChange;
    levelInput.oninput = (e) => {
        // Real-time validation for better UX
        const value = parseInt(e.target.value);
        const maxLevel = getMaxLevel(card);
        if (value > maxLevel) {
            e.target.value = maxLevel;
        } else if (value < 1 || isNaN(value)) {
            e.target.value = 1;
        }
    };

    // Create and attach the click handler
    const slotCard = { ...card };

    function slotClickHandler() {
        removeFromSlot(freeSlot, slotCard);
    }

    // Attach the event listener to the slot element only
    freeSlot.addEventListener('click', slotClickHandler);
    slotListeners.set(freeSlot, slotClickHandler);

    selectedCardIds.add(card.char_id);
    if (save) saveSlotsToLocalStorage();

updateSelectedSkillsList();
updateCardDisabledStates(); // ← ADD THIS INSTEAD

    // Update effect totals after adding card
    setTimeout(updateEffectTotals, 100);
}

// Enhanced removeFromSlot function
function removeFromSlot(slot, card) {
    if (!slot) return;

    // Find the container for this slot
    const slotContainer = slot.closest('.slot-container');
    if (!slotContainer) return;

    // Remove existing listener if any
    if (slotListeners.has(slot)) {
        slot.removeEventListener('click', slotListeners.get(slot));
        slotListeners.delete(slot);
    }

    // Reset slot content
    slot.classList.remove('has-card');
    
    // IMPORTANT: Don't remove the level data when unequipping!
    // The level is preserved by support_id in slotLevels
    const supportId = slot.dataset.supportId;
    
    delete slot.dataset.cardId;
    delete slot.dataset.supportId;
    slot.innerHTML = '<div class="placeholder">Empty</div>';

    // Reset level controls UI (but keep the data)
    const levelInput = slotContainer.querySelector('.slot-level-input');
    if (levelInput) {
        levelInput.disabled = true;
        levelInput.value = '1';
        levelInput.min = '1';
        levelInput.max = '50';
    }

    // Remove from selected cards
    if (card) {
        selectedCardIds.delete(card.char_id);
    }

saveSlotsToLocalStorage();
updateSelectedSkillsList();
updateCardDisabledStates(); // ← ADD THIS INSTEAD
    
    // Update effect totals after removal
    setTimeout(updateEffectTotals, 100);
}

/* ------------- REFRESH SLOT DISPLAY ------------- */
function refreshSlotDisplay(slot, card, level) {
    // Update the effect value display in the slot
    const sortByValue = document.getElementById('sortBy').value;
    
    if (!isNaN(parseInt(sortByValue))) {
    const effectId = parseInt(sortByValue);
    const effectValue = getEffectValueAtCurrentLevel(card, effectId, level);
    
    // Find and update the effect value display
    const effectDisplay = slot.querySelector('.name + div');
    if (effectDisplay && effectDisplay.textContent.includes(EFFECT_TYPES[effectId])) {
        const effectName = EFFECT_TYPES[effectId];
        const unit = EFFECT_UNITS[effectId] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
            effectValue.toString() : effectValue.toFixed(1);
        
        let displayValue;
        if (unit === "Lv ") {
            displayValue = unit + formattedValue;
        } else {
            displayValue = formattedValue + unit;
        }
        
        effectDisplay.textContent = `${effectName}: ${displayValue}`;
    }
}
    
    // Also update effect totals
    setTimeout(updateEffectTotals, 50);
}

/* ------------- Clear buttons ------------- */
// Enhanced clear all function - FIXED VERSION
clearAllBtn.addEventListener('click', () => {
    selectedCardIds.clear();

    // IMPORTANT: Don't clear level data when clearing deck!
    // The levels are preserved by support_id for future use

    // Reset all level controls and slots
    slotContainers.forEach(container => {
        const levelInput = container.querySelector('.slot-level-input');
        levelInput.disabled = true;
        levelInput.value = '1';
        levelInput.min = '1';
        levelInput.max = '50';

        const slot = container.querySelector('.slot');
        if (slotListeners.has(slot)) {
            slot.removeEventListener('click', slotListeners.get(slot));
            slotListeners.delete(slot);
        }
        slot.classList.remove('has-card');
        delete slot.dataset.cardId;
        delete slot.dataset.supportId;
        slot.innerHTML = '<div class="placeholder">Empty</div>';
    });

    localStorage.removeItem(SLOT_KEY);
    updateSelectedSkillsList();
    highlightSkills();
    highlightSelectedSkills();
    renderSections();

    // Update effect totals after clearing
    setTimeout(() => {
        updateEffectTotals();
    }, 100);
});

clearFiltersBtn.addEventListener('click', () => {
  // Only clear the preset filters (racecourse through strategy)
  const presetFilterIds = ['racecourse', 'length', 'direction', 'track', 'season', 'weather', 'strategy'];
  
  presetFilterIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.value = '';
      localStorage.removeItem('filter_' + id);
    }
  });

  // Clear card name search
  const cardSearchInput = document.getElementById('cardSearch');
  if (cardSearchInput) {
    cardSearchInput.value = '';
    cardSearchValue = '';
    localStorage.removeItem('cardSearch');
  }

  // DO NOT clear skill searches - keep them as they are
  // DO NOT clear toggle buttons (rarity and type) - keep them as they are

  // Reset preset cards to visible state when clearing filters
  showPresetCards = true;
  localStorage.setItem('showPresetCards', 'true');
  updateTogglePresetCardsButton();
  updateSidebarFiltersVisibility();

  // DO NOT clear sorting and region controls - keep them as they are
  
  // Clear the preset selection but preserve manual selection state
  const presetsSelect = document.getElementById('presets');
  if (presetsSelect) {
    presetsSelect.value = '';
    localStorage.removeItem('filter_presets');
    // Set manual selection flag when clearing filters
    localStorage.setItem('manuallySelectedNone', 'true');
  }
  
  // Batch UI updates
  sectionPages.clear();
  renderSections();
  updateSkillVisibility();
});

/* ------------- Filter persistence ------------- */
function setupFilterPersistence(){
  FILTER_KEYS.forEach(id=>{
    const el=document.getElementById(id); if(!el)return;
    const saved=localStorage.getItem('filter_'+id); if(saved) el.value=saved;
    el.addEventListener('change', ()=>{
      localStorage.setItem('filter_'+id, el.value);
      sectionPages.clear();
      renderSections();
    });
  });
}

/* ------------- CONCISE HIGHLIGHTING LOGIC ------------- */
function highlightSkills() {
  // Process ALL skills (both in main content and slots)
  document.querySelectorAll('.skill').forEach(skill => {
    skill.classList.remove('highlighted', 'search-highlighted');
    skill.removeAttribute('data-has-border');
    skill.style.background = '#eef2ff';
    skill.style.color = '#000';
  });
  
  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

// In both highlightSkills() and highlightSelectedSkills() functions:
const searchTerms = SKILL_SEARCH_KEYS
  .map(id => {
    const input = document.getElementById(id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${id}"]`);
    const color = colorPicker ? colorPicker.dataset.color : 'green'; // default to green
    return {
      term: input?.value.trim().toLowerCase(),
      color: color
    };
  })
  .filter(item => item.term);

  const colorMap = {
    racecourse: '#bce934',
    length: '#fdb832',        // corners/straightaways
    direction: '#bce934',
    track: '#bce934',
    season: '#bce934',
    weather: '#bce934',
    strategy: '#fdb832'       // corners/straightaways (savvy will be handled separately)
  };

  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  
  // Handle strategy separately for savvy vs corners/straightaways
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },        // #fdb832
      { term: `${s} Straightaways`, color: colorMap.strategy }, // #fdb832
      { term: `${s} Savvy`, color: colorMap.racecourse }        // #bce934 (using racecourse color)
    );
  }
  
  // Handle length with separate colors for distance type vs corners/straightaways
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },        // #fdb832
      { term: `${label} Straightaways`, color: colorMap.length },  // #fdb832
      { term: distType, color: colorMap.racecourse }               // #bce934 (using racecourse color)
    );
  }

    document.querySelectorAll('.skill').forEach(skill => {
    const skillText = normalizeSkill(skill.textContent || '');
    
    // Check search terms with custom colors
    for (const { term, color } of searchTerms) {
// In both highlightSkills() and highlightSelectedSkills() functions:
// Update this part:
if (skillText.includes(term)) {
  const colorValue = getColorValue(color);
  const textColor = getTextColor(color);
  const hasBorder = color.includes('-border');
  
  skill.style.setProperty('background', colorValue, 'important');
  skill.style.setProperty('color', textColor, 'important');
  skill.classList.add('search-highlighted');
  
  if (hasBorder) {
    skill.setAttribute('data-has-border', 'true');
  }
  return;
}
    }
    
    // Check dropdown terms
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skill.style.background = color;
        skill.style.color = '#000';
        skill.classList.add('highlighted');
        break;
      }
    }
  });

  // NEW: Update skill visibility for ALL skills (main content and slots)
  updateSkillVisibility();
}

// Helper functions for colors
function getColorValue(colorName) {
  const colorMap = {
    // Solid colors - no border
    green: '#bce934',
    blue: '#1cd8fe', 
    orange: '#fdb832',
    red: '#fca5a5', // Updated red
    
    // Border colors - dark backgrounds
    'green-border': '#57ad33',
    'blue-border': '#14a1f7',
    'orange-border': '#fa9937', 
    'red-border': '#f75757'
  };
  return colorMap[colorName] || '#bce934';
}

function getTextColor(colorName) {
  // Use white text for border colors, black text for solid colors
  if (colorName.includes('-border')) {
    return '#ffffff'; // White text for bordered colors
  }
  return '#000000'; // Black text for solid colors
}

function updateSkillVisibility() {
  const shouldHide = hideUncolored;
  
  // Process ALL skills (both in main content and slots)
  document.querySelectorAll('.skill').forEach(skill => {
    const isHighlighted = skill.classList.contains('highlighted') || 
                         skill.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skill.classList.add('hidden-skill');
    } else {
      skill.classList.remove('hidden-skill');
    }
  });
  
  // Hide empty headers AND entire groups when hiding uncolored skills
  document.querySelectorAll('.skills-group').forEach(group => {
    const skills = group.querySelectorAll('.skill');
    const visibleSkills = Array.from(skills).filter(skill => !skill.classList.contains('hidden-skill'));
    
    const header = group.querySelector('.skills-header');
    if (header) {
      if (shouldHide && visibleSkills.length === 0) {
        header.classList.add('hidden-skill');
        group.classList.add('hidden-skill'); // Hide the entire group
      } else {
        header.classList.remove('hidden-skill');
        group.classList.remove('hidden-skill'); // Show the entire group
      }
    }
  });
} // <-- This closes the updateSkillVisibility function
  
/* ------------- ROBUST SLOT DISPLAY UPDATE ------------- */
function updateAllSlotDisplays() {
  console.log('Updating all slot displays...');
  
  slots.forEach((slot, index) => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        console.log(`Updating slot ${index} with card: ${card.char_name}`);
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        const currentLevel = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
        
        // Force update the name section with effect data
        forceUpdateSlotNameWithEffectData(slot, card, currentLevel);
      }
    } else {
      console.log(`Slot ${index} is empty`);
    }
  });
}

/* ------------- SIMPLIFIED SLOT NAME UPDATE ------------- */
function forceUpdateSlotNameWithEffectData(slot, card, level) {
  console.log(`Updating slot effect text for: ${card.char_name}`);
  
  // Get the current sort selection
  const sortByValue = document.getElementById('sortBy').value;
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  // Find the name container and remove any existing effect text
  const nameContainer = slot.querySelector('.name');
  if (!nameContainer) return;
  
  // Remove any existing effect text (elements with effect-text class)
  const existingEffectTexts = slot.querySelectorAll('.effect-text');
  existingEffectTexts.forEach(element => element.remove());
  
  // Add new effect data based on current sort selection
  if (!hideDataOptions.includes(sortByValue)) {
    if (sortByValue === 'support_id') {
      const effectDiv = document.createElement('div');
      effectDiv.className = 'effect-text';
      effectDiv.textContent = `ID: ${card.support_id}`;
      nameContainer.after(effectDiv);
    } else if (sortByValue === 'release') {
      const releaseDate = region === 'global' ? card.release_en : card.release;
      if (releaseDate && releaseDate !== '') {
        const formattedDate = formatDateForDisplay(releaseDate);
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-text';
        effectDiv.textContent = formattedDate;
        nameContainer.after(effectDiv);
      }
    } else if (!isNaN(parseInt(sortByValue))) {
      // Effect sorting - show effect value at CURRENT LEVEL
      const effectId = parseInt(sortByValue);
      const effectValue = getEffectValueAtCurrentLevel(card, effectId, level);
      
      if (effectValue !== null) {
        const effectName = EFFECT_TYPES[effectId];
        const unit = EFFECT_UNITS[effectId] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
          effectValue.toString() : effectValue.toFixed(1);
        
        // Format with appropriate unit
        let displayValue;
        if (unit === "Lv ") {
          displayValue = unit + formattedValue;
        } else {
          displayValue = formattedValue + unit;
        }
        
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-text';
        effectDiv.textContent = `${effectName}: ${displayValue}`;
        nameContainer.after(effectDiv);
      }
    } else {
      // Default: show character ID (only if not hidden)
      if(!HIDE.char_id) {
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-text';
        effectDiv.textContent = `ID: ${card.char_id}`;
        nameContainer.after(effectDiv);
      }
    }
    
    if(!HIDE.url_name && card.url_name) {
      const urlDiv = document.createElement('div');
      urlDiv.className = 'effect-text';
      urlDiv.textContent = card.url_name;
      nameContainer.after(urlDiv);
    }
  }
  
  console.log(`Slot effect text updated for: ${card.char_name}`);
}


/* ------------- UPDATE SLOT NAME WITH EFFECT DATA ------------- */
function updateSlotNameWithEffectData(slot, card, level) {
  const nameContainer = slot.querySelector('.name');
  if (!nameContainer) return;
  
  // Get the current sort selection
  const sortByValue = document.getElementById('sortBy').value;
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  // Remove any existing effect text (elements with effect-text class)
  const existingEffectTexts = slot.querySelectorAll('.effect-text');
  existingEffectTexts.forEach(element => element.remove());
  
  // Add new effect data based on current sort selection
  if (!hideDataOptions.includes(sortByValue)) {
    if (sortByValue === 'support_id') {
      const effectDiv = document.createElement('div');
      effectDiv.className = 'effect-text';
      effectDiv.textContent = `ID: ${card.support_id}`;
      nameContainer.after(effectDiv);
    } else if (sortByValue === 'release') {
      const releaseDate = region === 'global' ? card.release_en : card.release;
      if (releaseDate && releaseDate !== '') {
        const formattedDate = formatDateForDisplay(releaseDate);
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-text';
        effectDiv.textContent = formattedDate;
        nameContainer.after(effectDiv);
      }
    } else if (!isNaN(parseInt(sortByValue))) {
      // Effect sorting - show effect value at CURRENT LEVEL
      const effectId = parseInt(sortByValue);
      const effectValue = getEffectValueAtCurrentLevel(card, effectId, level);
      
      if (effectValue !== null) {
        const effectName = EFFECT_TYPES[effectId];
        const unit = EFFECT_UNITS[effectId] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
          effectValue.toString() : effectValue.toFixed(1);
        
        // Format with appropriate unit
        let displayValue;
        if (unit === "Lv ") {
          displayValue = unit + formattedValue;
        } else {
          displayValue = formattedValue + unit;
        }
        
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-text';
        effectDiv.textContent = `${effectName}: ${displayValue}`;
        nameContainer.after(effectDiv);
      }
    } else {
      // Default: show character ID (only if not hidden)
      if(!HIDE.char_id) {
        const effectDiv = document.createElement('div');
        effectDiv.className = 'effect-text';
        effectDiv.textContent = `ID: ${card.char_id}`;
        nameContainer.after(effectDiv);
      }
    }
    
    if(!HIDE.url_name && card.url_name) {
      const urlDiv = document.createElement('div');
      urlDiv.className = 'effect-text';
      urlDiv.textContent = card.url_name;
      nameContainer.after(urlDiv);
    }
  }
}


/* ------------- FILTER BUILDING & MATCHING ------------- */
function buildFilterTerms(filters){
  const terms=[];
  if(filters.racecourse) terms.push(`${filters.racecourse} Racecourse`);
  if(filters.direction) terms.push(filters.direction==='Clockwise'?'Right-Handed':'Left-Handed');
  if(filters.track) terms.push(filters.track==='Firm'?'Firm Conditions':'Wet Conditions');
  
  // Handle season - dropdown uses "Fall" but skills use "Fall Runner"
  if(filters.season) {
    terms.push(`${filters.season} Runner`);
  }
  
  // Handle weather - dropdown uses "Rainy"/"Snowy" but skills use "Rainy Days"/"Snowy Days"
  if(filters.weather) {
    terms.push(`${filters.weather} Days`);
  }
  
  if(filters.strategy){
    const s=filters.strategy;
    terms.push(`${s} Corners`,`${s} Straightaways`,`${s} Savvy`);
  }
  if(filters.length){
    const dist=parseInt(filters.length);
    const label=getLengthCategory(dist);
    terms.push(`${label} Corners`,`${label} Straightaways`,isStandardDistance(dist)?'Standard Distance':'Non-Standard Distance');
  }
  return terms;
}

function filterCardsWithRules(cards,filters){
  const terms=buildFilterTerms(filters).map(normalizeSkill);
  const strictDistanceKeys=['standard distance','non-standard distance'];
  const strictTerms=terms.filter(t=>strictDistanceKeys.includes(t));
  const looseTerms=terms.filter(t=>!strictDistanceKeys.includes(t));
  return cards.filter(card=>{
    const skills=[...card.hint_skills,...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t=>skills.includes(t)) && looseTerms.every(term=>skills.some(s=>s.includes(term)));
  });
}

/* ------------- UPDATED RENDER SECTIONS WITH CARD SEARCH AT TOP ------------- */
function renderSections() {
  cardSections.innerHTML='';

  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };

const anyDropdownActive = Object.values(filters).some(v => v);
const anySkillActive = SKILL_SEARCH_KEYS.some(key => document.getElementById(key)?.value.trim());
const anyRarityActive = selectedRarities.size > 0;
const anyTypeActive = selectedTypes.size > 0;
const anyCardSearchActive = cardSearchValue.length > 0;

  if(!anyDropdownActive && !anySkillActive && !anyRarityActive && !anyTypeActive && !anyCardSearchActive) {
    const section = document.createElement('div');
    section.className = 'card-section';
    section.style.display = 'flex';
    section.style.flexDirection = 'column';
    section.style.alignItems = 'center';
    section.style.justifyContent = 'center';
    const msg = document.createElement('div');
    msg.style.opacity = '0.7';
    msg.style.padding = '0px';
    msg.style.marginTop = '20px';
    msg.style.marginBottom = '10px';
    msg.textContent = 'Pick a label on the left or type a skill to show matching cards.';
    section.appendChild(msg);
    cardSections.appendChild(section);
    return;
  }

// Apply region filter first - CORRECTED
let baseFilteredCards = cardsData.filter(card => {
  if (region === 'global') {
    // For Global, only show cards that have release_en date (released globally)
    return card.release_en && card.release_en !== '';
  } else { // japan
    // For Japan, show ALL cards (including those not released globally)
    return true;
  }
});
  
  // Apply rarity and type filters to base cards
  if (anyRarityActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      if (selectedRarities.has('R') && card.rarity === 1) return true;
      if (selectedRarities.has('SR') && card.rarity === 2) return true;
      if (selectedRarities.has('SSR') && card.rarity === 3) return true;
      return false;
    });
  }
  
  if (anyTypeActive) {
    baseFilteredCards = baseFilteredCards.filter(card => {
      return selectedTypes.has(card.type);
    });
  }

  // APPLY SORTING to base cards
  baseFilteredCards = sortCards(baseFilteredCards, sortBy, sortOrder);

  // ADD THIS NEW SECTION AT THE TOP - Render Card Name Search FIRST
  if (anyCardSearchActive) {
    renderCardSearchSection();
  }

// Render dropdown filter sections (separated as before)
const filterOrder = ['racecourse','length','direction','track','season','weather','strategy'];
filterOrder.forEach(catId => {
  if (!filters[catId]) return;

  // ADD THIS CHECK - only render if preset cards should be shown
  if (!shouldShowFilterSection(catId)) return;

  if (catId === 'length') {
      const dist = parseInt(filters.length);
      const label = getLengthCategory(dist);
      const distanceType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';

      [
        { title: `${label} Corners`, terms: [`${label} Corners`] },
        { title: `${label} Straightaways`, terms: [`${label} Straightaways`] },
        { title: distanceType, terms: [distanceType] }
      ].forEach((row, idx) => renderFilterRow(catId, row.title, row.terms, idx, baseFilteredCards));

    } else if (catId === 'strategy') {
      const strat = filters.strategy;
      const stratRows = [
        { title: `${strat} Corners`, term: `${strat} Corners` },
        { title: `${strat} Straightaways`, term: `${strat} Straightaways` },
        { title: `${strat} Savvy`, term: `${strat} Savvy` }
      ];
      stratRows.forEach((row, idx) => renderFilterRow(catId, row.title, [row.term], idx, baseFilteredCards));

    } else {
      let rowTerms = [], headerText = '';
      switch (catId) {
        case 'racecourse': rowTerms.push(`${filters.racecourse} Racecourse`); headerText = `${filters.racecourse} Racecourse`; break;
        case 'direction': const dir = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed'; rowTerms.push(dir); headerText = dir; break;
        case 'track': const trackLabel = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions'; rowTerms.push(trackLabel); headerText = trackLabel; break;
        case 'season': rowTerms.push(`${filters.season} Runner`); headerText = `${filters.season} Runner`; break;
        case 'weather': rowTerms.push(`${capitalize(filters.weather)} Days`); headerText = `${capitalize(filters.weather)} Days`; break;
      }
      renderFilterRow(catId, headerText, rowTerms, 0, baseFilteredCards);
    }
  });

// Render skill search sections (separated as before)
SKILL_SEARCH_KEYS.forEach((key, i) => {
  const val = document.getElementById(key)?.value.trim();
  if (!val) return;

  const normalized = normalizeSkill(val);
  
  // Use a Set to track unique cards by support_id to avoid duplicates
  const uniqueMatches = new Set();
  const matches = [];
  
  baseFilteredCards.forEach(card => {
    // Use English skills for Global region, Japanese skills for Japan region
    // Fall back to Japanese skills if English skills are empty
    const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
    const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
    
    const skills = [...card.hint_skills, ...eventSkillsToUse].map(normalizeSkill);
    const hasMatch = skills.some(s => s.includes(normalized));
    
    if (hasMatch && !uniqueMatches.has(card.support_id)) {
      uniqueMatches.add(card.support_id);
      matches.push(card);
    }
  });

  const header = `Skill Search ${i + 1}: "${val}"`;
  renderSkillSearchRow(key, header, matches, i);
});

  highlightSkills();
} // This closes the renderSections function

function renderFilterRow(catId, headerText, termList, rowIndex, baseCards){
  const termsNormalized = termList.map(normalizeSkill);
  const strictDistanceKeys = ['standard distance','non-standard distance'];
  const strictTerms = termsNormalized.filter(t => strictDistanceKeys.includes(t));
  const looseTerms = termsNormalized.filter(t => !strictDistanceKeys.includes(t));

  const matches = baseCards.filter(card => {
    const skills = [...card.hint_skills, ...card.event_skills].map(normalizeSkill);
    return strictTerms.every(t => skills.includes(t)) && looseTerms.every(term => skills.some(s => s.includes(term)));
  });

  // COMPLETELY HIDE SECTION IF NO MATCHES
  if(matches.length === 0){
    return; // Don't create any section at all
  }

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.textContent = headerText;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button'); 
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  const rightBtn = document.createElement('button'); 
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  const pageKey = `${catId}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  renderFilterPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);
  cardSections.appendChild(section);
}

function properCaseSkill(s) {
  return String(s || '')
    .split(' ')
    .map(word => {
      // Handle hyphenated words like "fast-paced"
      if (word.includes('-')) {
        return word
          .split('-')
          .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
          .join('-');
      }
      // Regular words
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

function renderSkillSearchRow(key, headerText, matches, rowIndex) {
  // COMPLETELY HIDE SECTION IF NO MATCHES
  if (matches.length === 0) {
    return; // Don't create any section at all
  }

  // Get the actual search value and convert to proper case for display
  const input = document.getElementById(key);
  const searchValue = input ? input.value.trim() : '';
  const displaySearchValue = searchValue
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  const section = document.createElement('div');
  section.className = 'card-section';

  const headerContainer = document.createElement('div');
  headerContainer.className = 'card-section-header';

  const header = document.createElement('h2');
  header.className = 'skill-search-header';
  header.textContent = `Skill Search ${rowIndex + 1}: "${displaySearchValue}"`;
  headerContainer.appendChild(header);

  const controls = document.createElement('div');
  controls.className = 'page-controls';
  const leftBtn = document.createElement('button');
  const rightBtn = document.createElement('button');
  leftBtn.textContent = '◀';
  leftBtn.disabled = true;
  rightBtn.textContent = '▶';
  rightBtn.disabled = true;
  controls.appendChild(leftBtn);
  controls.appendChild(rightBtn);

  headerContainer.appendChild(controls);
  section.appendChild(headerContainer);

  const wrapper = document.createElement('div');
  wrapper.className = 'card-grid-wrapper';
  const grid = document.createElement('div');
  grid.className = 'cards';
  wrapper.appendChild(grid);
  section.appendChild(wrapper);

  cardSections.appendChild(section);

  const pageKey = `${key}-${rowIndex}`;
  const currentPage = sectionPages.get(pageKey) || 0;
  sectionPages.set(pageKey, currentPage);

  const CARDS_PER_PAGE = 6;

  renderCardSearchPage(currentPage, matches, grid, leftBtn, rightBtn, pageKey);

  leftBtn.addEventListener('click', () => {
    const newPage = sectionPages.get(pageKey) - 1;
    if (newPage >= 0) {
      sectionPages.set(pageKey, newPage);
      renderCardSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
    }
  });

  rightBtn.addEventListener('click', () => {
    const totalPages = Math.ceil(matches.length / calculateCardsPerPage());
    const newPage = sectionPages.get(pageKey) + 1;
    if (newPage < totalPages) {
      sectionPages.set(pageKey, newPage);
      renderCardSearchPage(newPage, matches, grid, leftBtn, rightBtn, pageKey);
    }
  });
}

/* ------------- TOGGLE PRESET CARDS FUNCTIONALITY ------------- */
function setupTogglePresetCards() {
  const togglePresetCardsBtn = document.getElementById('togglePresetCardsBtn');
  
  // Load saved state
  const savedState = localStorage.getItem('showPresetCards');
  if (savedState !== null) {
    showPresetCards = savedState === 'true';
    updateTogglePresetCardsButton();
    updateSidebarFiltersVisibility(); // ADD THIS
  }

  togglePresetCardsBtn.addEventListener('click', () => {
    showPresetCards = !showPresetCards;
    localStorage.setItem('showPresetCards', showPresetCards);
    updateTogglePresetCardsButton();
    updateSidebarFiltersVisibility(); // ADD THIS
    renderSections();
  });
}

function updateTogglePresetCardsButton() {
  const togglePresetCardsBtn = document.getElementById('togglePresetCardsBtn');
  togglePresetCardsBtn.textContent = showPresetCards ? 
    'Hide Preset Cards' : 
    'Show Preset Cards';
}

// ADD THIS NEW FUNCTION
function updateSidebarFiltersVisibility() {
  const sidebarFiltersSection = document.getElementById('sidebarFiltersSection');
  if (sidebarFiltersSection) {
    if (showPresetCards) {
      sidebarFiltersSection.classList.remove('hidden');
    } else {
      sidebarFiltersSection.classList.add('hidden');
    }
  }
}

function shouldShowFilterSection(catId) {
  // If we're hiding preset cards, only show skill search sections
  if (!showPresetCards) {
    return false; // Hide all filter-based sections (racecourse, length, etc.)
  }
  return true; // Show all sections when preset cards are visible
}

/* ------------- SELECTED SKILLS MANAGEMENT ------------- */
function updateSelectedSkillsList() {
  const skillsList = document.getElementById('selectedSkillsList');
  const skillsCount = document.getElementById('skillsCount');
  
  if (!skillsList) return;
  
  // Get all unique skills from selected cards
  const allSkills = getAllSkillsFromSelectedCards();
  
  // Clear current list
  skillsList.innerHTML = '';
  
  // Create skill elements
  allSkills.forEach(skill => {
    const skillElement = document.createElement('div');
    skillElement.className = 'skill-item';
    skillElement.textContent = skill;
    skillsList.appendChild(skillElement);
  });
  
  // Update count
  if (skillsCount) {
    skillsCount.textContent = allSkills.length;
  }
  
  // NEW: Also highlight selected skills
  highlightSelectedSkills();
  updateSelectedSkillsVisibility();
}

function getAllSkillsFromSelectedCards() {
  const allSkills = new Set();
  
  // Iterate through all slots with cards
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        // Use English skills for Global region, Japanese skills for Japan region
        const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
        const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;
        
        // Add hint skills
        if (card.hint_skills) {
          card.hint_skills.forEach(skill => {
            const cleanSkill = String(skill || '').replace(/○\s*/g, '').trim();
            if (cleanSkill) allSkills.add(properCaseSkill(cleanSkill));
          });
        }
        
        // Add event skills
        if (eventSkillsToUse) {
          eventSkillsToUse.forEach(skill => {
            const cleanSkill = String(skill || '').replace(/○\s*/g, '').trim();
            if (cleanSkill) allSkills.add(properCaseSkill(cleanSkill));
          });
        }
      }
    }
  });
  
  // Convert Set to Array and sort alphabetically
  return Array.from(allSkills).sort();
}

function highlightSelectedSkills() {
  const skillItems = document.querySelectorAll('.skill-item');
  if (skillItems.length === 0) return;
  
  const filters = {
    racecourse: document.getElementById('racecourse').value || '',
    length: document.getElementById('length').value || '',
    direction: document.getElementById('direction').value || '',
    track: document.getElementById('track').value || '',
    season: document.getElementById('season').value || '',
    weather: document.getElementById('weather').value || '',
    strategy: document.getElementById('strategy').value || ''
  };
  
// In both highlightSkills() and highlightSelectedSkills() functions:
const searchTerms = SKILL_SEARCH_KEYS
  .map(id => {
    const input = document.getElementById(id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${id}"]`);
    const color = colorPicker ? colorPicker.dataset.color : 'green'; // default to green
    return {
      term: input?.value.trim().toLowerCase(),
      color: color
    };
  })
  .filter(item => item.term);
  
  const colorMap = {
    racecourse: '#bce934',
    length: '#fdb832',        // corners/straightaways
    direction: '#bce934',
    track: '#bce934',
    season: '#bce934',
    weather: '#bce934',
    strategy: '#fdb832'       // corners/straightaways (savvy will be handled separately)
  };
  
  const dropdownTerms = [];
  if (filters.racecourse) dropdownTerms.push({ term: `${filters.racecourse} Racecourse`, color: colorMap.racecourse });
  if (filters.direction) {
    const dirTerm = filters.direction === 'Clockwise' ? 'Right-Handed' : 'Left-Handed';
    dropdownTerms.push({ term: dirTerm, color: colorMap.direction });
  }
  if (filters.track) {
    const trackTerm = filters.track === 'Firm' ? 'Firm Conditions' : 'Wet Conditions';
    dropdownTerms.push({ term: trackTerm, color: colorMap.track });
  }
  if (filters.season) dropdownTerms.push({ term: `${filters.season} Runner`, color: colorMap.season });
  if (filters.weather) dropdownTerms.push({ term: `${capitalize(filters.weather)} Days`, color: colorMap.weather });
  
  // Handle strategy separately for savvy vs corners/straightaways
  if (filters.strategy) {
    const s = filters.strategy;
    dropdownTerms.push(
      { term: `${s} Corners`, color: colorMap.strategy },        // #fdb832
      { term: `${s} Straightaways`, color: colorMap.strategy }, // #fdb832
      { term: `${s} Savvy`, color: colorMap.racecourse }        // #bce934 (using racecourse color)
    );
  }
  
  // Handle length with separate colors for distance type vs corners/straightaways
  if (filters.length) {
    const dist = parseInt(filters.length, 10);
    const label = getLengthCategory(dist);
    const distType = isStandardDistance(dist) ? 'Standard Distance' : 'Non-Standard Distance';
    dropdownTerms.push(
      { term: `${label} Corners`, color: colorMap.length },        // #fdb832
      { term: `${label} Straightaways`, color: colorMap.length },  // #fdb832
      { term: distType, color: colorMap.racecourse }               // #bce934 (using racecourse color)
    );
  }
  
  skillItems.forEach(skillItem => {
    skillItem.classList.remove('highlighted', 'search-highlighted');
    skillItem.removeAttribute('data-has-border');
    skillItem.style.background = '#eef2ff';
    skillItem.style.color = '#000';
    
    const skillText = normalizeSkill(skillItem.textContent || '');
    
    // Check search terms with custom colors
    for (const { term, color } of searchTerms) {
      // FIX: Change 'skill' to 'skillItem'
      if (skillText.includes(term)) {
        const colorValue = getColorValue(color);
        const textColor = getTextColor(color);
        const hasBorder = color.includes('-border');
        
        skillItem.style.setProperty('background', colorValue, 'important'); // FIX: skillItem
        skillItem.style.setProperty('color', textColor, 'important'); // FIX: skillItem
        skillItem.classList.add('search-highlighted'); // FIX: skillItem
        
        if (hasBorder) {
          skillItem.setAttribute('data-has-border', 'true'); // FIX: skillItem
        }
        return;
      }
    }
    
    // Check dropdown terms
    for (const { term, color } of dropdownTerms) {
      if (skillText === normalizeSkill(term)) {
        skillItem.style.background = color;
        skillItem.style.color = '#000';
        skillItem.classList.add('highlighted');
        break;
      }
    }
  });
}

function updateSelectedSkillsVisibility() {
  const shouldHide = hideUncolored;
  const skillItems = document.querySelectorAll('.skill-item');
  
  skillItems.forEach(skillItem => {
    const isHighlighted = skillItem.classList.contains('highlighted') || 
                         skillItem.classList.contains('search-highlighted');
    
    if (shouldHide && !isHighlighted) {
      skillItem.classList.add('hidden-skill');
    } else {
      skillItem.classList.remove('hidden-skill');
    }
  });
}

/* ------------- LEVEL MANAGEMENT ------------- */
function getCardRarity(card) {
  if (card.rarity === 3) return 'SSR';
  if (card.rarity === 2) return 'SR';
  return 'R';
}

function getMaxLevel(card) {
  return MAX_LEVELS[getCardRarity(card)] || 50;
}

function validateLevel(level, card) {
  let num = parseInt(level);
  if (isNaN(num) || num < 1) return 1;
  
  const maxLevel = getMaxLevel(card);
  if (num > maxLevel) return maxLevel;
  
  return num;
}

// Enhanced level update function
function updateSlotLevel(slotContainer, card, level) {
    const validatedLevel = validateLevel(level, card);
    
    // Save the level for this specific card (by support_id)
    saveCardLevel(card.support_id, validatedLevel);
    
    // Update the input display
    const levelInput = slotContainer.querySelector('.slot-level-input');
    if (levelInput) {
        levelInput.value = validatedLevel;
    }
    
    // Update effect totals immediately
    setTimeout(updateEffectTotals, 50);
    
    return validatedLevel;
}

// Update the card display to show unique effects
/* ------------- UPDATE createCardElement FUNCTION ------------- */
function createCardElement(card){
  const el = document.createElement('div');
  el.className = 'card';
  el.dataset.id = card.char_id;
  el.dataset.supportId = card.support_id;
  el.dataset.name = card.char_name;

  const imgSrc = `https://gametora.com/images/umamusume/supports/support_card_s_${card.support_id}.png`;
  const typeImg = `https://gametora.com/images/umamusume/icons/utx_ico_obtain_${typeMap[card.type]||"xx"}.png`;

  // Use English skills for Global region, Japanese skills for Japan region
  // Fall back to Japanese skills if English skills are empty
  const useEnglishSkills = region === 'global' && card.event_skills_en && card.event_skills_en.length > 0;
  const eventSkillsToUse = useEnglishSkills ? card.event_skills_en : card.event_skills;

  let skillsHTML = '';
  
  // FIX: Handle hint_skills with safe string conversion
  if(card.hint_skills && card.hint_skills.length) {
    const hintSkillsHTML = card.hint_skills.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Support Hints</div>${hintSkillsHTML}</div>`;
  }

  // FIX: Handle event skills with safe string conversion
  if(eventSkillsToUse && eventSkillsToUse.length) {
    const eventSkillsHTML = eventSkillsToUse.map(s => {
      const skillText = String(s || '');
      return `<div class="skill">${escapeHtml(properCaseSkill(skillText.replace(/○\s*/g, '')))}</div>`;
    }).join('');
    skillsHTML += `<div class="skills-group"><div class="skills-header">Event Skills</div>${eventSkillsHTML}</div>`;
  }
  
  // ADD UNIQUE EFFECTS DISPLAY
  if (card.unique && card.unique.effects && card.unique.effects.length > 0) {
    const uniqueEffectsHTML = card.unique.effects.map(effect => {
      const effectName = EFFECT_TYPES[effect.type];
      if (effectName) {
        const threshold = card.rarity === 1 ? 20 : card.rarity === 2 ? 25 : 30;
        return `<div class="skill" style="background: #fff0f0; border-left: 3px solid #ff4444;">
          <strong>Unique:</strong> ${effectName} +${effect.value} (Lv. ${threshold}+)
        </div>`;
      }
      return '';
    }).filter(html => html !== '').join('');
    
    if (uniqueEffectsHTML) {
      skillsHTML += `<div class="skills-group"><div class="skills-header">Unique Effects</div>${uniqueEffectsHTML}</div>`;
    }
  }
  
  // ENHANCED: Add sort data display below name - HIDE FOR CERTAIN OPTIONS
  let nameHtml = `<div class="name">${escapeHtml(card.char_name)}</div>`;
  
  // Show different data based on current sort selection
  const sortByValue = document.getElementById('sortBy').value;
  
  // Define which sort options should NOT show the extra data box
  const hideDataOptions = ['rarity', 'name', 'type'];
  
  if (!hideDataOptions.includes(sortByValue)) {
    if (sortByValue === 'support_id') {
      nameHtml += `<div class="effect-text">ID: ${card.support_id}</div>`;
    } else if (sortByValue === 'release') {
      const releaseDate = region === 'global' ? card.release_en : card.release;
      if (releaseDate && releaseDate !== '') {
        const formattedDate = formatDateForDisplay(releaseDate);
        nameHtml += `<div class="effect-text">${formattedDate}</div>`;
      }
    } else if (!isNaN(parseInt(sortByValue))) {
      // Effect sorting - ALWAYS show the effect value at MAX LEVEL, even if 0
      const effectValue = getEffectValueForSorting(card, parseInt(sortByValue));
      if (effectValue !== null) {
        const effectName = EFFECT_TYPES[parseInt(sortByValue)];
        const unit = EFFECT_UNITS[parseInt(sortByValue)] || "";
        const formattedValue = Number.isInteger(effectValue) ? 
          effectValue.toString() : effectValue.toFixed(1);
        
        // Format with appropriate unit
        let displayValue;
        if (unit === "Lv ") {
          displayValue = unit + formattedValue;
        } else {
          displayValue = formattedValue + unit;
        }
        
        nameHtml += `<div class="effect-text">${effectName}: ${displayValue}</div>`;
      }
    } else {
      // Default: show character ID (only if not hidden)
      if(!HIDE.char_id) nameHtml += `<div class="effect-text">ID: ${card.char_id}</div>`;
    }
    
    if(!HIDE.url_name && card.url_name) nameHtml += `<div class="effect-text">${escapeHtml(card.url_name)}</div>`;
  }

  el.innerHTML = `
    <div class="type-icon"><img src="${typeImg}" alt="${escapeHtml(card.type)}"></div>
    <img src="${imgSrc}" alt="${escapeHtml(card.char_name)}">
    ${nameHtml}
    <div class="skills">${skillsHTML}</div>
  `;

  // Replace your current card click handler in createCardElement():
  el.addEventListener('click', ()=> {
    const slot = slots.find(s => Number(s.dataset.cardId) === card.char_id);
    if(slot) {
        removeFromSlot(slot, card);
    } else {
        addToSlot(card);
    }
    
    // INSTEAD of calling renderSections(), just update the disabled states
    updateCardDisabledStates();
  });

  // Ensure initial disabled state is set when card is created
  if(selectedCardIds.has(card.char_id)) {
    el.classList.add('disabled');
    // Add duplicate label if needed
    if (!el.querySelector('[data-dup-label]')) {
      const dupLabel = document.createElement('div');
      dupLabel.textContent = 'Duplicate Support';
      dupLabel.setAttribute('data-dup-label', 'true');
      dupLabel.style.position = 'absolute';
      dupLabel.style.top = '0';
      dupLabel.style.left = '0';
      dupLabel.style.width = '100%';
      dupLabel.style.background = 'red';
      dupLabel.style.color = 'white';
      dupLabel.style.fontSize = '9px';
      dupLabel.style.fontWeight = 'bold';
      dupLabel.style.textAlign = 'center';
      dupLabel.style.padding = '2px 0';
      dupLabel.style.borderTopLeftRadius = '4px';
      dupLabel.style.borderTopRightRadius = '4px';
      dupLabel.style.zIndex = '10';
      el.appendChild(dupLabel);
    }
  }

  return el;
}

function createLevelControls(slot, card) {
  const levelControls = document.createElement('div');
  levelControls.className = 'slot-level-controls';
  
  const levelLabel = document.createElement('span');
  levelLabel.className = 'slot-level-label';
  levelLabel.textContent = 'Level';
  
  const levelInput = document.createElement('input');
  levelInput.type = 'number';
  levelInput.className = 'slot-level-input';
  levelInput.min = '1';
  levelInput.max = getMaxLevel(card);
  levelInput.value = slotLevels[card.support_id] || 1;
  
  levelInput.addEventListener('change', (e) => {
    const newLevel = updateSlotLevel(slot, card, e.target.value);
    e.target.value = newLevel; // Ensure valid value is displayed
  });
  
  levelInput.addEventListener('blur', (e) => {
    const newLevel = updateSlotLevel(slot, card, e.target.value);
    e.target.value = newLevel; // Ensure valid value is displayed
  });
  
  levelControls.appendChild(levelLabel);
  levelControls.appendChild(levelInput);
  
  return levelControls;
}

/* ------------- DARK MODE ------------- */
function setupDarkMode() {
  const darkModeToggle = document.getElementById('darkModeToggle');
  const savedDarkMode = localStorage.getItem('darkMode') === 'true';
  
  // Apply saved dark mode state
  if (savedDarkMode) {
    document.body.classList.add('dark-mode');
    darkModeToggle.textContent = '☀️'; // Sun icon for light mode
  } else {
    darkModeToggle.textContent = '🌙'; // Moon icon for dark mode
  }
  
  darkModeToggle.addEventListener('click', () => {
    const isDarkMode = document.body.classList.toggle('dark-mode');
    localStorage.setItem('darkMode', isDarkMode);
    
    // Update button icon
    darkModeToggle.textContent = isDarkMode ? '☀️' : '🌙';
  });
}

// Initialize dark mode when the page loads
document.addEventListener('DOMContentLoaded', setupDarkMode);

// Initialize the hide uncolored checkbox
setupHideUncoloredCheckbox();

// Auto-update whenever a filter dropdown changes
['racecourse','length','direction','track','season','weather','strategy']
  .forEach(id => {
    const element = document.getElementById(id);
    if (element) {
      element.addEventListener('change', renderSections);
    }
  });

document.addEventListener('DOMContentLoaded', () => {
  renderSections();
});

window.addEventListener('resize', renderSections);

// Initialize skill search persistence when the page loads
document.addEventListener('DOMContentLoaded', () => {
  // This will be called by the existing DOMContentLoaded listener
});

/* ------------- RESPONSIVE PAGINATION ------------- */
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    // Re-render all sections to update pagination when window resizes
    sectionPages.clear();
    renderSections();
  }, 250);
});

/* ------------- SKILL SEARCH COPY/PASTE FUNCTIONALITY ------------- */
function setupCopyPasteButtons() {
  const copyBtn = document.getElementById('copySkillsBtn');
  const pasteBtn = document.getElementById('pasteSkillsBtn');
  
  copyBtn.addEventListener('click', copySkillsToClipboard);
  pasteBtn.addEventListener('click', pasteSkillsFromClipboard);
}

function copySkillsToClipboard() {
  const skillsData = skillSearches.map(search => {
    const input = document.getElementById(search.id);
    const colorPicker = document.querySelector(`.color-picker[data-search-id="${search.id}"]`);
    
    if (input && input.value.trim() && colorPicker) {
      return {
        skill: input.value.trim(),
        color: colorPicker.dataset.color
      };
    }
    return null;
  }).filter(item => item !== null);
  
  console.log('Skills to copy:', skillsData); // Debug log
  
  if (skillsData.length === 0) {
    alert('No skills to copy!');
    return;
  }
  
  // Format: skill1|color1,skill2|color2,skill3|color3
  const copyText = skillsData.map(item => `${item.skill}|${item.color}`).join(',');
  
  console.log('Copy text format:', copyText); // Debug log
  
  navigator.clipboard.writeText(copyText).then(() => {
    // Visual feedback
    const copyBtn = document.getElementById('copySkillsBtn');
    const originalText = copyBtn.textContent;
    copyBtn.textContent = 'Copied!';
    copyBtn.style.background = '#57ad33';
    
    setTimeout(() => {
      copyBtn.textContent = originalText;
      copyBtn.style.background = '';
    }, 1500);
    
    console.log(`Copied ${skillsData.length} skill(s) to clipboard`);
  }).catch(err => {
    console.error('Failed to copy skills: ', err);
    alert('Failed to copy skills to clipboard');
  });
}

function pasteSkillsFromClipboard() {
  navigator.clipboard.readText().then(text => {
    try {
      const skillsData = parseSkillsFromClipboard(text);
      
      if (skillsData.length === 0) {
        alert('No valid skills found in clipboard!');
        return;
      }
      
      // Clear existing searches first using the main clear function
      clearAllSkillSearches();
      
      // Create new searches for each pasted skill
      skillsData.forEach((skillItem, index) => {
        if (index < maxSearches) {
          if (index === 0) {
            // Update first search box
            const firstInput = document.getElementById('skillSearch1');
            const firstColorPicker = document.querySelector('.color-picker[data-search-id="skillSearch1"]');
            
            if (firstInput) firstInput.value = skillItem.skill;
            if (firstColorPicker) {
              firstColorPicker.className = `color-picker ${skillItem.color}`;
              firstColorPicker.dataset.color = skillItem.color;
              localStorage.setItem('color_skillSearch1', skillItem.color);
            }
            
            // Update state for first search
            const firstSearch = skillSearches.find(s => s.id === 'skillSearch1');
            if (firstSearch) {
              firstSearch.value = skillItem.skill;
            }
          } else {
            // Add new search boxes
            const newId = `skillSearch${index + 1}`;
            
            // Add to state
            skillSearches.push({ id: newId, value: skillItem.skill });
            
            // Create UI element
            createSearchBox(newId, skillItem.skill);
            
            // Set color
            const colorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
            if (colorPicker) {
              colorPicker.className = `color-picker ${skillItem.color}`;
              colorPicker.dataset.color = skillItem.color;
              localStorage.setItem(`color_${newId}`, skillItem.color);
            }
          }
        }
      });
      
      // Update search counter and global array
      searchCounter = skillSearches.length + 1;
      SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
      
      // Save the updated state
      saveSkillSearches();
      
      // Update UI
      sectionPages.clear();
      renderSections();
      highlightSkills();
      highlightSelectedSkills();
      
      // Visual feedback
      const pasteBtn = document.getElementById('pasteSkillsBtn');
      const originalText = pasteBtn.textContent;
      pasteBtn.textContent = `Pasted ${skillsData.length}`;
      pasteBtn.style.background = '#14a1f7';
      
      setTimeout(() => {
        pasteBtn.textContent = originalText;
        pasteBtn.style.background = '';
      }, 1500);
      
      console.log(`Pasted ${skillsData.length} skill(s) from clipboard`);
      
    } catch (error) {
      console.error('Failed to parse clipboard data: ', error);
      alert('Invalid format in clipboard! Use Copy Skills button first.');
    }
  }).catch(err => {
    console.error('Failed to read clipboard: ', err);
    alert('Failed to read from clipboard. Please check permissions.');
  });
}

function parseSkillsFromClipboard(text) {
  if (!text || typeof text !== 'string') {
    throw new Error('Invalid clipboard data');
  }
  
  // Expected format: skill1|color1,skill2|color2,skill3|color3
  const skills = text.split(',').map(item => {
    if (!item || !item.includes('|')) return null;
    
    const [skill, color] = item.split('|');
    if (skill && color) {
      return {
        skill: skill.trim(),
        color: color.trim()
      };
    }
    return null;
  }).filter(item => item !== null);
  
  return skills;
}

// Rename the existing function used by paste to avoid conflict
function clearAllSkillSearchesForPaste() {
  // Remove all search boxes except the first one
  const searchContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  searchContainers.forEach((container, index) => {
    if (index > 0) {
      const searchId = container.querySelector('.skill-search').id;
      removeSearchBox(searchId);
    }
  });
  
  // Clear the first search box
  const firstInput = document.getElementById('skillSearch1');
  const firstColorPicker = document.querySelector('.color-picker[data-search-id="skillSearch1"]');
  if (firstInput) firstInput.value = '';
  if (firstColorPicker) {
    firstColorPicker.className = 'color-picker green';
    firstColorPicker.dataset.color = 'green';
    localStorage.setItem('color_skillSearch1', 'green');
  }
  
  // Reset state
  skillSearches = [{ id: 'skillSearch1', value: '' }];
  searchCounter = 2;
}

function addSearchBoxFromPaste(skillItem) {
  const newId = `skillSearch${searchCounter}`;
  searchCounter++;
  
  // Add to state
  skillSearches.push({ id: newId, value: skillItem.skill });
  
  // Create UI element
  createSearchBox(newId, skillItem.skill, false);
  
  // Set color
  const colorPicker = document.querySelector(`.color-picker[data-search-id="${newId}"]`);
  if (colorPicker) {
    colorPicker.className = `color-picker ${skillItem.color}`;
    colorPicker.dataset.color = skillItem.color;
    localStorage.setItem(`color_${newId}`, skillItem.color);
  }
  
  // Update global array
  SKILL_SEARCH_KEYS = skillSearches.map(search => search.id);
}

/* ------------- CLEAR ALL SKILL SEARCHES ------------- */
function setupClearAllSearches() {
  const clearAllSearchesBtn = document.getElementById('clearAllSearchesBtn');
  
  clearAllSearchesBtn.addEventListener('click', clearAllSkillSearches);
}

/* ------------- CLEAR ALL SKILL SEARCHES - OPTIMIZED ------------- */
function clearAllSkillSearches() {
  // Get all search containers at once
  const searchContainers = document.querySelectorAll('#skillSearchGroup .search-input-container');
  
  // If no containers or only one, just reset the first one
  if (searchContainers.length === 0) return;
  
  // Clear and reset the first search box - ALWAYS reset to green
  const firstContainer = searchContainers[0];
  const firstInput = firstContainer.querySelector('.skill-search');
  const firstColorPicker = firstContainer.querySelector('.color-picker');
  
  if (firstInput) firstInput.value = '';
  if (firstColorPicker) {
    firstColorPicker.className = 'color-picker green'; // ALWAYS reset to green
    firstColorPicker.dataset.color = 'green'; // ALWAYS reset to green
  }
  
  // Remove all search boxes except the first one
  for (let i = searchContainers.length - 1; i > 0; i--) {
    searchContainers[i].remove();
  }
  
  // Reset state
  skillSearches = [{ id: 'skillSearch1', value: '' }];
  searchCounter = 2;
  SKILL_SEARCH_KEYS = ['skillSearch1'];
  
  // Save to localStorage - ALWAYS reset first color to green
  localStorage.setItem('skillSearches', JSON.stringify(skillSearches));
  localStorage.setItem('color_skillSearch1', 'green'); // ALWAYS reset to green
  
  // Clear any orphaned color picker data from localStorage
  for (let i = 2; i <= 30; i++) {
    localStorage.removeItem(`color_skillSearch${i}`);
  }
  
  // Update UI
  sectionPages.clear();
  renderSections();
  highlightSkills();
  highlightSelectedSkills();
  
  // Visual feedback
  const clearBtn = document.getElementById('clearAllSearchesBtn');
  const originalText = clearBtn.textContent;
  clearBtn.textContent = 'Cleared!';
  clearBtn.style.background = '#f75757';
  
  setTimeout(() => {
    clearBtn.textContent = originalText;
    clearBtn.style.background = '';
  }, 1500);
}

/* ------------- DECK COPY/PASTE FUNCTIONALITY ------------- */
function setupDeckCopyPaste() {
  const copyDeckBtn = document.getElementById('copyDeckBtn');
  const pasteDeckBtn = document.getElementById('pasteDeckBtn');
  
  copyDeckBtn.addEventListener('click', copyDeckToClipboard);
  pasteDeckBtn.addEventListener('click', pasteDeckFromClipboard);
}

// Also fix the deck paste override:
function setupDeckPasteOverride() {
    const pasteDeckBtn = document.getElementById('pasteDeckBtn');
    if (pasteDeckBtn && window.pasteDeckFromClipboard) {
        const originalPasteDeck = window.pasteDeckFromClipboard;
        window.pasteDeckFromClipboard = function() {
            return originalPasteDeck().then(() => {
                setTimeout(updateEffectTotals, 500);
            });
        };
    }
}

// Enhanced deck copy/paste to include levels
function copyDeckToClipboard() {
    const deckData = slots.map(slot => {
        const supportId = slot.dataset.supportId;
        // Use the saved level from slotLevels, or current input value as fallback
        let level = '1';
        if (supportId) {
            level = getCardLevel(supportId).toString();
        } else {
            const levelInput = slot.closest('.slot-container').querySelector('.slot-level-input');
            level = levelInput ? levelInput.value : '1';
        }

        return {
            supportId: supportId || 'empty',
            level: supportId ? level : '1'
        };
    });

    // Format: supportId1|level1,supportId2|level2,...,supportId6|level6
    const copyText = deckData.map(slot => `${slot.supportId}|${slot.level}`).join(',');

    navigator.clipboard.writeText(copyText).then(() => {
        // Visual feedback
        const copyBtn = document.getElementById('copyDeckBtn');
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = '#57ad33';

        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = '';
        }, 1500);

        console.log('Deck copied to clipboard with levels:', deckData);
    }).catch(err => {
        console.error('Failed to copy deck: ', err);
        alert('Failed to copy deck to clipboard');
    });
}

function pasteDeckFromClipboard() {
  navigator.clipboard.readText().then(text => {
    try {
      const deckData = parseDeckFromClipboard(text);
      
      if (!deckData || deckData.length !== 6) {
        alert('Invalid deck format! Expected 6 slots.');
        return;
      }
      
      // Clear current deck first
      clearAllBtn.click(); // Use the existing clear function
      
      // Add a small delay to ensure clear completes
      setTimeout(() => {
        let hasValidCards = false;
        
        // Populate slots with pasted data
        deckData.forEach((slotData, index) => {
          if (slotData.supportId !== 'empty') {
            const card = cardsData.find(c => String(c.support_id) === String(slotData.supportId));
            if (card) {
              const slot = slots[index];
              addToSlot(card, slot, false);
              
              // Set level if provided and valid
              if (slotData.level && slotData.level !== '1') {
                const slotContainer = slot.closest('.slot-container');
                const levelInput = slotContainer.querySelector('.slot-level-input');
                if (levelInput) {
                  const validatedLevel = validateLevel(slotData.level, card);
                  levelInput.value = validatedLevel;
                  slotLevels[card.support_id] = validatedLevel;
                }
              }
              
              hasValidCards = true;
            } else {
              console.warn(`Card with support_id ${slotData.supportId} not found`);
            }
          }
          // Empty slots are already handled by the clear operation
        });
        
        // Save the final state
        saveSlotsToLocalStorage();
        localStorage.setItem('slotLevels', JSON.stringify(slotLevels));
        
        // Update UI
        updateSelectedSkillsList();
        highlightSkills();
        highlightSelectedSkills();
        renderSections();
        
        // Visual feedback
        const pasteBtn = document.getElementById('pasteDeckBtn');
        const originalText = pasteBtn.textContent;
        const validCardCount = deckData.filter(slot => slot.supportId !== 'empty').length;
        pasteBtn.textContent = `Pasted ${validCardCount}`;
        pasteBtn.style.background = '#14a1f7';
        
        setTimeout(() => {
          pasteBtn.textContent = originalText;
          pasteBtn.style.background = '';
        }, 1500);
        
        if (!hasValidCards) {
          alert('No valid cards found in the deck data!');
        }
        
      }, 100);
      
    } catch (error) {
      console.error('Failed to parse deck data: ', error);
      alert('Invalid deck format in clipboard! Use Copy Deck button first.');
    }
  }).catch(err => {
    console.error('Failed to read clipboard: ', err);
    alert('Failed to read from clipboard. Please check permissions.');
  });
}

function parseDeckFromClipboard(text) {
  // Expected format: supportId1|level1,supportId2|level2,...,supportId6|level6
  const slots = text.split(',').map((item, index) => {
    const [supportId, level] = item.split('|');
    
    if (!supportId) {
      throw new Error(`Invalid format at slot ${index + 1}`);
    }
    
    return {
      supportId: supportId.trim(),
      level: (level || '1').trim()
    };
  });
  
  // Validate we have exactly 6 slots
  if (slots.length !== 6) {
    throw new Error(`Expected 6 slots, got ${slots.length}`);
  }
  
  return slots;
}

// Update the validateLevel function to handle string inputs
function validateLevel(level, card) {
  let num = parseInt(level);
  if (isNaN(num) || num < 1) return 1;
  
  const maxLevel = getMaxLevel(card);
  if (num > maxLevel) return maxLevel;
  
  return num;
}

function debugSkillPaste() {
  const copyBtn = document.getElementById('copySkillsBtn');
  const pasteBtn = document.getElementById('pasteSkillsBtn');
  
  console.log('Copy button exists:', !!copyBtn);
  console.log('Paste button exists:', !!pasteBtn);
  console.log('Current skill searches:', skillSearches);
  console.log('Skill search keys:', SKILL_SEARCH_KEYS);
  
  if (copyBtn && pasteBtn) {
    console.log('Event listeners should be attached');
  }
}

/* ------------- EFFECT PROGRESSION CALCULATION ------------- */
const EFFECT_TYPES = {
  1: "Friendship Bonus",
  2: "Mood Effect", 
  3: "Speed Bonus",
  4: "Stamina Bonus",
  5: "Power Bonus",
  6: "Guts Bonus",
  7: "Wit Bonus",
  8: "Training Effectiveness",
  9: "Initial Speed",
  10: "Initial Stamina",
  11: "Initial Power",
  12: "Initial Guts",
  13: "Initial Wit",
  14: "Initial Friendship Gauge",
  15: "Race Bonus",
  16: "Fan Bonus",
  17: "Hint Levels",
  18: "Hint Frequency",
  19: "Specialty Priority",
  // NOTE THE GAPS: 20-24 are missing
  25: "Event Recovery",
  26: "Event Effectiveness", 
  27: "Failure Protection",
  28: "Energy Cost Reduction",
  // 29 is missing
  30: "Skill Point Bonus",
  31: "Wit Friendship Recovery",
  32: "Initial Skill Points Up",
  // 33-40 are missing
  41: "All Stats Bonus"
};

let supportsDataWithEffects = [];

function loadSupportsData() {
  return fetch('supports.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to fetch supports.json: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      console.log('Loaded supports.json with effects data:', data.length, 'cards');
      supportsDataWithEffects = data;
      return data;
    })
    .catch(error => {
      console.error('Error loading supports.json:', error);
      return [];
    });
}

// Progression calculation functions
function clamp(x, min, max) {
  return Math.max(min, Math.min(x, max));
}

function computeGrowth(knownLevels, knownValues, n) {
  if (knownLevels.length === 0) return 0;
  if (knownLevels.length === 1) return knownValues[0];

  const y1 = knownValues[0];
  let total = y1;

  for (let i = 0; i < knownLevels.length - 1; i++) {
    const L1 = knownLevels[i];
    const L2 = knownLevels[i + 1];
    const v1 = knownValues[i];
    const v2 = knownValues[i + 1];
    const slope = (v2 - v1) / (L2 - L1);
    total += slope * clamp(n - L1, 0, L2 - L1);
  }

  return total;
}

function parseCardData(data) {
  if (!Array.isArray(data) || data.length < 2) {
    return { id: data[0], knownLevels: [], knownValues: [] };
  }

  const id = data[0];
  const init = data[1];
  const baseLevels = [1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
  const limits = data.slice(2);

  const knownLevels = [];
  const knownValues = [];

  if (init !== undefined && init !== -1) {
    knownLevels.push(1);
    knownValues.push(init);
  }

  for (let i = 0; i < limits.length && (i + 1) < baseLevels.length; i++) {
    const val = limits[i];
    const lvl = baseLevels[i + 1];
    if (val !== undefined && val !== -1) {
      knownLevels.push(lvl);
      knownValues.push(val);
    }
  }

  return { id, knownLevels, knownValues };
}

function getEffectValueAtLevel(effectData, level) {
  try {
    const { knownLevels, knownValues } = parseCardData(effectData);
    
    if (knownLevels.length === 0) return 0;
    
    return computeGrowth(knownLevels, knownValues, level);
  } catch (error) {
    console.warn('Error calculating effect value:', error, effectData);
    return 0;
  }
}

/* ------------- EFFECT VALUE AT CURRENT LEVEL ------------- */
function getEffectValueAtCurrentLevel(card, effectId, level) {
  // Find the card with effects data
  const cardWithEffects = findCardWithEffects(card.support_id);
  
  if (!cardWithEffects || !cardWithEffects.effects) {
    return null;
  }
  
  // Find the effect data for this effect ID
  const effectData = cardWithEffects.effects.find(effect => effect[0] === effectId);
  
  if (!effectData) {
    return 0; // Effect not found, return 0
  }
  
  // Get the value at CURRENT LEVEL instead of max level
  const currentValue = getEffectValueAtLevel(effectData, level);
  
  // ADD UNIQUE EFFECTS IF APPLICABLE AT CURRENT LEVEL
  if (shouldApplyUniqueEffects(card, level)) {
    const uniqueValue = getUniqueEffectValue(card, effectId);
    return currentValue + uniqueValue;
  }
  
  return currentValue;
}

function findCardWithEffects(supportId) {
  if (!supportsDataWithEffects || supportsDataWithEffects.length === 0) {
    console.warn('supportsDataWithEffects not loaded yet');
    return null;
  }
  
  const card = supportsDataWithEffects.find(c => c.support_id == supportId);
  return card;
}

// Calculate individual card contributions for each effect
function calculateEffectContributions() {
  console.log('Calculating effect contributions...');
  const contributions = {};
  
  // Initialize structure for each effect type
  Object.values(EFFECT_TYPES).forEach(effectName => {
    contributions[effectName] = {
      total: 0,
      cards: [] // Array of { supportId, value, level, char_name }
    };
  });

  // Iterate through all slots with cards
  const slots = document.querySelectorAll('.slot');
  
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const slotContainer = slot.closest('.slot-container');
      const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
      const level = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
      
      // Find card in supports.json (which has the effects data)
      const card = findCardWithEffects(supportId);
      
      if (card && card.effects) {
        // Calculate values for each effect at this card's level
        card.effects.forEach(effectData => {
          const effectId = effectData[0];
          const effectName = EFFECT_TYPES[effectId];
          
          if (effectName) {
            const value = getEffectValueAtLevel(effectData, level);
            
            if (value > 0) { // Only show cards that actually contribute
              contributions[effectName].total += value;
              contributions[effectName].cards.push({
                supportId: supportId,
                value: value,
                level: level,
                char_name: card.char_name
              });
            }
          }
        });
      }
    }
  });
  
  return contributions;
}

// Update the unit mapping to put Lv before the number
const EFFECT_UNITS = {
  1: "%",   // Friendship Bonus
  2: "%",   // Mood Effect
  3: "",    // Speed Bonus
  4: "",    // Stamina Bonus
  5: "",    // Power Bonus
  6: "",    // Guts Bonus
  7: "",    // Wit Bonus
  8: "%",   // Training Effectiveness
  9: "",    // Initial Speed
  10: "",   // Initial Stamina
  11: "",   // Initial Power
  12: "",   // Initial Guts
  13: "",   // Initial Wit
  14: "",   // Initial Friendship Gauge
  15: "%",  // Race Bonus
  16: "%",  // Fan Bonus
  17: "Lv ", // Hint Levels
  18: "%",  // Hint Frequency
  19: "",   // Specialty Priority
  25: "%",  // Event Recovery
  26: "%",  // Event Effectiveness
  27: "%",  // Failure Protection
  28: "%",  // Energy Cost Reduction
  30: "",   // Skill Point Bonus
  31: "%",  // Wit Friendship Recovery
  32: "",   // Initial Skill Points Up
  41: ""    // All Stats Bonus
};

// Then update the display logic to handle prefix vs suffix units
function updateEffectTotals() {
  try {
    console.log('Updating effect totals UI with card contributions...');
    const contributions = calculateEffectContributions();
    const isCollapsed = document.getElementById('rightSidebar').classList.contains('collapsed');
    
    // Check if any slots have cards
    const hasCards = document.querySelectorAll('.slot.has-card').length > 0;
    
    // Update each effect display
    Object.entries(contributions).forEach(([effectName, data]) => {
      // Find all elements for this effect
      const effectElements = document.querySelectorAll(`[data-effect="${effectName}"]`);
      
      effectElements.forEach(element => {
        // Hide entire row if total is 0 and no cards contribute, OR if deck is empty
        if ((data.total === 0 && data.cards.length === 0) || !hasCards) {
          element.style.display = 'none';
          
          // Also reset the values to 0 when hiding
          const valueSpan = element.querySelector('.effect-value');
          if (valueSpan) {
            valueSpan.textContent = '0';
          }
          
          const cardsContainer = element.querySelector('.effect-cards');
          if (cardsContainer) {
            cardsContainer.innerHTML = '';
          }
          return;
        }
        
        // Show the row if it has values
        element.style.display = 'flex';
        
        // Update the total value with appropriate unit
        const valueSpan = element.querySelector('.effect-value');
        if (valueSpan) {
          // Find the effect ID from the effect name
          const effectId = Object.keys(EFFECT_TYPES).find(key => 
            EFFECT_TYPES[key] === effectName
          );
          const unit = EFFECT_UNITS[effectId] || "";
          const formattedValue = Number.isInteger(data.total) ? 
            data.total.toString() : data.total.toFixed(1);
          
          // Check if unit is "Lv " (prefix) or something else (suffix)
          if (unit === "Lv ") {
            valueSpan.textContent = unit + formattedValue; // Lv before number
          } else {
            valueSpan.textContent = formattedValue + unit; // unit after number
          }
        }

        // Update the card contributions - hide in collapsed mode
        const cardsContainer = element.querySelector('.effect-cards');
        if (cardsContainer) {
          if (isCollapsed) {
            cardsContainer.style.display = 'none';
          } else {
            cardsContainer.style.display = 'flex';
            cardsContainer.innerHTML = '';
            
            // Sort cards by value (highest first) for consistent display
            const sortedCards = [...data.cards].sort((a, b) => b.value - a.value);
            
            // Add card icons for each contributing card
            sortedCards.forEach(cardData => {
              const cardElement = document.createElement('div');
              cardElement.className = 'effect-card';
              
              // Find the effect ID for this specific card's effect
              const card = findCardWithEffects(cardData.supportId);
              let unit = "";
              if (card && card.effects) {
                const effectData = card.effects.find(effect => 
                  EFFECT_TYPES[effect[0]] === effectName
                );
                if (effectData) {
                  unit = EFFECT_UNITS[effectData[0]] || "";
                }
              }
              
              const formattedCardValue = Number.isInteger(cardData.value) ? 
                cardData.value.toString() : cardData.value.toFixed(1);
              
              // Handle prefix vs suffix for tooltip
              let tooltipValue;
              if (unit === "Lv ") {
                tooltipValue = unit + formattedCardValue;
              } else {
                tooltipValue = formattedCardValue + unit;
              }
              
              cardElement.title = `${cardData.char_name} (Lv. ${cardData.level}): +${tooltipValue}`;
              
              // Handle prefix vs suffix for card display
              let displayValue;
              if (unit === "Lv ") {
                displayValue = unit + formattedCardValue;
              } else {
                displayValue = "+" + formattedCardValue + unit;
              }
              
              cardElement.innerHTML = `
                <img src="https://gametora.com/images/umamusume/supports/support_card_s_${cardData.supportId}.png" 
                    alt="${cardData.char_name}" 
                    class="effect-card-img">
                <div class="effect-card-value">${displayValue}</div>
              `;
              
              cardsContainer.appendChild(cardElement);
            });
            
            // Handle many cards - enable horizontal scroll if more than 6
            if (sortedCards.length > 6) {
              cardsContainer.classList.add('has-many-cards');
            } else {
              cardsContainer.classList.remove('has-many-cards');
            }
          }
        }
      });
    });
    
    // If no cards at all, ensure all effects are hidden and reset
    if (!hasCards) {
      document.querySelectorAll('.effect-row').forEach(row => {
        row.style.display = 'none';
        const valueSpan = row.querySelector('.effect-value');
        if (valueSpan) valueSpan.textContent = '0';
        const cardsContainer = row.querySelector('.effect-cards');
        if (cardsContainer) cardsContainer.innerHTML = '';
      });
    }
  } catch (error) {
    console.error('Error updating effect totals:', error);
  }
}

// Override the existing functions to include effect calculation
function setupEffectCalculation() {
  console.log('Setting up effect calculation with card contributions...');
  
  // Store original functions
  const originalAddToSlot = window.addToSlot;
  const originalRemoveFromSlot = window.removeFromSlot;
  
  // Override addToSlot to include effect calculation
  window.addToSlot = function(card, targetSlot = null, save = true) {
    const result = originalAddToSlot(card, targetSlot, save);
    
    setTimeout(() => {
      updateEffectTotals();
      
      const slot = targetSlot || document.querySelector('.slot[data-support-id]:not(.has-card)');
      if (slot) {
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        if (levelInput) {
          levelInput.addEventListener('change', updateEffectTotals);
          levelInput.addEventListener('input', updateEffectTotals);
        }
      }
    }, 100);
    
    return result;
  };
  
  // Override removeFromSlot to include effect calculation
  window.removeFromSlot = function(slot, card) {
    const result = originalRemoveFromSlot(slot, card);
    
    setTimeout(() => {
      updateEffectTotals();
    }, 100);
    
    return result;
  };
  
  // Set up level input listeners for existing slots
  document.querySelectorAll('.slot-level-input').forEach(input => {
    input.addEventListener('change', updateEffectTotals);
    input.addEventListener('input', updateEffectTotals);
  });

  
  // Initial calculation after data is loaded
  setTimeout(updateEffectTotals, 1500);
}

// Initialize when both datasets are loaded
function initializeEffectCalculation() {
  console.log('Initializing effect calculation system...');
  
  loadSupportsData().then(() => {
    console.log('supports.json loaded, waiting for transformed_supports.json...');
    
    const checkDataLoaded = setInterval(() => {
      if (window.cardsData && window.cardsData.length > 0) {
        clearInterval(checkDataLoaded);
        console.log('Both datasets loaded, setting up effect calculation');
        setupEffectCalculation();
      }
    }, 100);
  });
}

// Start initialization
document.addEventListener('DOMContentLoaded', initializeEffectCalculation);

// Also trigger calculation when deck is pasted
document.addEventListener('DOMContentLoaded', function() {
  if (window.pasteDeckFromClipboard) {
    const originalPasteDeck = window.pasteDeckFromClipboard;
    window.pasteDeckFromClipboard = function() {
      return originalPasteDeck().then(() => {
        setTimeout(updateEffectTotals, 500);
      });
    };
  }
});

// Manual trigger for debugging
window.updateEffects = updateEffectTotals;
window.getCardEffects = findCardWithEffects;

/* ------------- COLLAPSIBLE SIDEBAR FUNCTIONALITY ------------- */
function setupCollapsibleSidebar() {
  const rightSidebar = document.getElementById('rightSidebar');
  const collapseToggle = document.getElementById('collapseSidebar');
  
  // Load saved state
  const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';

  // Set initial state
  if (isCollapsed) {
    rightSidebar.classList.add('collapsed');
    collapseToggle.textContent = '◀'; // Arrow pointing LEFT when collapsed
    collapseToggle.title = 'Expand sidebar';
  } else {
    collapseToggle.textContent = '▶'; // Arrow pointing RIGHT when expanded
    collapseToggle.title = 'Collapse sidebar';
  }

  collapseToggle.addEventListener('click', () => {
    const isNowCollapsed = !rightSidebar.classList.contains('collapsed');
    
    if (isNowCollapsed) {
      rightSidebar.classList.add('collapsed');
      collapseToggle.textContent = '◀';
      collapseToggle.title = 'Expand sidebar';
      localStorage.setItem('sidebarCollapsed', 'true');
    } else {
      rightSidebar.classList.remove('collapsed');
      collapseToggle.textContent = '▶';
      collapseToggle.title = 'Collapse sidebar';
      localStorage.setItem('sidebarCollapsed', 'false');
    }
    
    // Update effect totals to ensure proper display
    setTimeout(updateEffectTotals, 50);
    
    // SIMPLE FIX: Force cards to recalculate layout after sidebar animation
    setTimeout(() => {
      sectionPages.clear();
      renderSections();
    }, 100); // Small delay to ensure CSS transition completes
  });
}

// Initialize when the page loads
document.addEventListener('DOMContentLoaded', function() {
  setupCollapsibleSidebar();
});

/* ------------- UNIQUE EFFECTS CALCULATION ------------- */
function shouldApplyUniqueEffects(card, level) {
  if (!card.unique || !card.unique.effects || card.unique.effects.length === 0) {
    return false;
  }
  
  const rarity = card.rarity;
  const threshold = rarity === 1 ? 20 : rarity === 2 ? 25 : 30;
  
  return level >= threshold;
}

function getUniqueEffectValue(card, effectType) {
  if (!card.unique || !card.unique.effects) return 0;
  
  const uniqueEffect = card.unique.effects.find(effect => effect.type === effectType);
  return uniqueEffect ? uniqueEffect.value : 0;
}

function calculateEffectContributions() {
  console.log('Calculating effect contributions...');
  const contributions = {};
  
  // Initialize structure for each effect type
  Object.values(EFFECT_TYPES).forEach(effectName => {
    contributions[effectName] = {
      total: 0,
      cards: [] // Array of { supportId, value, level, char_name }
    };
  });

  // Iterate through all slots with cards
  const slots = document.querySelectorAll('.slot');
  
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const slotContainer = slot.closest('.slot-container');
      const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
      const level = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
      
      // Find card in supports.json (which has the effects data)
      const card = findCardWithEffects(supportId);
      
      if (card && card.effects) {
        // Calculate values for each effect at this card's level
        card.effects.forEach(effectData => {
          const effectId = effectData[0];
          const effectName = EFFECT_TYPES[effectId];
          
          if (effectName) {
            let value = getEffectValueAtLevel(effectData, level);
            
            // ADD UNIQUE EFFECTS IF LEVEL THRESHOLD IS MET
            if (shouldApplyUniqueEffects(card, level)) {
              const uniqueValue = getUniqueEffectValue(card, effectId);
              value += uniqueValue;
            }
            
            if (value > 0) { // Only show cards that actually contribute
              contributions[effectName].total += value;
              contributions[effectName].cards.push({
                supportId: supportId,
                value: value,
                level: level,
                char_name: card.char_name,
                hasUnique: shouldApplyUniqueEffects(card, level) && getUniqueEffectValue(card, effectId) > 0
              });
            }
          }
        });
      }
    }
  });
  
  return contributions;
}

// Function to update unique effects display based on current level
function updateUniqueEffectsDisplay(slot, card, level) {
    const uniqueEffects = slot.querySelectorAll('.skills-group:last-child .skill');
    if (uniqueEffects.length > 0 && card.unique && card.unique.effects) {
        uniqueEffects.forEach((effectElement, index) => {
            const uniqueEffect = card.unique.effects[index];
            if (uniqueEffect) {
                const threshold = card.rarity === 1 ? 20 : card.rarity === 2 ? 25 : 30;
                const isActive = level >= threshold;
                const activeStyle = isActive ? 'background: #f0fff0; border-left: 3px solid #44ff44;' : 'background: #fff0f0; border-left: 3px solid #ff4444;';
                
                effectElement.style.cssText = activeStyle;
                // Update the status indicator
                const text = effectElement.textContent;
                const newText = text.replace(/✅|🔒/g, isActive ? '✅' : '🔒');
                effectElement.textContent = newText;
            }
        });
    }
}

// Debug function to see all saved levels
function debugSavedLevels() {
    console.log('All saved card levels:', slotLevels);
    // Show in alert for easy checking
    const levelCount = Object.keys(slotLevels).length;
    alert(`Saved levels for ${levelCount} cards:\n${JSON.stringify(slotLevels, null, 2)}`);
}

// Add debug button to help troubleshoot
function addDebugButton() {
    const debugBtn = document.createElement('button');
    debugBtn.textContent = 'Debug Levels';
    debugBtn.style.position = 'fixed';
    debugBtn.style.bottom = '10px';
    debugBtn.style.right = '10px';
    debugBtn.style.zIndex = '10000';
    debugBtn.style.padding = '5px';
    debugBtn.style.fontSize = '10px';
    debugBtn.style.background = '#ff4444';
    debugBtn.style.color = 'white';
    debugBtn.style.border = 'none';
    debugBtn.style.borderRadius = '3px';
    debugBtn.style.cursor = 'pointer';
    debugBtn.addEventListener('click', debugSavedLevels);
    
    document.body.appendChild(debugBtn);
}

// Initialize debug button in development
// addDebugButton(); // Uncomment if you need to debug level saving

/* ------------- SORTING HELPER FUNCTIONS ------------- */
function formatDateForDisplay(dateString) {
  if (!dateString) return 'Unknown';
  
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return dateString; // Return original if invalid
    
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  } catch (e) {
    return dateString; // Return original if parsing fails
  }
}

/* ------------- UPDATE getEffectValueForSorting FUNCTION ------------- */
function getEffectValueForSorting(card, effectId) {
  // Find the card with effects data
  const cardWithEffects = findCardWithEffects(card.support_id);
  
  if (!cardWithEffects || !cardWithEffects.effects) {
    return null;
  }
  
  // Find the effect data for this effect ID
  const effectData = cardWithEffects.effects.find(effect => effect[0] === effectId);
  
  if (!effectData) {
    return 0; // Effect not found, return 0
  }
  
  // Get the MAX LEVEL value instead of base value
  const maxLevel = getMaxLevel(card);
  const maxValue = getEffectValueAtLevel(effectData, maxLevel);
  
  // ADD UNIQUE EFFECTS AT MAX LEVEL
  if (shouldApplyUniqueEffects(card, maxLevel)) {
    const uniqueValue = getUniqueEffectValue(card, effectId);
    return maxValue + uniqueValue;
  }
  
  return maxValue;
}


/* ------------- UPDATE SLOTS FOR SORT CHANGE ------------- */
function updateSlotsForSortChange() {
  slots.forEach(slot => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        // Remove the existing slot content
        if (slotListeners.has(slot)) {
          slot.removeEventListener('click', slotListeners.get(slot));
          slotListeners.delete(slot);
        }
        
        // Re-add the card with updated display data
        addToSlot(card, slot, false);
      }
    }
  });
  
  // Save the updated slots
  saveSlotsToLocalStorage();
}

/* ------------- SMART RENDER DETECTION ------------- */
function needsFullRender() {
  // Check if any filters, searches, or sorting changed that would affect card visibility
  const currentFilterState = JSON.stringify({
    racecourse: document.getElementById('racecourse').value,
    length: document.getElementById('length').value,
    direction: document.getElementById('direction').value,
    track: document.getElementById('track').value,
    season: document.getElementById('season').value,
    weather: document.getElementById('weather').value,
    strategy: document.getElementById('strategy').value,
    skillSearches: SKILL_SEARCH_KEYS.map(key => document.getElementById(key)?.value.trim()).filter(Boolean),
    cardSearch: cardSearchValue,
    rarities: Array.from(selectedRarities),
    types: Array.from(selectedTypes),
    sortBy: sortBy,
    sortOrder: sortOrder,
    region: region
  });
  
  // Store the last state to compare against
  if (!window.lastFilterState) {
    window.lastFilterState = currentFilterState;
    return true; // First render
  }
  
  const needsRender = window.lastFilterState !== currentFilterState;
  window.lastFilterState = currentFilterState;
  return needsRender;
}

/* ------------- DEBUG SLOT STATUS ------------- */
function debugSlotStatus() {
  console.log('=== SLOT DEBUG INFO ===');
  slots.forEach((slot, index) => {
    console.log(`Slot ${index}:`, {
      hasCard: slot.classList.contains('has-card'),
      supportId: slot.dataset.supportId,
      cardId: slot.dataset.cardId,
      name: slot.querySelector('.name')?.textContent,
      effectText: slot.querySelector('.name')?.nextElementSibling?.textContent
    });
  });
}

/* ------------- UPDATE ALL SLOT DISPLAYS ------------- */
function updateAllSlotDisplays() {
  console.log('Updating all slot displays...');
  
  slots.forEach((slot, index) => {
    if (slot.dataset.supportId) {
      const supportId = slot.dataset.supportId;
      const card = cardsData.find(c => String(c.support_id) === String(supportId));
      
      if (card) {
        console.log(`Updating slot ${index} with card: ${card.char_name}`);
        const slotContainer = slot.closest('.slot-container');
        const levelInput = slotContainer ? slotContainer.querySelector('.slot-level-input') : null;
        const currentLevel = levelInput && !levelInput.disabled ? parseInt(levelInput.value) || 1 : 1;
        
        // Update the name section with effect data
        updateSlotNameWithEffectData(slot, card, currentLevel);
      }
    } else {
      console.log(`Slot ${index} is empty`);
    }
  });
}

/* ------------- ENSURE SLOTS LOAD PROPERLY ------------- */
function ensureSlotsLoaded() {
  console.log('Ensuring slots are properly loaded...');
  
  // Check if we have slots with cards but no effect text
  const slotsWithCards = Array.from(slots).filter(slot => slot.dataset.supportId);
  
  if (slotsWithCards.length > 0) {
    console.log(`Found ${slotsWithCards.length} slots with cards, verifying effect text...`);
    
    let needsUpdate = false;
    slotsWithCards.forEach(slot => {
      const nameContainer = slot.querySelector('.name');
      if (nameContainer) {
        const effectText = nameContainer.nextElementSibling;
        // If there's no effect text element after the name, we need to update
        if (!effectText || !effectText.style || effectText.style.fontSize !== '8px') {
          needsUpdate = true;
        }
      }
    });
    
    if (needsUpdate) {
      console.log('Slots need effect text update, forcing refresh...');
      updateAllSlotDisplays();
    }
  }
}

// Call this in console if you need to debug: debugSlotStatus()

// ---------- DOCUMENT ------------------------------------------------------------------

// Initialize when the page loads
document.addEventListener('DOMContentLoaded', function() {
  // Wait for cards data to be loaded
  const checkDataLoaded = setInterval(() => {
    if (cardsData && cardsData.length > 0) {
      clearInterval(checkDataLoaded);
      setTimeout(() => {
        setupEffectCalculation();
        updateEffectTotals();
      }, 1000);
    }
  }, 100);
});


  
  // Update when pasting decks
  const originalPasteDeck = window.pasteDeckFromClipboard;
  if (originalPasteDeck) {
    window.pasteDeckFromClipboard = function() {
      originalPasteDeck().then(() => {
        setTimeout(updateEffectTotals, 500);
      });
    };
  }


// Initialize the copy/paste buttons when the page loads
document.addEventListener('DOMContentLoaded', setupCopyPasteButtons);

</script>
</body>
</html>